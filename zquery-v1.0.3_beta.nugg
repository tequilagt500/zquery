<?xml version="1.0" encoding="utf-16"?>
<nugget name="ZQUERY">
 <CLAS CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" VERSION="1" LANGU="E" UUID="E4772CD16E157BF18FF40050569504A2" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="701" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <publicSection>class ZCL_ZQUERY_DATA_TRANSFER definition
  public
  create public .

*&quot;* public components of class ZCL_ZQUERY_DATA_TRANSFER
*&quot;* do not include other source files here!!!
public section.

  class-methods SET_DATA
    importing
      !I_DATA type ref to DATA .
  class-methods GET_DATA
    returning
      value(RETURN) type ref to DATA .</publicSection>
  <protectedSection>*&quot;* protected components of class ZCL_ZQUERY_DATA_TRANSFER
*&quot;* do not include other source files here!!!
protected section.</protectedSection>
  <privateSection>*&quot;* private components of class ZCL_ZQUERY_DATA_TRANSFER
*&quot;* do not include other source files here!!!
private section.

  class-data O_DATA type ref to DATA .</privateSection>
  <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
  <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" CMPNAME="O_DATA" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " R3RELEASE="701" TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" CMPNAME="GET_DATA" VERSION="1" LANGU="E" DESCRIPT="Get Data" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="701" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" CMPNAME="GET_DATA" SCONAME="RETURN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="DATA"/>
   <source>method GET_DATA.
  return = o_data.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" CMPNAME="SET_DATA" VERSION="1" LANGU="E" DESCRIPT="Set Data to transfer" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" MTDTYPE="0" MTDDECLTYP="1" R3RELEASE="701" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_ZQUERY_DATA_TRANSFER" CMPNAME="SET_DATA" SCONAME="I_DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="ALCANTARA" CREATEDON="20141128" CHANGEDBY="ALCANTARA" CHANGEDON="20141215" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
   <source>method SET_DATA.
  o_data = i_data.
endmethod.</source>
  </method>
 </CLAS>
 <PROG NAME="ZQUERY" VARCL="X" SUBC="1" CNAM="ALCANTARA" CDAT="20140919" UNAM="ALCANTARA" UDAT="20141219" VERN="000137" RSTAT="K" RMAND="810" RLOAD="P" FIXPT="X" SDATE="20141219" STIME="145634" IDATE="20141219" ITIME="141449" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="I" KEY="001" ENTRY="Query is syntactically correct." LENGTH="40 "/>
    <textElement ID="I" KEY="002" ENTRY="Query saved successfully." LENGTH="40 "/>
    <textElement ID="I" KEY="003" ENTRY="Performance Analyzer" LENGTH="30 "/>
    <textElement ID="I" KEY="004" ENTRY="Inverse Names" LENGTH="20 "/>
    <textElement ID="I" KEY="005" ENTRY="Generate Type" LENGTH="20 "/>
    <textElement ID="I" KEY="006" ENTRY="Performance Analyzer" LENGTH="30 "/>
    <textElement ID="I" KEY="007" ENTRY="Type name" LENGTH="20 "/>
    <textElement ID="I" KEY="008" ENTRY="SQL Statement" LENGTH="20 "/>
    <textElement ID="I" KEY="009" ENTRY="ABAP Procedures" LENGTH="20 "/>
    <textElement ID="I" KEY="010" ENTRY="Query name" LENGTH="20 "/>
    <textElement ID="I" KEY="011" ENTRY="Overwrite existing query?" LENGTH="31 "/>
    <textElement ID="I" KEY="012" ENTRY="The selected record(s) will be deleted. Are you sure?" LENGTH="70 "/>
    <textElement ID="I" KEY="013" ENTRY="Table Name" LENGTH="15 "/>
    <textElement ID="I" KEY="014" ENTRY="Field Name" LENGTH="15 "/>
    <textElement ID="I" KEY="015" ENTRY="Description" LENGTH="15 "/>
    <textElement ID="I" KEY="016" ENTRY="Select fields to WHERE clause" LENGTH="45 "/>
    <textElement ID="I" KEY="017" ENTRY="WHERE Generator" LENGTH="20 "/>
    <textElement ID="I" KEY="018" ENTRY="Yes" LENGTH="3 "/>
    <textElement ID="I" KEY="019" ENTRY="No" LENGTH="3 "/>
    <textElement ID="I" KEY="E01" ENTRY="No query entry to execute" LENGTH="30 "/>
    <textElement ID="I" KEY="E02" ENTRY="Canceled" LENGTH="10 "/>
    <textElement ID="I" KEY="E03" ENTRY="Allowed only 70 fields or less" LENGTH="50 "/>
    <textElement ID="I" KEY="E04" ENTRY="No queries found" LENGTH="30 "/>
    <textElement ID="S" KEY="P_QNAME" ENTRY="        Query Name" LENGTH="18 "/>
    <textElement ID="S" KEY="S_USER" ENTRY="D       ." LENGTH="17 "/>
   </language>
  </textPool>
  <dynpros>
   <dynpro PROG="ZQUERY" DNUM="0100" FNUM="0100" BZMX="200 " BZBR="240 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="200 " NOCO="240 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141215" TGEN="203131" DTEXT="Tela Inicial">
    <dynprofield FNAM="C_CONTAINER" DIDX="00C8" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="F0" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0100.
  MODULE zm_initialize_0100.

PROCESS AFTER INPUT.
  MODULE zm_user_command_0100.
  MODULE zm_exit_command_0100 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="0200" TYPE="M" FNUM="0200" BZMX="21 " BZBR="102 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="21 " NOCO="110 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141215" TGEN="203131" DTEXT="Type Generator">
    <dynprofield FNAM="C_TYPE_CONTAINER" DIDX="0015" FLG1="00" FLG2="00" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="66" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0200.
  MODULE zm_initialize_0200.

PROCESS AFTER INPUT.
  MODULE zm_user_command_0200.
  MODULE zm_exit_command_0200 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="0300" TYPE="M" FNUM="0300" BZMX="30 " BZBR="146 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="30 " NOCO="146 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141215" TGEN="203131" DTEXT="Performance Analyzer">
    <dynprofield FNAM="GRAPH_CONTAINER" DIDX="001D" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="92" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
    <dynprofield FNAM="%#AUTOTEXT001" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FILL="P" FMB1="30" FMB2="00" LENG="06" LINE="1E" COLN="8E" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="Close" RES1="                                                                                                                                                                        ENTER"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0300.
  MODULE zm_initialize_0300.

PROCESS AFTER INPUT.
  MODULE zm_user_command_0300.
  MODULE zm_exit_command_0300 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="0500" TYPE="M" FNUM="0500" BZMX="200 " BZBR="240 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="200 " NOCO="240 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141215" TGEN="203131" DTEXT="SELECT fields for user interaction">
    <dynprofield FNAM="V_SELECT_TYPE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0B" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Select Type" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="V_SELECT_TYPE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________" RES1=" DL                                                                                                                                                                     SQL_FUNC"/>
    <dynprofield FNAM="CONTAINER" DIDX="00C7" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="F0" LINE="02" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0500.
  MODULE zm_initialize_0500.

PROCESS AFTER INPUT.
  MODULE zm_user_command_0500.
  MODULE zm_exit_command_0500 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="0600" TYPE="M" FNUM="0600" BZMX="200 " BZBR="240 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="200 " NOCO="240 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141217" TGEN="135921" DTEXT="Screen for FROM generator">
    <dynprofield FNAM="%#AUTOTEXT001" DIDX="0005" FLG1="00" FLG2="00" FLG3="00" FILL="R" FMB1="30" FMB2="00" LENG="73" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="101" AGLT="00" ADEZ="00" STXT="Parameters"/>
    <dynprofield FNAM="V_TABNAME" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0F" LINE="02" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Table Name" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="V_TABNAME" DIDX="0000" FLG1="80" FLG2="00" FLG3="A0" FMB1="00" FMB2="08" LENG="22" LINE="02" COLN="13" LANF="00" LBLK="00" LREP="00" PAID="DTB" TYPE="CHAR" DMAC="DD_DBTB_16" ITYP="C" AGLT="1E" ADEZ="00" STXT="__________________________________"/>
    <dynprofield FNAM="V_TABDESCR" DIDX="0000" FLG1="80" FLG2="02" FLG3="80" FMB1="31" FMB2="00" LENG="3C" LINE="02" COLN="37" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="3C" ADEZ="00" STXT="____________________________________________________________"/>
    <dynprofield FNAM="V_TABALIAS" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0B" LINE="03" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Table Alias" RES1="                                                                                                                                                                                                                                                        X"/>
    <dynprofield FNAM="V_TABALIAS" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FMB1="00" FMB2="00" LENG="22" LINE="03" COLN="13" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="__________________________________"/>
    <dynprofield FNAM="V_CREATE_SELECT" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="16" LINE="04" COLN="03" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="0" AGLT="00" ADEZ="00" STXT="Generate SELECT clause"/>
    <dynprofield FNAM="V_CREATE_SELECT" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="04" COLN="1A" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="102" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="V_CREATE_WHERE" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FILL="C" FMB1="30" FMB2="00" LENG="15" LINE="04" COLN="1E" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" ITYP="0" AGLT="00" ADEZ="00" STXT="Generate WHERE Clause"/>
    <dynprofield FNAM="V_CREATE_WHERE" DIDX="0000" FLG1="80" FLG2="00" FLG3="80" FILL="C" FMB1="00" FMB2="00" LENG="01" LINE="04" COLN="34" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" ITYP="C" AGLT="00" ADEZ="00"/>
    <dynprofield FNAM="CONTAINER_FROM" DIDX="00C3" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="F0" LINE="06" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="104" AGLT="01" ADEZ="01"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0600.
  MODULE zm_initialize_0600.

PROCESS AFTER INPUT.
  FIELD v_create_select. FIELD v_create_where.
  FIELD v_tabname MODULE zm_tablename ON REQUEST.
  FIELD v_tabalias MODULE zm_tablealias ON REQUEST.

  MODULE zm_user_command_0600.
  MODULE zm_exit_command_0600 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
   <dynpro PROG="ZQUERY" DNUM="0700" TYPE="M" FNUM="0700" BZMX="0 " BZBR="0 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="200 " NOCO="240 " VALP="0 " CUAN="G" SPRA="E" DGEN="20141215" TGEN="203132" DTEXT="Screen for Fields of a Join Table">
    <dynprofield FNAM="CONTAINER_JOIN" DIDX="00C8" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="F0" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="01" ADEZ="01"/>
    <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
    <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE zm_status_0700.
  MODULE zm_initialize_0700.

PROCESS AFTER INPUT.
  MODULE zm_user_command_0700.
  MODULE zm_exit_command_0700 AT EXIT-COMMAND.</dynproflowsource>
   </dynpro>
  </dynpros>
  <pfstatus>
   <pfstatus_sta CODE="PF_0100" MODAL="D" ACTCODE="000001" PFKCODE="000002" BUTCODE="0001" INT_NOTE="Tela inicial"/>
   <pfstatus_sta CODE="PF_0200" MODAL="P" PFKCODE="000003" BUTCODE="0001" INT_NOTE="Type Generator"/>
   <pfstatus_sta CODE="PF_0500" MODAL="P" PFKCODE="000005" BUTCODE="0001" INT_NOTE="Status for screen 500"/>
   <pfstatus_sta CODE="PF_0600" MODAL="P" PFKCODE="000006" BUTCODE="0001" INT_NOTE="Status for screen 600"/>
   <pfstatus_sta CODE="PF_0700" MODAL="P" PFKCODE="000007" BUTCODE="0001" INT_NOTE="Status for screen 700"/>
   <pfstatus_sta CODE="PF_SALV_STATUS" MODAL="P" PFKCODE="000004" BUTCODE="0001" INT_NOTE="Standard for General List Output in Dialog Box with Checkbox"/>
   <pfstatus_fun CODE="%SC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Search" PATH="E"/>
   <pfstatus_fun CODE="%SC+" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Find Next"/>
   <pfstatus_fun CODE="&amp;AC1" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_fun CODE="&amp;ALL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_ALL" ICON_ID="@4B@" FUN_TEXT="Select All" PATH="S"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_SAVE" ICON_ID="@DN@" FUN_TEXT="Save Layout..."/>
   <pfstatus_fun CODE="&amp;CRB" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_LEFT" ICON_ID="@0B@" FUN_TEXT="First Column"/>
   <pfstatus_fun CODE="&amp;CRE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_RIGHT" ICON_ID="@0C@" FUN_TEXT="Last Column"/>
   <pfstatus_fun CODE="&amp;CRL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_LEFT" ICON_ID="@0D@" FUN_TEXT="Column Left"/>
   <pfstatus_fun CODE="&amp;CRR" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_RIGHT" ICON_ID="@0E@" FUN_TEXT="Column Right"/>
   <pfstatus_fun CODE="&amp;EB9" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TABLE_SETTINGS" ICON_ID="@36@" FUN_TEXT="Call Up Report..." PATH="B"/>
   <pfstatus_fun CODE="&amp;ELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_HELP" ICON_ID="@35@" FUN_TEXT="Help"/>
   <pfstatus_fun CODE="&amp;ERW" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_CHOOSE" ICON_ID="@DM@" FUN_TEXT="Administration..." ICON_TEXT="Admin" INFO_TEXT="Manage Layouts..." PATH="A"/>
   <pfstatus_fun CODE="&amp;ETA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Details"/>
   <pfstatus_fun CODE="&amp;IC1" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Choose"/>
   <pfstatus_fun CODE="&amp;ILD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_FILTER_UNDO" ICON_ID="@GD@" FUN_TEXT="Delete Filter" PATH="L"/>
   <pfstatus_fun CODE="&amp;ILT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_FILTER" ICON_ID="@4G@" FUN_TEXT="Set Filter" PATH="F"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_CHOOSE" ICON_ID="@DM@" FUN_TEXT="Select Layout..."/>
   <pfstatus_fun CODE="&amp;ODN" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_DOWN" ICON_ID="@3F@" FUN_TEXT="Sort in Descending Order" PATH="O"/>
   <pfstatus_fun CODE="&amp;OL0" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANTS" ICON_ID="@LZ@" FUN_TEXT="Change..."/>
   <pfstatus_fun CODE="&amp;OMP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLLAPSE" ICON_ID="@3T@" FUN_TEXT="Collapse"/>
   <pfstatus_fun CODE="&amp;ONT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
   <pfstatus_fun CODE="&amp;OUP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_UP" ICON_ID="@3E@" FUN_TEXT="Sort in Ascending Order" PATH="I"/>
   <pfstatus_fun CODE="&amp;RNT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PRINT" ICON_ID="@0X@" FUN_TEXT="Print" PATH="P"/>
   <pfstatus_fun CODE="&amp;SAL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_ALL" ICON_ID="@4D@" FUN_TEXT="Deselect All" PATH="D"/>
   <pfstatus_fun CODE="&amp;SUM" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INTERMEDIATE_SUM" ICON_ID="@5V@" FUN_TEXT="Subtotals..." PATH="T"/>
   <pfstatus_fun CODE="&amp;UMC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SUM" ICON_ID="@3Z@" FUN_TEXT="Total" PATH="T"/>
   <pfstatus_fun CODE="&amp;XPA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPAND" ICON_ID="@3S@" FUN_TEXT="Expand"/>
   <pfstatus_fun CODE="BACK" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Voltar"/>
   <pfstatus_fun CODE="BACK" TEXTNO="002" TEXT_TYPE="S" FUN_TEXT="Back"/>
   <pfstatus_fun CODE="CANCEL" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancelar"/>
   <pfstatus_fun CODE="CANCEL" TEXTNO="002" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
   <pfstatus_fun CODE="CHECK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CHECK" ICON_ID="@38@" FUN_TEXT="Check syntax" ICON_TEXT="Check"/>
   <pfstatus_fun CODE="DEL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DELETE" ICON_ID="@11@" FUN_TEXT="Delete" INFO_TEXT="Delete selected query(ies)"/>
   <pfstatus_fun CODE="ENTER" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Ok"/>
   <pfstatus_fun CODE="EXEC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute" ICON_TEXT="Execute"/>
   <pfstatus_fun CODE="EXEC_NO" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Exec. no conversion"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Encerrar"/>
   <pfstatus_fun CODE="EXIT" TEXTNO="002" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
   <pfstatus_fun CODE="FIELDS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CHOOSE_COLUMNS" ICON_ID="@HE@" FUN_TEXT="... SELECT clause" ICON_TEXT="Generate SELECT clause"/>
   <pfstatus_fun CODE="FROM" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="... FROM clause" PATH="F"/>
   <pfstatus_fun CODE="MINE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="My queries..." PATH="M"/>
   <pfstatus_fun CODE="OPEN" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Open query..." PATH="O"/>
   <pfstatus_fun CODE="P+" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Next Page"/>
   <pfstatus_fun CODE="P++" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Last Page"/>
   <pfstatus_fun CODE="P-" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Previous Page"/>
   <pfstatus_fun CODE="P--" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="First Page"/>
   <pfstatus_fun CODE="SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
   <pfstatus_fun CODE="SELECT" TEXTNO="001" TEXT_TYPE="S" ICON_ID="@HE@" FUN_TEXT="... SELECT clause" PATH="S"/>
   <pfstatus_fun CODE="WHERE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INSPECTION_METHOD" ICON_ID="@GS@" FUN_TEXT="... WHERE clause" ICON_TEXT="Generate WHERE clause" PATH="W"/>
   <pfstatus_men CODE="000006" NO="01" REF_TYPE="F" REF_CODE="OPEN" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="02" REF_TYPE="F" REF_CODE="MINE" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="03" REF_TYPE="F" REF_CODE="EXEC_NO" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="01" REF_TYPE="F" REF_CODE="SELECT" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="02" REF_TYPE="F" REF_CODE="FROM" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="03" REF_TYPE="F" REF_CODE="WHERE" REF_NO="001"/>
   <pfstatus_mtx CODE="000006" TEXT_TYPE="S" TEXT="Options" PATH="O"/>
   <pfstatus_mtx CODE="000007" TEXT_TYPE="S" TEXT="Generate" PATH="G"/>
   <pfstatus_act CODE="000001" NO="01" MENUCODE="000006"/>
   <pfstatus_act CODE="000001" NO="02" MENUCODE="000007"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="26"/>
   <pfstatus_but PFK_CODE="000001" CODE="0002" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000001" CODE="0003" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="01" PFNO="08"/>
   <pfstatus_but PFK_CODE="000002" CODE="0001" NO="02" PFNO="26"/>
   <pfstatus_but PFK_CODE="000003" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="02" PFNO="39"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="03" PFNO="37"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="04" PFNO="05"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="05" PFNO="06"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="06" PFNO="28"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="07" PFNO="40"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="08" PFNO="71"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="09" PFNO="84"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="10" PFNO="29"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="11" PFNO="38"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="12" PFNO="30"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="13" PFNO="42"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="14" PFNO="35"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="15" PFNO="47"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="16" PFNO="86"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="17" PFNO="32"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="18" PFNO="33"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="19" PFNO="34"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="20" PFNO="36"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="21" PFNO="01"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="22" PFNO="18"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="23" PFNO="26"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="24" PFNO="27"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="25" PFNO="19"/>
   <pfstatus_but PFK_CODE="000004" CODE="0001" NO="26" PFNO="94"/>
   <pfstatus_but PFK_CODE="000005" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000005" CODE="0001" NO="02" PFNO="12"/>
   <pfstatus_but PFK_CODE="000006" CODE="0001" NO="01" PFNO="11"/>
   <pfstatus_but PFK_CODE="000006" CODE="0001" NO="02" PFNO="12"/>
   <pfstatus_but PFK_CODE="000007" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_pfk CODE="000001" PFNO="00" FUNCODE="ENTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="BACK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="EXEC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="CANCEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="EXIT" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="26" FUNCODE="CHECK" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="03" FUNCODE="BACK" FUNNO="002"/>
   <pfstatus_pfk CODE="000002" PFNO="08" FUNCODE="EXEC" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="12" FUNCODE="CANCEL" FUNNO="002"/>
   <pfstatus_pfk CODE="000002" PFNO="15" FUNCODE="EXIT" FUNNO="002"/>
   <pfstatus_pfk CODE="000002" PFNO="18" FUNCODE="SELECT" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="19" FUNCODE="FROM" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="20" FUNCODE="WHERE" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="26" FUNCODE="CHECK" FUNNO="001"/>
   <pfstatus_pfk CODE="000002" PFNO="32" FUNCODE="EXEC_NO" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="00" FUNCODE="ENTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000003" PFNO="12" FUNCODE="CANCEL" FUNNO="002"/>
   <pfstatus_pfk CODE="000004" PFNO="00" FUNCODE="&amp;ONT" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="01" FUNCODE="&amp;ELP" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="02" FUNCODE="&amp;IC1" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="05" FUNCODE="&amp;ALL" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="06" FUNCODE="&amp;SAL" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="12" FUNCODE="&amp;AC1" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="18" FUNCODE="&amp;CRB" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="19" FUNCODE="&amp;CRE" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="21" FUNCODE="P--" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="22" FUNCODE="P-" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="23" FUNCODE="P+" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="24" FUNCODE="P++" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="26" FUNCODE="&amp;CRL" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="27" FUNCODE="&amp;CRR" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="28" FUNCODE="&amp;OUP" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="29" FUNCODE="&amp;ILT" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="30" FUNCODE="&amp;UMC" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="32" FUNCODE="&amp;OL0" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="33" FUNCODE="&amp;OAD" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="34" FUNCODE="&amp;AVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="35" FUNCODE="&amp;XPA" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="36" FUNCODE="&amp;ERW" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="37" FUNCODE="&amp;EB9" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="38" FUNCODE="&amp;ILD" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="39" FUNCODE="&amp;ETA" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="40" FUNCODE="&amp;ODN" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="42" FUNCODE="&amp;SUM" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="47" FUNCODE="&amp;OMP" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="71" FUNCODE="%SC" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="80" FUNCODE="P--" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="81" FUNCODE="P-" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="82" FUNCODE="P+" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="83" FUNCODE="P++" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="84" FUNCODE="%SC+" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_pfk CODE="000004" PFNO="94" FUNCODE="DEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000005" PFNO="00" FUNCODE="ENTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000005" PFNO="12" FUNCODE="CANCEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000006" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000006" PFNO="12" FUNCODE="CANCEL" FUNNO="002"/>
   <pfstatus_pfk CODE="000007" PFNO="00" FUNCODE="ENTER" FUNNO="001"/>
   <pfstatus_pfk CODE="000007" PFNO="12" FUNCODE="CANCEL" FUNNO="002"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="BACK"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="CANCEL"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="CHECK"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="EXEC"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="EXEC_NO"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="EXIT"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="FIELDS"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="FROM"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="MINE"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="OPEN"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="SAVE"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="SELECT"/>
   <pfstatus_set STATUS="PF_0100" FUNCTION="WHERE"/>
   <pfstatus_set STATUS="PF_0200" FUNCTION="CANCEL"/>
   <pfstatus_set STATUS="PF_0200" FUNCTION="ENTER"/>
   <pfstatus_set STATUS="PF_0500" FUNCTION="CANCEL"/>
   <pfstatus_set STATUS="PF_0500" FUNCTION="ENTER"/>
   <pfstatus_set STATUS="PF_0600" FUNCTION="CANCEL"/>
   <pfstatus_set STATUS="PF_0600" FUNCTION="SAVE"/>
   <pfstatus_set STATUS="PF_0700" FUNCTION="CANCEL"/>
   <pfstatus_set STATUS="PF_0700" FUNCTION="ENTER"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="%CH"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="%PC"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="%SC"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="%SC+"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="%SL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;AC1"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ALL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;AVE"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;CRB"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;CRE"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;CRL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;CRR"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;EB3"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;EB9"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ELP"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ERW"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ETA"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;IC1"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ILD"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ILT"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;OAD"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ODN"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;OL0"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;OMP"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;ONT"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;OUP"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;SAL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;SUM"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;UMC"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="&amp;XPA"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BAC1"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BACK"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEB1"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEB2"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEB9"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEBA"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEBB"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEBC"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEBD"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="BEBN"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="DEL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="DRUK"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="DSAL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="EXIT"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="EXPA"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="GLIS"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="KOMP"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="P+"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="P++"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="P-"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="P--"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PF09"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PF13"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PIC1"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PICK"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PRI"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PRIN"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="PRNT"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="RW"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SALL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SCRB"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SCRE"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SCRL"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SCRR"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SODN"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SOUP"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="SUMC"/>
   <pfstatus_set STATUS="PF_SALV_STATUS" FUNCTION="ZSUM"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="Tela inicial"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="P" INT_NOTE="Tela inicial"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="C" INT_NOTE="Tela inicial"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0002" MODAL="P" INT_NOTE="Status for Type Generator"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0003" MODAL="P" INT_NOTE="Performance Analyzer"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000002" MODAL="D" INT_NOTE="Tela inicial"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000002" SUB_CODE="0001" MODAL="D" INT_NOTE="Tela inicial"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000003" MODAL="P" INT_NOTE="Type Generator"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000003" SUB_CODE="0001" MODAL="P" INT_NOTE="Type Generator"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000004" MODAL="P" NORM="X" INT_NOTE="Standard Dialog Box"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000004" SUB_CODE="0001" MODAL="P" INT_NOTE="Standard Dialog Box"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000005" MODAL="P" INT_NOTE="Status for screen 500"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000005" SUB_CODE="0001" MODAL="P" INT_NOTE="Status for screen 500"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000006" MODAL="P" INT_NOTE="Status for screen 600"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000006" SUB_CODE="0001" MODAL="P" INT_NOTE="Status for screen 600"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000007" MODAL="P" INT_NOTE="Status for screen 700"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000007" SUB_CODE="0001" MODAL="P" INT_NOTE="Status for screen 700"/>
   <pfstatus_tit CODE="TITLE_0100" TEXT="ZQUERY - Open SQL Editor"/>
  </pfstatus>
  <source>*/--------------------------------------------------------------------------------------\
*|  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;       &quot;&quot;&quot;&quot;&quot;      &quot;&quot;&quot;&quot;    &quot;&quot;&quot;&quot;  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;     &quot;&quot;&quot;&quot;&quot;   &quot;&quot;&quot;&quot;&quot;  |
*|  &quot;         &quot;     &quot;       &quot;    &quot;  &quot;    &quot;  &quot;  &quot;         &quot;  &quot;        &quot;    &quot;   &quot; &quot;   &quot;   |
*|  &quot;&quot;&quot;&quot;&quot;     &quot;    &quot;   &quot;&quot;&quot;   &quot;   &quot;  &quot;    &quot;  &quot;  &quot;    &quot;&quot;&quot;&quot;&quot;&quot;  &quot;   &quot; &quot;   &quot;    &quot;   &quot;   &quot;    |
*|     &quot;     &quot;    &quot;   &quot;   &quot;   &quot;  &quot;  &quot;    &quot;  &quot;  &quot;    &quot;&quot;&quot;     &quot;   &quot; &quot;   &quot;     &quot;     &quot;     |
*|    &quot;     &quot;     &quot;   &quot;   &quot;   &quot;  &quot;  &quot;    &quot;  &quot;  &quot;      &quot;     &quot;        &quot;       &quot;   &quot;      |
*|   &quot;     &quot;      &quot;    &quot;&quot;&quot;    &quot;  &quot;  &quot;    &quot;  &quot;  &quot;    &quot;&quot;&quot;     &quot;   &quot;&quot;    &quot;      &quot;   &quot;      |
*|  &quot;     &quot;&quot;&quot;&quot;&quot;    &quot;         &quot;   &quot;    &quot;&quot;    &quot;  &quot;    &quot;&quot;&quot;&quot;&quot;&quot;  &quot;   &quot; &quot;    &quot;     &quot;   &quot;      |
*|  &quot;         &quot;     &quot;     &quot;   &quot;    &quot;       &quot;   &quot;         &quot;  &quot;   &quot;  &quot;    &quot;    &quot;   &quot;      |
*|  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;       &quot;&quot;&quot;&quot;&quot; &quot;        &quot;&quot;&quot;&quot;&quot;     &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;  &quot;&quot;&quot;&quot;&quot;   &quot;&quot;&quot;&quot;&quot;&quot;   &quot;&quot;&quot;&quot;&quot;      |
*\--------------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------------\
*|   Welcome to the ZQUERY Open SQL Editor.                                             |
*|                                                                                      |
*|   This is an open source project that aims the SAP ABAP developers                   |
*|   create your own queries without a need to create a test program.                   |
*|   It provides the possibility to execute many queries at the same                    |
*|   time and also generate a SELECT command, FROM command and even a                   |
*|   WHERE command.                                                                     |
*|                                                                                      |
*|   Feel free to use and share!                                                        |
*|                                                                                      |
*\--------------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------------\
*|                                                                                      |
*| This project is shared via Saplink: http://www.saplink.org                           |
*|                                                                                      |
*| You can find tutorials here:                                                         |
*| http://zquery.wordpress.com/how-to-tutorials/                                        |
*|                                                                                      |
*| Let me know your opinion, suggestion, doubt, anything by here:                       |
*| http://zquery.wordpress.com/contact/                                                 |
*|                                                                                      |
*\--------------------------------------------------------------------------------------/
*/--------------------------------------------------------------------------------------\
*| Developed by: Vinícius Rodrigues de Alcântara                                        |
*\--------------------------------------------------------------------------------------/

REPORT zquery.

&quot;$. Region DATA
TABLES: sscrfields.

INTERFACE lif_screen    DEFERRED.
CLASS lcl_query_element DEFINITION DEFERRED.
CLASS lcl_query_agent   DEFINITION DEFERRED.
CLASS lcl_field         DEFINITION DEFERRED.
CLASS lcl_table         DEFINITION DEFERRED.
CLASS lcl_screen        DEFINITION DEFERRED.
CLASS lcl_screen_600    DEFINITION DEFERRED.
CLASS lcl_join_fields   DEFINITION DEFERRED.

TYPE-POOLS: gfw, vrm.

TYPES: yt_query_elements TYPE TABLE OF REF TO lcl_query_element,
       yt_t_fields       TYPE TABLE OF REF TO lcl_field,
       yt_t_table        TYPE TABLE OF REF TO lcl_table,
       yt_lines          TYPE TABLE OF tline,
       yt_screen         TYPE TABLE OF REF TO lcl_screen,
       yt_rsdstabs       TYPE TABLE OF rsdstabs,
       yt_rsdsfields     TYPE TABLE OF rsdsfields,
       yt_t_query_agent  TYPE TABLE OF REF TO lcl_query_agent,
       yt_t_query        TYPE TABLE OF salv_wd_t_string,

       BEGIN OF yt_analyzer,
         analyzer_id   TYPE i,
         start_runtime TYPE i,
         end_runtime   TYPE i,
       END OF yt_analyzer,
       tyt_analyzer TYPE TABLE OF yt_analyzer,

       BEGIN OF yt_analyzer_ids,
         analyzer_id TYPE i,
         description TYPE string,
       END OF yt_analyzer_ids,

       BEGIN OF yt_user_range,
         sign   TYPE sign,
         option TYPE option,
         low    TYPE sy-uname,
         high   TYPE sy-uname,
       END OF yt_user_range,
       tyt_user_range TYPE TABLE OF yt_user_range,

       BEGIN OF yt_query,
         check       TYPE c,
         query       TYPE rsod_query,
         user        TYPE xubname,
         date        TYPE cdat,
         t_cell_type TYPE salv_t_int4_column,
       END OF yt_query,
       tyt_query TYPE TABLE OF yt_query,

       BEGIN OF ty_where_fields,
         mark        TYPE c,
         tabname     TYPE char30,
         fieldname   TYPE char30,
         description TYPE char40,
         type        TYPE rsscr_type,
         where_leng  TYPE rsdswhleng,
         sign	       TYPE signflag,
         decimals    TYPE rsdecimals,
       END OF ty_where_fields,
       tyt_where_fields TYPE TABLE OF ty_where_fields,

       BEGIN OF ty_table_fields,
         mark          TYPE boolean,
         tabname       TYPE lvc_tname,
         fieldname     TYPE lvc_fname,
         descr         TYPE scrtext_l,
         tab_alias     TYPE string,
         field_alias   TYPE string,
         sql_function  TYPE char128,
         internal_type TYPE inttype,
         style         TYPE lvc_t_styl,
       END OF ty_table_fields,
       tyt_table_fields TYPE TABLE OF ty_table_fields,

       BEGIN OF ty_join_fields,
         fortable             TYPE fortable,
         forkey               TYPE forkey,
         signal               TYPE char2,
         checktable           TYPE checktable,
         checkfield           TYPE fieldname,
         dd_handle_forkey     TYPE int4,
         dd_handle_checktable TYPE int4,
         dd_handle_checkfield TYPE int4,
         style                TYPE lvc_t_styl,
       END OF ty_join_fields,
       tyt_join_fields TYPE TABLE OF ty_join_fields,

       BEGIN OF ty_join_table,
         tabname     TYPE tabname,
         alias       TYPE char10,
         join_kind   TYPE char20,
         icon        TYPE iconname,
         join_fields TYPE REF TO lcl_join_fields,
         style       TYPE lvc_t_styl,
       END OF ty_join_table,
       tyt_join_table TYPE TABLE OF ty_join_table,

       BEGIN OF ty_handle,
         tabname       TYPE string,
         tab_handle    TYPE i,
         fields_handle TYPE i,
       END OF ty_handle.

DATA: o_screen_100       TYPE REF TO lif_screen,
      o_screen_200       TYPE REF TO lif_screen,
      o_screen_300       TYPE REF TO lif_screen,
      o_selection_screen TYPE REF TO lif_screen,
      o_screen_500       TYPE REF TO lif_screen,
      o_screen_600       TYPE REF TO lcl_screen_600,
      o_screen_700       TYPE REF TO lif_screen,
      v_select_type      TYPE char80,
      v_tabname          TYPE dd02l-tabname,
      v_tabalias         TYPE char30,
      v_tabdescr         TYPE dd02t-ddtext,
      v_create_where     TYPE xfeld,
      v_create_select    TYPE xfeld,
      l_screen           TYPE i.

SELECTION-SCREEN: BEGIN OF SCREEN 0400.
SELECT-OPTIONS s_user FOR sy-uname NO INTERVALS DEFAULT sy-uname.
PARAMETERS p_qname TYPE thead-tdname.
SELECTION-SCREEN: END OF SCREEN 0400.
&quot;$. Endregion DATA

INCLUDE zquery_class_definition.
INCLUDE zquery_class_implementation.

AT SELECTION-SCREEN.
  l_screen = sy-dynnr.
  TRY.
      o_selection_screen ?= lcl_screen=&gt;get_instance( l_screen ).
      o_selection_screen-&gt;user_command( sscrfields-ucomm ).
    CATCH cx_root.                                       &quot;#EC NO_HANDLE
  ENDTRY.

START-OF-SELECTION.
  o_screen_100 ?= lcl_screen=&gt;get_instance( 100 ).
  o_screen_100-&gt;show( ).

  &quot;$. Region PBO Modules
*&amp;---------------------------------------------------------------------*
*&amp; Module zm_status_0100 OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0100 OUTPUT.
  o_screen_100-&gt;screen_status( ).
ENDMODULE. &quot; zm_status_0100 OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp; Module zm_initialize_0100 OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0100 OUTPUT.
  o_screen_100-&gt;initialize_screen( ).
ENDMODULE. &quot; zm_initialize_0100 OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  zm_status_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0200 OUTPUT.
  o_screen_200 ?= lcl_screen=&gt;get_instance( 200 ).
  o_screen_200-&gt;screen_status( ).
ENDMODULE.                 &quot; zm_status_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  zm_initialize_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0200 OUTPUT.
  o_screen_200-&gt;initialize_screen( ).
ENDMODULE.                 &quot; zm_initialize_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_STATUS_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0300 OUTPUT.
  o_screen_300 ?= lcl_screen=&gt;get_instance( 300 ).
  o_screen_300-&gt;screen_status( ).
ENDMODULE.                 &quot; ZM_STATUS_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_INITIALIZE_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0300 OUTPUT.
  o_screen_300-&gt;initialize_screen( ).
ENDMODULE.                 &quot; ZM_INITIALIZE_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_STATUS_0500  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0500 OUTPUT.
  o_screen_500 ?= lcl_screen=&gt;get_instance( 500 ).
  o_screen_500-&gt;screen_status( ).
ENDMODULE.                 &quot; ZM_STATUS_0500  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_INITIALIZE_0500  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0500 OUTPUT.
  o_screen_500-&gt;initialize_screen( ).
ENDMODULE.                 &quot; ZM_INITIALIZE_0500  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_STATUS_0600  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0600 OUTPUT.
  o_screen_600 ?= lcl_screen=&gt;get_instance( 600 ).
  o_screen_600-&gt;screen_status( ).
ENDMODULE.                 &quot; ZM_STATUS_0600  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_INITIALIZE_0600  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0600 OUTPUT.
  o_screen_600-&gt;initialize_screen( ).
ENDMODULE.                 &quot; ZM_INITIALIZE_0600  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_STATUS_0700  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_status_0700 OUTPUT.
  o_screen_700 = lcl_screen=&gt;get_instance( 700 ).
  o_screen_700-&gt;screen_status( ).
ENDMODULE.                 &quot; ZM_STATUS_0700  OUTPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_INITIALIZE_0700  OUTPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_initialize_0700 OUTPUT.
  o_screen_700-&gt;initialize_screen( ).
ENDMODULE.                 &quot; ZM_INITIALIZE_0700  OUTPUT
&quot;$. Endregion PBO Modules

&quot;$. Region Modules PAI
*&amp;---------------------------------------------------------------------*
*&amp; Module zm_exit_command_0100 INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0100 INPUT.
  o_screen_100-&gt;exit_command( sy-ucomm ).
ENDMODULE. &quot; zm_exit_command_0100 INPUT
*&amp;---------------------------------------------------------------------*
*&amp; Module zm_user_command_0100 INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0100 INPUT.
  o_screen_100-&gt;user_command( sy-ucomm ).
ENDMODULE. &quot; zm_user_command_0100 INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  zm_exit_command_0200  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0200 INPUT.
  o_screen_200-&gt;exit_command( sy-ucomm ).
ENDMODULE.                 &quot; zm_exit_command_0200  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  zm_user_command_0200  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0200 INPUT.
  o_screen_200-&gt;user_command( sy-ucomm ).
ENDMODULE.                 &quot; zm_user_command_0200  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_USER_COMMAND_0300  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0300 INPUT.
  o_screen_300-&gt;user_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_USER_COMMAND_0300  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_EXIT_COMMAND_0300  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0300 INPUT.
  o_screen_300-&gt;exit_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_EXIT_COMMAND_0300  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_USER_COMMAND_0500  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0500 INPUT.
  o_screen_500-&gt;user_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_USER_COMMAND_0500  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_EXIT_COMMAND_0500  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0500 INPUT.
  o_screen_500-&gt;exit_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_EXIT_COMMAND_0500  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_USER_COMMAND_0600  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0600 INPUT.
  o_screen_600-&gt;user_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_USER_COMMAND_0600  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_EXIT_COMMAND_0600  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0600 INPUT.
  o_screen_600-&gt;exit_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_EXIT_COMMAND_0600  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_TABLENAME  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_tablename INPUT.
  o_screen_600-&gt;user_command( lcl_screen_600=&gt;c_tabname ).
ENDMODULE.                 &quot; ZM_TABLENAME  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_TABLEALIAS  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_tablealias INPUT.
  o_screen_600-&gt;user_command( lcl_screen_600=&gt;c_tabalias ).
ENDMODULE.                 &quot; ZM_TABLEALIAS  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_USER_COMMAND_0700  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_user_command_0700 INPUT.
  o_screen_700-&gt;user_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_USER_COMMAND_0700  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Module  ZM_EXIT_COMMAND_0700  INPUT
*&amp;---------------------------------------------------------------------*
MODULE zm_exit_command_0700 INPUT.
  o_screen_700-&gt;exit_command( sy-ucomm ).
ENDMODULE.                 &quot; ZM_EXIT_COMMAND_0700  INPUT
&quot;$. Endregion Modules PAI</source>
 </PROG>
 <PROG NAME="ZQUERY_CLASS_DEFINITION" VARCL="X" SUBC="I" CNAM="ALCANTARA" CDAT="20140919" UNAM="ALCANTARA" UDAT="20141219" VERN="000483" RSTAT="P" RMAND="810" RLOAD="P" SDATE="20141219" STIME="141833" IDATE="20141219" ITIME="141833" UCCHECK="X">
  <textPool/>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Include ZQUERY_CLASS_DEFINITION
*&amp;---------------------------------------------------------------------*

CLASS lcl_message DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: report_message IMPORTING i_msg     TYPE string
                                            i_type    TYPE char1
                                            i_disp_as TYPE char1 OPTIONAL,

                   user_choice IMPORTING i_title       TYPE string OPTIONAL
                                         i_question    TYPE string
                                         i_option_1    TYPE c
                                         i_option_2    TYPE c
                                         i_icon        TYPE iconname OPTIONAL
                               RETURNING value(return) TYPE char1.
ENDCLASS.                    &quot;lcl_message DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_no_query DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_no_query DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_no_query DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_query_overflow DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_query_overflow DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_query_overflow DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_error_query_check DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_error_query_check DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING i_message TYPE string OPTIONAL,
             get_message RETURNING value(return) TYPE string.
  PRIVATE SECTION.
    DATA: v_message TYPE string.
ENDCLASS.                    &quot;lcx_error_query_check DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_no_fieldcat DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_no_fieldcat DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_no_fieldcat DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_table_not_found DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_table_not_found DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_table_not_found DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_table_alias DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_table_alias DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_table_alias DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_cancel DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_cancel DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_cancel DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_existent_object DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_existent_object DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS: continue_process IMPORTING i_question TYPE string
                              RETURNING value(return) TYPE boolean.
ENDCLASS.                    &quot;lcx_existent_object DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_fields_overflow DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_fields_overflow DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_fields_overflow DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_no_fields_selected DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_no_fields_selected DEFINITION INHERITING FROM cx_dynamic_check.
ENDCLASS.                    &quot;lcx_no_fields_selected DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_query_element_not_found DEFINITION
*----------------------------------------------------------------------*
CLASS lcx_query_element_not_found DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING i_text TYPE string,
             get_message RETURNING value(return) TYPE string.

  PRIVATE SECTION.
    DATA: v_text TYPE string.
ENDCLASS.                    &quot;lcx_query_element_not_found DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcx_join_error DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_join_error DEFINITION INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING i_index   TYPE i
                                   i_field   TYPE string
                                   i_message TYPE string,
             get_index RETURNING value(return) TYPE i,
             get_field RETURNING value(return) TYPE string,
             get_message RETURNING value(return) TYPE string.

  PRIVATE SECTION.
    DATA: v_index TYPE i,
          v_field TYPE string,
          v_message TYPE string.
ENDCLASS.                    &quot;lcx_join_error DEFINITION

*----------------------------------------------------------------------*
*       INTERFACE lif_screen DEFINITION
*----------------------------------------------------------------------*
INTERFACE lif_screen.
  METHODS: user_command IMPORTING i_ucomm TYPE sy-ucomm ,
           exit_command IMPORTING i_ucomm TYPE sy-ucomm,
           screen_status,
           initialize_screen,
           show IMPORTING i_first_col TYPE i OPTIONAL
                          i_first_row TYPE i OPTIONAL
                          i_last_col  TYPE i OPTIONAL
                          i_last_row  TYPE i OPTIONAL.

  DATA v_screen TYPE i.

ENDINTERFACE. &quot;lif_screen

*----------------------------------------------------------------------*
* CLASS lcl_screen DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen DEFINITION ABSTRACT.
  PUBLIC SECTION.
    INTERFACES lif_screen.
    ALIASES: user_command      FOR lif_screen~user_command,
             exit_command      FOR lif_screen~exit_command,
             screen_status     FOR lif_screen~screen_status,
             initialize_screen FOR lif_screen~initialize_screen,
             show              FOR lif_screen~show.

    METHODS: constructor IMPORTING i_screen TYPE i,
             set_screen IMPORTING i_screen TYPE i,
             get_screen RETURNING value(return) TYPE i,

             set_exit_command IMPORTING i_exit_command TYPE boolean,
             get_exit_command RETURNING value(return) TYPE boolean.

    CLASS-METHODS: get_instance IMPORTING i_screen TYPE i
                                RETURNING value(return) TYPE REF TO lcl_screen.

  PROTECTED SECTION.
    CONSTANTS: c_ok     TYPE sy-ucomm VALUE &apos;OK&apos;,
               c_back   TYPE sy-ucomm VALUE &apos;BACK&apos;,
               c_exit   TYPE sy-ucomm VALUE &apos;EXIT&apos;,
               c_cancel TYPE sy-ucomm VALUE &apos;CANCEL&apos;,
               c_enter  TYPE sy-ucomm VALUE &apos;ENTER&apos;,
               c_save   TYPE sy-ucomm VALUE &apos;SAVE&apos;.

    DATA: o_call_screen  TYPE REF TO lcl_screen,
          o_cust_cont    TYPE REF TO cl_gui_custom_container,
          v_exit_command TYPE boolean.

ENDCLASS. &quot;lcl_screen DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_selection_screen DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_selection_screen DEFINITION ABSTRACT INHERITING FROM lcl_screen.

  PUBLIC SECTION.
    METHODS: lif_screen~show REDEFINITION.

ENDCLASS.                    &quot;lcl_selection_screen DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_screen_100 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_100 DEFINITION INHERITING FROM lcl_screen.
  PUBLIC SECTION.
    METHODS: lif_screen~user_command REDEFINITION,
             lif_screen~screen_status REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,
             show_results,

             initialize_editor IMPORTING i_container TYPE REF TO cl_gui_container,
             initialize_splitter IMPORTING i_container TYPE REF TO cl_gui_custom_container
                                           i_rows TYPE i
                                           i_cols TYPE i,

             get_container_from_splitter IMPORTING i_row TYPE i
                                                   i_col TYPE i
                                         RETURNING value(return) TYPE REF TO cl_gui_container,

             get_container_from_result IMPORTING i_row TYPE i
                                                 i_col TYPE i
                                       RETURNING value(return) TYPE REF TO cl_gui_container,

             get_texted_query IMPORTING i_selected TYPE boolean OPTIONAL
                                        i_blank    TYPE boolean OPTIONAL
                                        PREFERRED PARAMETER i_selected
                              RETURNING value(return) TYPE salv_wd_t_string RAISING lcx_no_query,
             set_texted_query IMPORTING i_query TYPE salv_wd_t_string,
             get_editor RETURNING value(return) TYPE REF TO cl_gui_abapedit,

             save_query RAISING lcx_cancel,

             open_query RAISING lcx_cancel,
             open_my_queries RAISING lcx_cancel lcx_table_not_found,

             generate_select RAISING lcx_cancel lcx_no_query lcx_error_query_check lcx_fields_overflow lcx_no_fields_selected lcx_query_element_not_found,
             generate_from RAISING lcx_cancel lcx_no_query lcx_error_query_check lcx_fields_overflow lcx_no_fields_selected lcx_query_element_not_found,
             generate_where RAISING lcx_cancel lcx_no_query lcx_error_query_check lcx_fields_overflow lcx_no_fields_selected lcx_query_element_not_found,

             add_query_agent IMPORTING i_query_agent TYPE REF TO lcl_query_agent,
             get_query_agents_lines RETURNING value(return) TYPE i,

             execute_query IMPORTING i_no_conversion TYPE boolean OPTIONAL
                           RAISING lcx_no_query lcx_error_query_check lcx_query_element_not_found lcx_query_overflow.

  PRIVATE SECTION.
    CONSTANTS: c_exec    TYPE sy-ucomm VALUE &apos;EXEC&apos;,
               c_exec_no TYPE sy-ucomm VALUE &apos;EXEC_NO&apos;,
               c_check   TYPE sy-ucomm VALUE &apos;CHECK&apos;,
               c_open    TYPE sy-ucomm VALUE &apos;OPEN&apos;,
               c_mine    TYPE sy-ucomm VALUE &apos;MINE&apos;,
               c_select  TYPE sy-ucomm VALUE &apos;SELECT&apos;,
               c_from    TYPE sy-ucomm VALUE &apos;FROM&apos;,
               c_where   TYPE sy-ucomm VALUE &apos;WHERE&apos;.


    DATA: o_cont_query      TYPE REF TO cl_gui_container,
          o_cont_alv        TYPE REF TO cl_gui_container,
          o_splitter        TYPE REF TO cl_gui_splitter_container,
          o_result_splitter TYPE REF TO cl_gui_splitter_container,
          o_editor          TYPE REF TO cl_gui_abapedit,
          t_query_agents    TYPE yt_t_query_agent.

    METHODS: check_query_syntax RAISING lcx_no_query lcx_error_query_check lcx_query_element_not_found,
             split_queries IMPORTING i_text TYPE salv_wd_t_string
                           EXPORTING e_queries TYPE yt_t_query
                           RAISING lcx_query_overflow,

             flush.

ENDCLASS. &quot;lcl_screen_100 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_report DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_report DEFINITION.

  PUBLIC SECTION.
    CLASS-METHODS: delete_comments CHANGING i_text TYPE salv_wd_t_string,
                   compute_apostrophes IMPORTING i_text TYPE string
                                       RETURNING value(return) TYPE string.

    METHODS: constructor IMPORTING i_report_name TYPE string,

             set_report_name IMPORTING i_report_name TYPE string,
             get_report_name RETURNING value(return) TYPE string,

             add_source      IMPORTING i_line TYPE string OPTIONAL,
             add_report_name,

             get_source      RETURNING value(return) TYPE salv_wd_t_string,

             check_syntax    IMPORTING i_source TYPE salv_wd_t_string OPTIONAL
                             RAISING lcx_error_query_check,

             generate_report RETURNING value(return) TYPE string
                               RAISING lcx_error_query_check,

             execute_report IMPORTING i_form_name TYPE string
                                      i_report_name TYPE string,

             delete_report IMPORTING i_report_name TYPE string.

  PRIVATE SECTION.
    DATA: v_report_name TYPE string,
          t_source      TYPE salv_wd_t_string.

ENDCLASS.                    &quot;lcl_report DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_commands DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_commands DEFINITION .

  PUBLIC SECTION.
    CONSTANTS: select             TYPE string VALUE &apos;SELECT&apos;,
               from               TYPE string VALUE &apos;FROM&apos;,
               from_check         TYPE string VALUE &apos; FROM &apos;,
               join               TYPE string VALUE &apos;JOIN&apos;,
               inner              TYPE string VALUE &apos;INNER&apos;,
               outer              TYPE string VALUE &apos;OUTER&apos;,
               left               TYPE string VALUE &apos;LEFT&apos;,
               right              TYPE string VALUE &apos;RIGHT&apos;,
               where              TYPE string VALUE &apos;WHERE&apos;,
               having             TYPE string VALUE &apos;HAVING&apos;,
               group              TYPE string VALUE &apos;GROUP&apos;,
               by                 TYPE string VALUE &apos;BY&apos;,
               up                 TYPE string VALUE &apos;UP&apos;,
               order              TYPE string VALUE &apos;ORDER&apos;,
               distinct           TYPE string VALUE &apos;DISTINCT&apos;,
               asterisk           TYPE string VALUE &apos;*&apos;,
               single             TYPE string VALUE &apos;SINGLE&apos;,
               single_check       TYPE string VALUE &apos; SINGLE &apos;,
               as                 TYPE string VALUE &apos;AS&apos;,
               primary            TYPE string VALUE &apos;PRIMARY&apos;,
               sum                TYPE string VALUE &apos;SUM&apos;,
               sum_check          TYPE string VALUE &apos;SUM(&apos;,
               avg                TYPE string VALUE &apos;AVG&apos;,
               avg_check          TYPE string VALUE &apos;AVG(&apos;,
               max                TYPE string VALUE &apos;MAX&apos;,
               max_check          TYPE string VALUE &apos;MAX(&apos;,
               min                TYPE string VALUE &apos;MIN&apos;,
               min_check          TYPE string VALUE &apos;MIN(&apos;,
               count              TYPE string VALUE &apos;COUNT&apos;,
               count_command      TYPE string VALUE &apos;COUNT( * )&apos;,
               count_check        TYPE string VALUE &apos;COUNT(&apos;,
               dot                TYPE string VALUE &apos;.&apos;,
               inner_join_command TYPE string VALUE &apos;INNER JOIN&apos;,
               outer_join_command TYPE string VALUE &apos;OUTER JOIN&apos;,
               left_join_command  TYPE string VALUE &apos;LEFT JOIN&apos;,
               right_join_command TYPE string VALUE &apos;RIGHT JOIN&apos;,
               on                 TYPE string VALUE &apos;ON&apos;,
               and                TYPE string VALUE &apos;AND&apos;,
               equal              TYPE string VALUE &apos;=&apos;,
               eq                 TYPE string VALUE &apos;EQ&apos;,
               lt                 TYPE string VALUE &apos;LT&apos;,
               le                 TYPE string VALUE &apos;LE&apos;,
               gt                 TYPE string VALUE &apos;GT&apos;,
               ge                 TYPE string VALUE &apos;GE&apos;.

    CLASS-METHODS: class_constructor,
                   get_command_list RETURNING value(return) TYPE salv_wd_t_string,
                   get_identify_commands_list RETURNING value(return) TYPE salv_wd_t_string.

    CLASS-DATA: t_commands TYPE salv_wd_t_string,
                t_identify_commands TYPE salv_wd_t_string.

  PRIVATE SECTION.
    CLASS-METHODS: initialize_command_list,
                   initialize_identify_commands.

ENDCLASS. &quot;lcl_commands DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_field DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_field DEFINITION .

  PUBLIC SECTION.
    METHODS: constructor     IMPORTING i_field_name  TYPE string
                                       i_table_name  TYPE string OPTIONAL
                                       i_field_alias TYPE string OPTIONAL,

             set_field_alias IMPORTING i_field_alias TYPE string,
             get_field_alias RETURNING value(return) TYPE string,

             set_field_name  IMPORTING i_field_name TYPE string,
             get_field_name  RETURNING value(return) TYPE string,

             set_table_name  IMPORTING i_table_name TYPE string,
             get_table_name  RETURNING value(return) TYPE string,

             set_count_field IMPORTING i_count TYPE boolean,
             get_count_field RETURNING value(return) TYPE boolean,

             set_sql_function IMPORTING i_sql_function TYPE string,
             get_sql_function RETURNING value(return) TYPE string.

  PRIVATE SECTION.
    DATA: v_field_alias  TYPE string,
          v_field_name   TYPE string,
          v_table_name   TYPE string,
          v_count_field  TYPE boolean,
          v_sql_function TYPE string.

ENDCLASS. &quot;lcl_field DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_join_fields DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_join_fields DEFINITION.

  PUBLIC SECTION.
    METHODS: set_fortable IMPORTING i_fortable TYPE fortable,
             get_fortable RETURNING value(return) TYPE fortable,

             set_forkey IMPORTING i_forkey TYPE forkey,
             get_forkey RETURNING value(return) TYPE forkey,

             set_checktable IMPORTING i_checktable TYPE checktable,
             get_checktable RETURNING value(return) TYPE checktable,

             set_checkfield IMPORTING i_checkfield TYPE fieldname,
             get_checkfield RETURNING value(return) TYPE fieldname,

             add_join_field IMPORTING i_fortable   TYPE fortable
                                      i_forkey     TYPE forkey
                                      i_checktable TYPE checktable
                                      i_checkfield TYPE fieldname,
             set_join_fields IMPORTING i_join_fields TYPE tyt_join_fields,
             get_join_fields EXPORTING e_join_fields TYPE tyt_join_fields,

             get_join_fields_count RETURNING value(return) TYPE i.

  PRIVATE SECTION.
    DATA: v_fortable    TYPE fortable,
          v_forkey      TYPE forkey,
          v_checktable  TYPE checktable,
          v_checkfield  TYPE fieldname,
          v_signal      TYPE string,
          t_join_fields TYPE tyt_join_fields.

ENDCLASS.                    &quot;lcl_join_fields DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_table DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_table DEFINITION.

  PUBLIC SECTION.
    CLASS-METHODS: check_table_name IMPORTING i_tabname TYPE any
                                    RETURNING value(return) TYPE boolean.
    METHODS: set_name IMPORTING i_name TYPE string,
             get_name RETURNING value(return) TYPE string,

             set_alias IMPORTING i_alias TYPE string,
             get_alias RETURNING value(return) TYPE string,

             set_join_kind IMPORTING i_join_kind TYPE string,
             get_join_kind RETURNING value(return) TYPE string,

             set_outer_join IMPORTING i_outer_join TYPE boolean,
             get_outer_join RETURNING value(return) TYPE boolean,

             set_join_fields IMPORTING i_join_fields TYPE tyt_join_fields,
             get_join_fields EXPORTING e_join_fields TYPE tyt_join_fields,

             get_table_fields EXPORTING e_fields TYPE tyt_table_fields,

             get_description_from_ddic RETURNING value(return) TYPE string,

             constructor IMPORTING i_name  TYPE string
                                   i_alias TYPE string OPTIONAL.

  PRIVATE SECTION.
    DATA: v_name        TYPE string,
          v_alias       TYPE string,
          v_outer_join  TYPE boolean,
          v_join_kind   TYPE string,
          t_join_fields TYPE tyt_join_fields.

ENDCLASS. &quot;lcl_table DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_query_element DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_query_element DEFINITION ABSTRACT.

  PUBLIC SECTION.
    DATA: v_element TYPE string.

    METHODS: set_command_contents ABSTRACT IMPORTING i_query   TYPE salv_wd_t_string
                                                     i_command TYPE string,
             get_command_contents RETURNING value(return) TYPE salv_wd_t_string,
             to_string RETURNING value(return) TYPE string.


  PROTECTED SECTION.
    DATA: t_command_contents TYPE salv_wd_t_string,
          v_command          TYPE string.
    METHODS: check_alias IMPORTING i_query TYPE salv_wd_t_string
                                   i_index TYPE i
                         RETURNING value(return) TYPE string.

ENDCLASS. &quot;lcl_query_element DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_select DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_select DEFINITION INHERITING FROM lcl_query_element.

  PUBLIC SECTION.
    CONSTANTS: c_max_fields TYPE i VALUE 20.

    METHODS: set_select_type IMPORTING i_select_type TYPE string ,
             get_select_type RETURNING value(return) TYPE string,

             add_field       IMPORTING i_field TYPE REF TO lcl_field,
             get_fields      EXPORTING return TYPE yt_t_fields,

             get_fields_count RETURNING value(return) TYPE i,

             set_command_contents REDEFINITION.

  PRIVATE SECTION.
    DATA: select_type TYPE string,
          t_fields    TYPE TABLE OF REF TO lcl_field.

    METHODS: split_field_name IMPORTING i_field   TYPE string
                              EXPORTING e_name    TYPE string
                                        e_tabname TYPE string,

             check_alias_existence IMPORTING i_query TYPE salv_wd_t_string
                                             i_index TYPE i
                                             i_field TYPE REF TO lcl_field
                                   RETURNING value(return) TYPE i.

ENDCLASS. &quot;lcl_select DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_from DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_from DEFINITION INHERITING FROM lcl_query_element.

  PUBLIC SECTION.
    METHODS: set_command_contents REDEFINITION,

             add_table IMPORTING i_table TYPE REF TO lcl_table,

             get_table IMPORTING i_table TYPE string OPTIONAL
                                 i_index TYPE i      OPTIONAL
                                 PREFERRED PARAMETER i_index
                       RETURNING value(return) TYPE REF TO lcl_table
                       RAISING lcx_table_not_found,

             get_tables EXPORTING e_tables TYPE yt_t_table.


  PRIVATE SECTION.
    DATA: t_tables TYPE TABLE OF REF TO lcl_table.

    METHODS: check_outer_join IMPORTING i_query       TYPE salv_wd_t_string
                                        i_index       TYPE i
                              RETURNING value(return) TYPE boolean,

             check_join_fields IMPORTING i_table TYPE REF TO lcl_table
                                         i_query TYPE salv_wd_t_string
                                         i_index TYPE i.

ENDCLASS. &quot;lcl_from DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_fieldcat DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_fieldcat DEFINITION.

  PUBLIC SECTION.
    METHODS: set_fieldcat IMPORTING i_fieldcat TYPE lvc_t_fcat,
             get_fieldcat RETURNING value(return) TYPE lvc_t_fcat,

             constructor IMPORTING i_fieldcat TYPE lvc_t_fcat OPTIONAL,

             add_field_to_fcat IMPORTING i_fieldcat     TYPE lvc_s_fcat OPTIONAL
                                         i_fieldcat_tab TYPE lvc_t_fcat OPTIONAL
                                         i_fieldname    TYPE string     OPTIONAL
                                         i_edit         TYPE boolean    OPTIONAL
                                         i_scrtext      TYPE string     OPTIONAL
                                         i_descr        TYPE string     OPTIONAL
                                         i_outputlen    TYPE i          OPTIONAL
                                         i_inttype      TYPE inttype    OPTIONAL
                                         i_intlen       TYPE intlen     OPTIONAL
                                         i_checkbox     TYPE lvc_checkb OPTIONAL
                                         i_drop_down    TYPE i          OPTIONAL
                                         i_drop_alias   TYPE c          OPTIONAL
                                         i_drdn_field   TYPE string     OPTIONAL
                                         i_icon         TYPE boolean    OPTIONAL
                                         i_hotspot      TYPE boolean    OPTIONAL
                                         i_just         TYPE lvc_just   OPTIONAL
                                         i_f4_avaliable TYPE boolean    OPTIONAL
                                         i_checktable   TYPE tabname    OPTIONAL
                                         PREFERRED PARAMETER i_fieldcat_tab,

             merge_fieldcat IMPORTING i_table TYPE REF TO lcl_table OPTIONAL
                                      i_no_conversion TYPE boolean OPTIONAL
                                      PREFERRED PARAMETER i_table
                            RETURNING value(return) TYPE lvc_t_fcat,

             inverse_fieldcat_names IMPORTING i_alv TYPE REF TO cl_gui_alv_grid
                                    RETURNING value(return) TYPE lvc_t_fcat,

             no_routine_conversion IMPORTING i_alv TYPE REF TO cl_gui_alv_grid
                                   RETURNING value(return) TYPE lvc_t_fcat,

             compute_fieldcat_to_fields IMPORTING i_select TYPE REF TO lcl_select
                                                  i_from   TYPE REF TO lcl_from,

             get_fieldcat_count_fields RETURNING value(return) TYPE i.

  PRIVATE SECTION.
    DATA: t_fieldcat TYPE lvc_t_fcat.

    METHODS: get_fieldcat_struct IMPORTING i_field_name TYPE string
                                           i_table_name TYPE string
                                           i_from       TYPE REF TO lcl_from
                                           i_fieldcat   TYPE lvc_t_fcat
                                 RETURNING value(return) TYPE lvc_s_fcat
                                 RAISING lcx_table_not_found,

             adjust_column_positions.

ENDCLASS.                    &quot; DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_where DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_where DEFINITION INHERITING FROM lcl_query_element.
  PUBLIC SECTION.
    METHODS set_command_contents REDEFINITION.
ENDCLASS. &quot;lcl_where DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_query_element_factory DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_query_element_factory DEFINITION .
  PUBLIC SECTION.
    CLASS-METHODS: factory_query_element IMPORTING i_element TYPE string
                                         RETURNING value(return) TYPE REF TO lcl_query_element .
ENDCLASS. &quot;lcl_query_element_factory DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_factory DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_factory DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: factory_screen IMPORTING i_screen TYPE i RETURNING value(return) TYPE REF TO lcl_screen,
                   get_screen IMPORTING i_screen TYPE i
                              RETURNING value(return) TYPE REF TO lcl_screen.
  PRIVATE SECTION.
    CLASS-DATA t_screens TYPE yt_screen.
ENDCLASS.                    &quot;lcl_screen_factory DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_query DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_query DEFINITION .

  PUBLIC SECTION.
    CLASS-METHODS: split_text IMPORTING i_text TYPE string
                                        i_outputlen TYPE i
                              RETURNING value(return) TYPE salv_wd_t_string.

    METHODS: constructor IMPORTING i_query TYPE salv_wd_t_string,

             add_query_element IMPORTING i_query_element TYPE REF TO lcl_query_element,
             get_query_elements EXPORTING e_elements TYPE yt_query_elements,
             get_query_element IMPORTING i_element TYPE string
                               RETURNING value(return) TYPE REF TO lcl_query_element,

             set_query IMPORTING i_query TYPE salv_wd_t_string,
             get_query RETURNING value(return) TYPE salv_wd_t_string,

             set_query_string IMPORTING i_query TYPE string,
             get_query_string RETURNING value(return) TYPE string,

             set_data IMPORTING i_data TYPE REF TO data,
             get_data RETURNING value(return) TYPE REF TO data,

             execute RAISING lcx_error_query_check,

             check_query_syntax RETURNING value(return) TYPE boolean
                                RAISING lcx_error_query_check lcx_query_element_not_found,
             identify_query_elements IMPORTING i_element TYPE string OPTIONAL
                                     RETURNING value(return) TYPE REF TO lcl_query_element,

             compute_query,

             get_fields_count RETURNING value(return) TYPE i.

  PRIVATE SECTION.
    DATA:    t_query_elements TYPE TABLE OF REF TO lcl_query_element,
             t_query TYPE salv_wd_t_string,
             v_query TYPE string,
             o_data TYPE REF TO data.

    METHODS: build_to_syntax_check IMPORTING i_query       TYPE string &quot;salv_wd_t_string
                                             i_report      TYPE REF TO lcl_report
                                   RAISING lcx_query_element_not_found.

ENDCLASS. &quot;lcl_query DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_event_handler DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_event_handler DEFINITION.

  PUBLIC SECTION.
    CONSTANTS: c_tech   TYPE ui_func VALUE &apos;TECH&apos;, &quot;Inverse names
               c_type   TYPE ui_func VALUE &apos;TYPE&apos;, &quot;Type generator
               c_perf   TYPE ui_func VALUE &apos;PERF&apos;, &quot;Performance
               c_no_conv TYPE ui_func VALUE &apos;NO_CONV&apos;,
               c_del    TYPE ui_func VALUE &apos;DEL&apos;,  &quot;Delete query
               c_sall   TYPE ui_func VALUE &apos;SALL&apos;, &quot;Select All
               c_dall   TYPE ui_func VALUE &apos;DALL&apos;, &quot;Deselect All
               c_add    TYPE ui_func VALUE &apos;ADD&apos;, &quot;Add line
               c_sugest TYPE ui_func VALUE &apos;SUGEST&apos;. &quot;Sugest join

    METHODS: constructor IMPORTING i_query_agent TYPE REF TO lcl_query_agent OPTIONAL,

             &quot;Query Resut
             handle_toolbar      FOR EVENT toolbar      OF cl_gui_alv_grid IMPORTING e_object,
             handle_user_command FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
             handle_menu_button  FOR EVENT menu_button  OF cl_gui_alv_grid IMPORTING e_object e_ucomm,

             &quot;Select Generator
             handle_toolbar_select_gen FOR EVENT toolbar OF cl_gui_alv_grid IMPORTING e_object,
             handle_user_command_select_gen FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
             handle_row_drag FOR EVENT ondrag OF cl_gui_alv_grid IMPORTING e_row e_dragdropobj,
             handle_row_drop FOR EVENT ondrop OF cl_gui_alv_grid IMPORTING e_row e_dragdropobj,

             &quot;From Generator
             handle_toolbar_from_gen      FOR EVENT toolbar OF cl_gui_alv_grid IMPORTING e_object,
             handle_user_command_from_gen FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
             handle_hotspot_from_gen      FOR EVENT hotspot_click OF cl_gui_alv_grid IMPORTING e_row_id e_column_id,
             handle_f4_from_gen           FOR EVENT onf4 OF cl_gui_alv_grid IMPORTING e_fieldname e_fieldvalue es_row_no,

             &quot;Join fields
             handle_toolbar_join      FOR EVENT toolbar OF cl_gui_alv_grid IMPORTING e_object,
             handle_user_command_join FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
             handle_data_change_join  FOR EVENT data_changed OF cl_gui_alv_grid IMPORTING er_data_changed,

             &quot;My queries - SALV_TABLE
             handle_added_function FOR EVENT added_function OF cl_salv_events IMPORTING e_salv_function.

  PRIVATE SECTION.
    DATA: o_query_agent TYPE REF TO lcl_query_agent.

    METHODS: add_button IMPORTING i_function  TYPE ui_func   OPTIONAL
                                  i_icon      TYPE iconname  OPTIONAL
                                  i_quickinfo TYPE iconquick OPTIONAL
                                  i_butn_type TYPE tb_btype
                                  i_disabled  TYPE boolean   OPTIONAL
                                  i_text      TYPE text40    OPTIONAL
                         CHANGING t_toolbar   TYPE ttb_button.

ENDCLASS.                    &quot;lcl_event_handler DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_drag_drop DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_drag_drop DEFINITION.
  PUBLIC SECTION.
    METHODS: set_index IMPORTING i_index TYPE i,
             get_index RETURNING value(return) TYPE i,

             set_data IMPORTING i_data TYPE ty_table_fields,
             get_data RETURNING value(return) TYPE ty_table_fields.

  PRIVATE SECTION.
    DATA: v_index TYPE i,
          o_data TYPE ty_table_fields.

ENDCLASS.                    &quot;lcl_drag_drop DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_performance_analyzer DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_performance_analyzer DEFINITION.

  PUBLIC SECTION.
    CONSTANTS: abap                    TYPE i VALUE 1,
               sql                     TYPE i VALUE 2,
               check_syntax            TYPE i VALUE 3,
               identify_query_elements TYPE i VALUE 4,
               fieldcat_creation       TYPE i VALUE 5,
               build_dynamic_structure TYPE i VALUE 6.

    CLASS-METHODS: class_constructor,
                   get_analyzer_description IMPORTING i_id TYPE i
                                            RETURNING value(return) TYPE string.

    METHODS: start_runtime_analyzer IMPORTING i_analyzer_id TYPE i,
             stop_runtime_analyzer IMPORTING i_analyzer_id TYPE i,

             get_analyzer IMPORTING i_id TYPE i
                          RETURNING value(return) TYPE yt_analyzer,

             get_analyzer_table EXPORTING t_analyzer TYPE tyt_analyzer,

             calculate_runtime IMPORTING i_id    TYPE i OPTIONAL
                                         i_start TYPE i OPTIONAL
                                         i_end   TYPE i OPTIONAL
                               RETURNING value(return) TYPE dec_16_02_s.

  PRIVATE SECTION.
    CLASS-DATA: t_analyzer_ids TYPE TABLE OF yt_analyzer_ids.
    DATA: t_analyzer TYPE TABLE OF yt_analyzer.

    CLASS-METHODS: add_analyzer_id IMPORTING i_id    TYPE i
                                             i_descr TYPE char100.

    METHODS: add_analyzer IMPORTING i_id TYPE i,
             get_runtime_field RETURNING value(return) TYPE i.

ENDCLASS.                    &quot;lcl_performance_analyzer DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_query_save DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_query_save DEFINITION.

  PUBLIC SECTION.
    CONSTANTS: c_buffer_prefix TYPE string VALUE &apos;YZBUFFERQUERY_&apos;,
               c_zquery_prefix TYPE string VALUE &apos;YZQUERY_&apos;.

    METHODS: set_selected_query IMPORTING i_query TYPE tyt_query,
             get_selected_query EXPORTING e_query TYPE tyt_query,

             set_refresh IMPORTING i_refresh TYPE boolean,

             buffer_query_texted IMPORTING i_query TYPE salv_wd_t_string,
             get_buffered_query RETURNING value(return) TYPE salv_wd_t_string,
             get_query_name RETURNING value(return) TYPE string RAISING lcx_cancel,

             read_query IMPORTING i_query_name TYPE string
                                  i_check      TYPE boolean OPTIONAL
                        RETURNING value(return) TYPE salv_wd_t_string
                          RAISING lcx_existent_object,

             save_query IMPORTING i_name TYPE string
                                  i_query TYPE salv_wd_t_string
                        RAISING lcx_cancel,

             delete_query IMPORTING i_query_name TYPE string,

             check_existent_query IMPORTING i_name TYPE string
                                    RAISING lcx_existent_object,

             get_queries IMPORTING i_user TYPE tyt_user_range
                                   i_query_name TYPE string
                         EXPORTING e_queries TYPE tyt_query
                           RAISING lcx_table_not_found,

             search_queries IMPORTING i_user       TYPE tyt_user_range
                                      i_query_name TYPE string
                            EXPORTING e_queries TYPE tyt_query
                              RAISING lcx_table_not_found,

             display_queries IMPORTING i_queries TYPE tyt_query
                                       i_mine    TYPE boolean OPTIONAL
                             EXPORTING e_selected TYPE tyt_query
                               RAISING lcx_cancel,

             compute_selected_queries IMPORTING i_queries TYPE tyt_query
                                      RETURNING value(return) TYPE salv_wd_t_string,

             delete_selected_query,

             is_refresh RETURNING value(return) TYPE boolean.

    CLASS-METHODS: get_instance RETURNING value(return) TYPE REF TO lcl_query_save.

  PRIVATE SECTION.
    CLASS-DATA: o_instance TYPE REF TO lcl_query_save.
    DATA: o_table TYPE REF TO cl_salv_table,
          t_selected_query TYPE tyt_query,
          v_refresh TYPE boolean.

    METHODS: compute_query IMPORTING i_query TYPE salv_wd_t_string
                           EXPORTING e_lines TYPE yt_lines,

             get_selected_queries_by_rows IMPORTING i_rows TYPE salv_t_row
                                          EXPORTING e_query TYPE tyt_query,

             process_delete_query IMPORTING i_query TYPE tyt_query.

ENDCLASS.                    &quot;lcl_query_save DEFINITION

*----------------------------------------------------------------------*
* CLASS lcl_query_agent DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_query_agent DEFINITION .

  PUBLIC SECTION.
    METHODS: get_alv RETURNING value(return) TYPE REF TO cl_gui_alv_grid,
             initialize_alv IMPORTING i_container TYPE REF TO cl_gui_container,

             execute_query IMPORTING i_query TYPE salv_wd_t_string RAISING lcx_error_query_check lcx_query_element_not_found,

             generate_where IMPORTING i_query TYPE salv_wd_t_string
                            RETURNING value(return) TYPE salv_wd_t_string
                            RAISING lcx_error_query_check lcx_fields_overflow lcx_cancel lcx_no_fields_selected lcx_query_element_not_found,
             generate_select IMPORTING i_query TYPE salv_wd_t_string
                             RETURNING value(return) TYPE salv_wd_t_string
                             RAISING lcx_error_query_check lcx_fields_overflow lcx_cancel lcx_no_fields_selected lcx_query_element_not_found,

             check_query_syntax IMPORTING i_query TYPE salv_wd_t_string
                                RAISING lcx_error_query_check lcx_query_element_not_found,

             build_dyn_struct IMPORTING i_fieldcat    TYPE lvc_t_fcat
                              RETURNING value(return) TYPE REF TO data,

             create_fcat RETURNING value(return) TYPE lvc_t_fcat,

             set_fieldcat IMPORTING i_fieldcat TYPE lvc_t_fcat,
             get_fieldcat RETURNING value(return) TYPE lvc_t_fcat,

             set_no_conversion IMPORTING i_no_conversion TYPE boolean,
             get_no_conversion RETURNING value(return) TYPE boolean,

             get_query_results RETURNING value(return) TYPE REF TO data,

             show_results IMPORTING i_container TYPE REF TO cl_gui_container,
             inverse_fieldcat_names,
             no_routine_conversion,
             flush_alv,
             generate_types RAISING lcx_cancel,
             show_performance_analyzer.

    CLASS-METHODS: get_query_agent RETURNING value(return) TYPE REF TO lcl_query_agent.

  PRIVATE SECTION.
    CLASS-DATA: o_query_agent TYPE REF TO lcl_query_agent.
    DATA: v_no_conversion TYPE boolean,
          o_query         TYPE REF TO lcl_query,
          &quot;o_editor        TYPE REF TO cl_gui_abapedit,
          o_alv           TYPE REF TO cl_gui_alv_grid,
          o_event_handler TYPE REF TO lcl_event_handler,
          o_analyzer      TYPE REF TO lcl_performance_analyzer,
          t_fieldcat      TYPE lvc_t_fcat.

    METHODS: get_layout RETURNING value(return) TYPE lvc_s_layo,
             check_fields_to_select.

ENDCLASS. &quot;lcl_query_agent DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_type_generator DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_type_generator DEFINITION.

  PUBLIC SECTION.
    METHODS: constructor IMPORTING i_type_name TYPE string OPTIONAL,

             set_type_name IMPORTING i_type_name TYPE string,
             get_type_name RETURNING value(return) TYPE string,

             get_command_line RETURNING value(return) TYPE salv_wd_t_string,

             generate_type_by_fcat IMPORTING i_fieldcat TYPE lvc_t_fcat,
             generate_generic_type IMPORTING i_table_name TYPE string.

    CLASS-METHODS: get_type_name_by_user RETURNING value(return) TYPE string RAISING lcx_cancel.

  PRIVATE SECTION.
    DATA: v_type_name TYPE string,
          t_command_line TYPE TABLE OF string.

    METHODS: add_command_line IMPORTING i_line TYPE string OPTIONAL.

ENDCLASS.                    &quot;lcl_type_generator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_200 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_200 DEFINITION INHERITING FROM lcl_screen.

  PUBLIC SECTION.
    METHODS: lif_screen~user_command REDEFINITION,
             lif_screen~screen_status REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,

             set_type_gen_instance IMPORTING i_type_gen TYPE REF TO lcl_type_generator,
             get_type_gen_instance RETURNING value(return) TYPE REF TO lcl_type_generator,

             set_editor IMPORTING i_editor TYPE REF TO cl_gui_abapedit,
             get_editor RETURNING value(return) TYPE REF TO cl_gui_abapedit.

  PRIVATE SECTION.
    DATA: o_type_generator TYPE REF TO lcl_type_generator,
          o_editor         TYPE REF TO cl_gui_abapedit.

ENDCLASS.                    &quot;lcl_screen_200 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_300 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_300 DEFINITION INHERITING FROM lcl_screen.

  PUBLIC SECTION.
    METHODS: lif_screen~user_command REDEFINITION,
             lif_screen~screen_status REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,

             set_analyzer IMPORTING i_analyzer TYPE REF TO lcl_performance_analyzer,
             get_analyzer RETURNING value(return) TYPE REF TO lcl_performance_analyzer.

  PRIVATE SECTION.
    DATA: o_analyzer TYPE REF TO lcl_performance_analyzer,
          t_values TYPE TABLE OF gprval,
          t_texts  TYPE TABLE OF gprtxt.

    METHODS: add_text IMPORTING i_text TYPE string,
             add_value IMPORTING i_rowtxt TYPE string
                                 i_val    TYPE any
                                 i_id     TYPE i,

             display_graphic,

             generate_graphic_data IMPORTING i_analyzer TYPE REF TO lcl_performance_analyzer.

ENDCLASS.                    &quot;lcl_screen_300 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_400 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_400 DEFINITION INHERITING FROM lcl_selection_screen.

  PUBLIC SECTION.
    METHODS: lif_screen~user_command REDEFINITION,
             execute IMPORTING i_user TYPE sy-uname OPTIONAL
                       RAISING lcx_table_not_found lcx_cancel,

             compute_user_range IMPORTING i_user TYPE sy-uname OPTIONAL
                                EXPORTING e_user_range TYPE tyt_user_range,
             compute_query_name RETURNING value(return) TYPE string.

  PRIVATE SECTION.
    CONSTANTS c_exec TYPE sy-ucomm VALUE &apos;CRET&apos;.

ENDCLASS.                    &quot;lcl_screen_400 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_query_element_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_element_generator DEFINITION ABSTRACT.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING i_element TYPE REF TO lcl_query_element,
             generate ABSTRACT
                      RETURNING value(return) TYPE salv_wd_t_string
                      RAISING lcx_fields_overflow lcx_cancel lcx_no_fields_selected lcx_query_element_not_found,

             generate_new_query_text ABSTRACT
                                     IMPORTING i_query        TYPE salv_wd_t_string OPTIONAL
                                               i_query_string TYPE string           OPTIONAL
                                               i_command_text TYPE salv_wd_t_string
                                     RETURNING value(return)  TYPE salv_wd_t_string,

             find_command IMPORTING i_command TYPE string
                                    i_text TYPE string
                          RETURNING value(return) TYPE sy-subrc,

             set_query_element IMPORTING i_element TYPE REF TO lcl_query_element,
             get_query_element RETURNING value(return) TYPE REF TO lcl_query_element.


  PRIVATE SECTION.
    DATA: o_query_element TYPE REF TO lcl_query_element.

ENDCLASS.                    &quot;lcl_query_element_generator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_where_generator DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_where_generator DEFINITION INHERITING FROM lcl_query_element_generator.
  PUBLIC SECTION.
    METHODS: generate REDEFINITION,
             generate_new_query_text REDEFINITION.

  PRIVATE SECTION.
    METHODS: get_fields IMPORTING i_from TYPE REF TO lcl_from
                        EXPORTING e_fields TYPE tyt_where_fields,

             select_fields CHANGING c_fields TYPE tyt_where_fields RAISING lcx_fields_overflow lcx_no_fields_selected,

             get_dynamic_selections IMPORTING i_fields TYPE tyt_where_fields
                                              i_tables TYPE yt_t_table
                                    RETURNING value(return) TYPE salv_wd_t_string
                                    RAISING lcx_cancel lcx_query_element_not_found,

             build_fields_to_selection IMPORTING i_fields TYPE tyt_where_fields
                                                 i_tables TYPE yt_t_table
                                       EXPORTING e_tables_tab TYPE yt_rsdstabs
                                                 e_fields_tab TYPE yt_rsdsfields,

             init_free_selection CHANGING c_tables_tab TYPE yt_rsdstabs
                                          c_fields_tab TYPE yt_rsdsfields
                                          c_selid      TYPE rsdynsel-selid,

             call_select_dialog CHANGING c_selid TYPE rsdynsel-selid
                                         c_fields_tab TYPE yt_rsdsfields
                                         c_twhere TYPE rsds_twhere
                                RAISING lcx_cancel,

             get_dynamic_where IMPORTING i_tables TYPE yt_t_table
                                         i_fields TYPE tyt_where_fields
                                         i_twhere TYPE rsds_twhere
                               RETURNING value(return) TYPE salv_wd_t_string
                               RAISING lcx_query_element_not_found.

ENDCLASS.                    &quot;lcl_where_generator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_select_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_generator DEFINITION INHERITING FROM lcl_query_element_generator.
  PUBLIC SECTION.
    METHODS: generate REDEFINITION,
             generate_new_query_text REDEFINITION,

             generate_by_fieldcat IMPORTING i_fieldcat TYPE REF TO lcl_fieldcat
                                  RETURNING value(return) TYPE salv_wd_t_string,

             set_select_type IMPORTING i_select_type TYPE string,
             get_select_type RETURNING value(return) TYPE string,

             set_select IMPORTING i_select TYPE REF TO lcl_select,
             get_select RETURNING value(return) TYPE REF TO lcl_select,

             set_aggregation IMPORTING i_aggregation TYPE boolean,
             get_aggregation RETURNING value(return) TYPE boolean,

             check_aggregation IMPORTING i_fields TYPE tyt_table_fields,

             compute_aggregation_clause RETURNING value(return) TYPE salv_wd_t_string.

  PRIVATE SECTION.
    DATA: o_select      TYPE REF TO lcl_select,
          v_select_type TYPE string,
          t_fields      TYPE tyt_table_fields,
          v_aggregation TYPE boolean.

    METHODS: get_fields IMPORTING i_tables TYPE yt_t_table
                        EXPORTING e_fields TYPE tyt_table_fields,

             select_fields CHANGING e_fields TYPE tyt_table_fields RAISING lcx_cancel,
             mark_fields CHANGING e_fields TYPE tyt_table_fields,
             compute_fields IMPORTING i_fields TYPE tyt_table_fields RETURNING value(return) TYPE salv_wd_t_string.

ENDCLASS.                    &quot;lcl_select_generator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_from_generator DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_from_generator DEFINITION INHERITING FROM lcl_query_element_generator.

  PUBLIC SECTION.
    METHODS: generate REDEFINITION,
             generate_new_query_text REDEFINITION.

  PRIVATE SECTION.
    DATA: v_gen_select TYPE boolean,
          v_gen_where  TYPE boolean.
    METHODS: select_join_tables EXPORTING e_join_tables TYPE tyt_join_table
                                  RAISING lcx_cancel,

             compute_join_tables IMPORTING i_join_tables TYPE tyt_join_table
                                 RETURNING value(return) TYPE salv_wd_t_string.

ENDCLASS.                    &quot;lcl_from_generator DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_500 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_500 DEFINITION INHERITING FROM lcl_screen.

  PUBLIC SECTION.
    METHODS: lif_screen~user_command REDEFINITION,
             lif_screen~screen_status REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,

             set_fields IMPORTING i_fields TYPE tyt_table_fields,
             get_fields EXPORTING e_fields TYPE tyt_table_fields,

             get_select_type RETURNING value(return) TYPE string,
             set_select_type IMPORTING i_select_type TYPE string,

             check_changed_data,
             refresh_alv IMPORTING i_stable	      TYPE lvc_s_stbl OPTIONAL
                                   i_soft_refresh TYPE char01 OPTIONAL,
             flush,

             lock_drop_down IMPORTING i_all TYPE boolean OPTIONAL,

             mark_fields,
             unmark_fields.

  PRIVATE SECTION.
    DATA: o_grid          TYPE REF TO cl_gui_alv_grid,
          o_container     TYPE REF TO cl_gui_custom_container,
          o_select_type   TYPE REF TO data,
          o_event_handler TYPE REF TO lcl_event_handler,
          o_behaviour_alv TYPE REF TO cl_dragdrop,
          t_fields        TYPE tyt_table_fields.

    METHODS: create_fcat RETURNING value(return) TYPE lvc_t_fcat,
             create_layout RETURNING value(return) TYPE lvc_s_layo,
             add_field_to_fcat IMPORTING i_fieldname  TYPE string
                                         i_edit       TYPE boolean
                                         i_descr      TYPE string
                                         i_outputlen  TYPE i
                                         i_checkbox   TYPE lvc_checkb OPTIONAL
                                         i_drop_down  TYPE i OPTIONAL
                                         i_drop_alias TYPE c OPTIONAL
                                CHANGING e_fieldcat TYPE lvc_t_fcat,

             exclude_functions RETURNING value(return) TYPE ui_functions,

             get_sql_functions_drop_down RETURNING value(return) TYPE lvc_t_dral,

             add_option_to_drop_down IMPORTING i_handle    TYPE	int4
                                               i_value     TYPE string
                                               i_int_value TYPE	string
                                      CHANGING e_drop_down TYPE lvc_t_dral,

             initialize_alv,
             initialize_select_type,

             create_vrm_values RETURNING value(return) TYPE vrm_values,

             add_vrm_value IMPORTING i_key  TYPE string
                                     i_text TYPE string
                            CHANGING e_values TYPE vrm_values,

             verify_selected_fields RETURNING value(return) TYPE boolean.

ENDCLASS.                    &quot;lcl_screen_500 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_600 DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_screen_600 DEFINITION INHERITING FROM lcl_screen.

  PUBLIC SECTION.
    CONSTANTS: c_tabname  TYPE sy-ucomm VALUE &apos;TABNAME&apos;,
               c_tabalias TYPE sy-ucomm VALUE &apos;TABALIAS&apos;.

    METHODS: lif_screen~user_command      REDEFINITION,
             lif_screen~screen_status     REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,

             set_tabname IMPORTING i_tabname TYPE string,
             get_tabname RETURNING value(return) TYPE string,

             set_tabalias IMPORTING i_tabalias TYPE string,
             get_tabalias RETURNING VALUE(return) TYPE string,

             set_tabdescr IMPORTING i_descr TYPE string,
             get_tabdescr RETURNING value(return) TYPE string,

             set_join_tables IMPORTING i_join_tables TYPE tyt_join_table,
             get_join_tables EXPORTING e_join_tables TYPE tyt_join_table,

             get_create_select RETURNING value(return) TYPE boolean,
             get_create_where RETURNING value(return) TYPE boolean,

             set_block_flags IMPORTING i_block TYPE boolean,
             get_block_flags RETURNING value(return) TYPE boolean,

             set_direct_initialize IMPORTING i_direct_initialize TYPE boolean,

             refresh_alv IMPORTING i_stable	      TYPE lvc_s_stbl OPTIONAL
                                   i_soft_refresh TYPE char01 OPTIONAL,

             add_line,
             delete_line RAISING lcx_no_fields_selected,

             suggest_join,

             open_join_fields IMPORTING i_index TYPE lvc_index,

             search_help_for_tabname IMPORTING i_index TYPE i,

             check_join_tables IMPORTING i_index               TYPE i       OPTIONAL
                                         i_consist_join_fields TYPE boolean OPTIONAL
                                         PREFERRED PARAMETER i_consist_join_fields
                               RAISING lcx_join_error,

             get_tables RETURNING value(return) TYPE salv_wd_t_string,

             flush IMPORTING i_no_flags TYPE boolean OPTIONAL,

             build_join_tables IMPORTING i_from TYPE REF TO lcl_from.

  PRIVATE SECTION.
    DATA: o_container   TYPE REF TO cl_gui_custom_container,
          o_alv         TYPE REF TO cl_gui_alv_grid,
          o_handler     TYPE REF TO lcl_event_handler,
          t_join_tables TYPE tyt_join_table,
          v_block_flags TYPE boolean,
          v_direct_initialize TYPE boolean.

    METHODS: check_table_name RAISING lcx_table_not_found,
             check_table_alias RAISING lcx_table_alias,
             initialize_join_grid,
             initialize_container,
             initialize_alv,
             exclude_functions RETURNING value(return) TYPE ui_functions,
             get_fieldcat RETURNING value(return) TYPE lvc_t_fcat,
             get_drop_down RETURNING value(return) TYPE lvc_t_dral,
             add_option_to_drop_down IMPORTING i_handle    TYPE	int4
                                               i_value     TYPE string
                                               i_int_value TYPE	string
                                      CHANGING e_drop_down TYPE lvc_t_dral,
             get_f4_fields RETURNING value(return) TYPE lvc_t_f4,

             get_related_tables IMPORTING i_tabname TYPE string
                                RETURNING value(return) TYPE dd05mttyp,

             compute_related_tables IMPORTING i_tables TYPE dd05mttyp,
             get_block_style_for_join_table RETURNING value(return) TYPE lvc_t_styl,

             add_style IMPORTING i_fieldname TYPE lvc_fname
                                 i_style     TYPE lvc_style
                        CHANGING e_style     TYPE lvc_t_styl,

             consist_join_table IMPORTING i_join_table TYPE ty_join_table
                                          i_index      TYPE i
                                          i_consist_join_fields TYPE boolean OPTIONAL
                                RAISING lcx_join_error.

ENDCLASS.                    &quot;lcl_screen_600 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_700 DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_700 DEFINITION INHERITING FROM lcl_screen.
  PUBLIC SECTION.
    METHODS: lif_screen~user_command      REDEFINITION,
             lif_screen~screen_status     REDEFINITION,
             lif_screen~initialize_screen REDEFINITION,

             set_join_fields IMPORTING i_join_fields TYPE REF TO lcl_join_fields, &quot;dd05mttyp,
             get_join_fields RETURNING value(return) TYPE REF TO lcl_join_fields, &quot;dd05mttyp,

             set_join_table IMPORTING i_table TYPE string,
             get_join_table RETURNING value(return) TYPE string,

             refresh_alv IMPORTING i_stable	      TYPE lvc_s_stbl OPTIONAL
                                   i_soft_refresh TYPE char01 OPTIONAL,

             add_line,
             delete_line,

             consist_tables IMPORTING i_tables TYPE salv_wd_t_string,

             set_handle_checkfield IMPORTING i_index TYPE i
                                             i_value TYPE any,

             flush.

  PRIVATE SECTION.
    DATA: o_container   TYPE REF TO cl_gui_custom_container,
          o_grid        TYPE REF TO cl_gui_alv_grid,
          t_join_fields TYPE tyt_join_fields,
          v_join_table  TYPE string,
          t_handle      TYPE TABLE OF ty_handle,
          t_drop_down   TYPE lvc_t_drop.

    METHODS: initialize_container,
             initialize_alv,
             create_fieldcat RETURNING value(return) TYPE lvc_t_fcat,
             exclude_functions RETURNING value(return) TYPE ui_functions,
             get_style_block_fields RETURNING value(return) TYPE lvc_t_styl,
             add_handle IMPORTING i_tabname       TYPE string
                                  i_tab_handle    TYPE i
                                  i_fields_handle TYPE i,

             add_dropdown IMPORTING i_handle TYPE i
                                    i_fields TYPE tyt_table_fields OPTIONAL
                                    i_value  TYPE any OPTIONAL,

             get_field_handle IMPORTING i_tabname     TYPE any
                              RETURNING value(return) TYPE i,

             compute_join_fields,
             check_join_fields RAISING lcx_join_error.

ENDCLASS.                    &quot;lcl_screen_700 DEFINITION</source>
 </PROG>
 <PROG NAME="ZQUERY_CLASS_IMPLEMENTATION" VARCL="X" SUBC="I" CNAM="ALCANTARA" CDAT="20140919" UNAM="ALCANTARA" UDAT="20141219" VERN="001262" RSTAT="P" RMAND="810" RLOAD="P" SDATE="20141219" STIME="145634" IDATE="20141219" ITIME="145634" UCCHECK="X">
  <textPool/>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Include ZQUERY_CLASS_IMPLEMENTATION
*&amp;---------------------------------------------------------------------*
CLASS lcl_query IMPLEMENTATION .

  METHOD constructor.
    me-&gt;set_query( i_query ).
    me-&gt;compute_query( ).
  ENDMETHOD. &quot;constructor

  &quot;$. Region Getters and Setters
  METHOD set_query.
    me-&gt;t_query = i_query .
  ENDMETHOD. &quot;set_query
  METHOD get_query.
    return = me-&gt;t_query.
  ENDMETHOD. &quot;get_query

  METHOD set_data.
    me-&gt;o_data = i_data.
  ENDMETHOD.                    &quot;set_data
  METHOD get_data.
    return = me-&gt;o_data.
  ENDMETHOD.                    &quot;get_data

  METHOD set_query_string.
    me-&gt;v_query = i_query.
  ENDMETHOD.                    &quot;set_query_string
  METHOD get_query_string.
    return = me-&gt;v_query.
  ENDMETHOD.                    &quot;get_query_String
  &quot;$. Endregion Getters and Setters

  METHOD split_text.
    DATA: l_length TYPE i,
    l_remains TYPE i,
    l_aux TYPE i,
    l_text TYPE string ,
    l_last_char TYPE i.

    l_length = STRLEN( i_text ).

    IF l_length &lt;= i_outputlen.
      APPEND i_text TO return.
      RETURN.
    ELSE.

      l_remains = l_length.

      DO.
        IF i_outputlen &lt; l_remains.
          l_text = i_text+l_aux(i_outputlen).
        ELSE.
          APPEND i_text+l_aux(l_remains) TO return.
          EXIT.
        ENDIF.

        l_last_char = STRLEN( l_text ) - 1.

        DO.
          DATA l_char TYPE char1.

          l_char = l_text+l_last_char(1).
          CONDENSE l_char NO-GAPS.

          IF l_char IS INITIAL OR l_char = space.
            EXIT.
          ENDIF.
          l_last_char = STRLEN( l_text(l_last_char) ) - 1.
        ENDDO.

        APPEND l_text(l_last_char) TO return.
        ADD l_last_char TO l_aux .
        l_remains = l_length - l_aux.
      ENDDO.
    ENDIF.
  ENDMETHOD. &quot;split_text

  METHOD add_query_element.
    APPEND i_query_element TO me-&gt;t_query_elements.
  ENDMETHOD. &quot;add_query_element

  METHOD get_query_elements.
    e_elements = me-&gt;t_query_elements .
  ENDMETHOD. &quot;get_query_elements

  METHOD execute.
    CONSTANTS: c_form_name TYPE string VALUE &apos;F_EXECUTE&apos;.

    DATA: o_data        TYPE REF TO data,
          o_select      TYPE REF TO lcl_select,
          o_report      TYPE REF TO lcl_report,
          t_split_1     TYPE salv_wd_t_string,
          t_split_2     TYPE salv_wd_t_string,

          l_report_name TYPE string,
          l_query       TYPE string,
          l_split_1     TYPE string,
          l_split_2     TYPE string.

    o_data = me-&gt;get_data( ).
    o_select ?= me-&gt;get_query_element( lcl_commands=&gt;select ).

    CONCATENATE &apos;ZQUERY_EXEC&apos; sy-datum sy-uzeit INTO l_report_name SEPARATED BY &apos;_&apos;.
    CREATE OBJECT o_report
      EXPORTING
        i_report_name = l_report_name.

    l_query = me-&gt;get_query_string( ).
    SPLIT l_query AT lcl_commands=&gt;from_check INTO l_split_1 l_split_2.
    CONCATENATE lcl_commands=&gt;from l_split_2 &apos;.&apos; INTO l_split_2 SEPARATED BY space.
    CONDENSE: l_split_1, l_split_2.
    t_split_1 = lcl_query=&gt;split_text( i_text = l_split_1
                                       i_outputlen = 80 ).
    t_split_2 = lcl_query=&gt;split_text( i_text = l_split_2
                                       i_outputlen = 80 ).

    o_report-&gt;add_report_name( ).
    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;FORM F_EXECUTE.&apos; ).
    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;DATA: O_DATA TYPE REF TO DATA.&apos; ).
    o_report-&gt;add_source( &apos;DATA: O_WA_DATA TYPE REF TO DATA.&apos; ).
    o_report-&gt;add_source( &apos;DATA: V_COUNT TYPE I.&apos; ).
    o_report-&gt;add_source( &apos;FIELD-SYMBOLS: &lt;FS_TAB&gt; TYPE STANDARD TABLE.&apos; ).
    o_report-&gt;add_source( &apos;FIELD-SYMBOLS: &lt;FS_WA&gt; TYPE ANY.&apos; ).
    o_report-&gt;add_source( &apos;FIELD-SYMBOLS: &lt;FS_AUX&gt; TYPE ANY.&apos; ).
    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;O_DATA = ZCL_ZQUERY_DATA_TRANSFER=&gt;GET_DATA( ).&apos; ).
    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;ASSIGN O_DATA-&gt;* TO &lt;FS_TAB&gt;. CHECK SY-SUBRC IS INITIAL.&apos; ).
    o_report-&gt;add_source( ). &quot;Blank line

    IF o_select-&gt;get_select_type( ) = lcl_commands=&gt;single.
      o_report-&gt;add_source( &apos;CREATE DATA O_WA_DATA LIKE LINE OF &lt;FS_TAB&gt;.&apos; ).
      o_report-&gt;add_source( &apos;ASSIGN O_WA_DATA-&gt;* TO &lt;FS_WA&gt;. CHECK SY-SUBRC IS INITIAL.&apos; ).
      o_report-&gt;add_source( ). &quot;Blank line
      LOOP AT t_split_1 INTO l_split_1.
        o_report-&gt;add_source( l_split_1 ).
      ENDLOOP.
      IF me-&gt;get_fields_count( ) &gt; lcl_select=&gt;c_max_fields.
        o_report-&gt;add_source( &apos;INTO CORRESPONDING FIELDS OF &lt;FS_WA&gt;&apos; ).
      ELSE.
        o_report-&gt;add_source( &apos;INTO &lt;FS_WA&gt;&apos; ).
      ENDIF.
      LOOP AT t_split_2 INTO l_split_2.
        o_report-&gt;add_source( l_split_2 ).
      ENDLOOP.
      o_report-&gt;add_source( ). &quot;Blank line
      o_report-&gt;add_source( &apos;APPEND &lt;FS_WA&gt; TO &lt;FS_TAB&gt;.&apos; ).

    ELSEIF o_select-&gt;get_select_type( ) = lcl_commands=&gt;count.
      o_report-&gt;add_source( &apos;CREATE DATA O_WA_DATA LIKE LINE OF &lt;FS_TAB&gt;.&apos; ).
      o_report-&gt;add_source( &apos;ASSIGN O_WA_DATA-&gt;* TO &lt;FS_WA&gt;. CHECK SY-SUBRC IS INITIAL.&apos; ).
      o_report-&gt;add_source( ). &quot;Blank line
      LOOP AT t_split_1 INTO l_split_1.
        o_report-&gt;add_source( l_split_1 ).
      ENDLOOP.
      o_report-&gt;add_source( &apos;INTO V_COUNT&apos; ).
      LOOP AT t_split_2 INTO l_split_2.
        o_report-&gt;add_source( l_split_2 ).
      ENDLOOP.
      o_report-&gt;add_source( ). &quot;Blank line
      o_report-&gt;add_source( &apos;ASSIGN COMPONENT 1 OF STRUCTURE &lt;FS_WA&gt; TO &lt;FS_AUX&gt;. CHECK SY-SUBRC IS INITIAL.&apos; ).
      o_report-&gt;add_source( ). &quot;Blank line
      o_report-&gt;add_source( &apos;&lt;FS_AUX&gt; = V_COUNT.&apos; ).
      o_report-&gt;add_source( ). &quot;Blank line
      o_report-&gt;add_source( &apos;APPEND &lt;FS_WA&gt; TO &lt;FS_TAB&gt;.&apos; ).

    ELSE.
      LOOP AT t_split_1 INTO l_split_1.
        o_report-&gt;add_source( l_split_1 ).
      ENDLOOP.
      IF me-&gt;get_fields_count( ) &gt; lcl_select=&gt;c_max_fields.
        o_report-&gt;add_source( &apos;INTO CORRESPONDING FIELDS OF TABLE &lt;FS_TAB&gt;&apos; ).
      ELSE.
        o_report-&gt;add_source( &apos;INTO TABLE &lt;FS_TAB&gt;&apos; ).
      ENDIF.
      LOOP AT t_split_2 INTO l_split_2.
        o_report-&gt;add_source( l_split_2 ).
      ENDLOOP.

    ENDIF.

    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;ZCL_ZQUERY_DATA_TRANSFER=&gt;SET_DATA( O_DATA ).&apos; ).
    o_report-&gt;add_source( ). &quot;Blank line
    o_report-&gt;add_source( &apos;ENDFORM.&apos; ).

    zcl_zquery_data_transfer=&gt;set_data( o_data ).

    l_report_name = o_report-&gt;generate_report( ).
    IF sy-subrc IS INITIAL.
      o_report-&gt;execute_report( i_form_name   = c_form_name
                                i_report_name = l_report_name ).
      o_report-&gt;delete_report( l_report_name ).
    ENDIF.

    o_data = zcl_zquery_data_transfer=&gt;get_data( ).
    me-&gt;set_data( o_data ).

  ENDMETHOD. &quot;execute

  METHOD compute_query.
    DATA: t_aux        TYPE salv_wd_t_string,
          t_query_comp TYPE salv_wd_t_string,
          t_query      TYPE salv_wd_t_string,
          l_query      TYPE string,
          l_string     TYPE string,
          l_line       TYPE i.

    FIELD-SYMBOLS: &lt;fs_text&gt; TYPE char255,
    &lt;fs_string&gt; TYPE string.

    t_query = me-&gt;get_query( ).

    LOOP AT t_query INTO l_string.
      CONCATENATE l_query l_string INTO l_query SEPARATED BY space.
    ENDLOOP.

    TRANSLATE l_query TO UPPER CASE.
    CONDENSE l_query.
    me-&gt;set_query_string( l_query ).

    SPLIT l_query AT space INTO TABLE t_aux.

    LOOP AT t_aux INTO l_string.
      IF l_string = &apos;&apos;&apos;&apos;.
        DESCRIBE TABLE t_query_comp LINES l_line.
        READ TABLE t_query_comp ASSIGNING &lt;fs_string&gt; INDEX l_line.
        CONCATENATE &lt;fs_string&gt; l_string INTO &lt;fs_string&gt;.
        UNASSIGN &lt;fs_string&gt;.
      ELSE.
        APPEND l_string TO t_query_comp.
      ENDIF.
    ENDLOOP.

    me-&gt;set_query( t_query_comp ).
  ENDMETHOD. &quot;compute_query

  METHOD check_query_syntax.
    DATA: o_report      TYPE REF TO lcl_report,
          t_program     TYPE salv_wd_t_string,
          l_report_name TYPE string,
          l_query       TYPE string. &quot;salv_wd_t_string

    l_query = me-&gt;get_query_string( ).

    CONCATENATE &apos;ZQUERY_CHECK&apos; sy-datum sy-uzeit INTO l_report_name SEPARATED BY &apos;_&apos;.
    CREATE OBJECT o_report
      EXPORTING
        i_report_name = l_report_name.

    me-&gt;build_to_syntax_check( i_query  = l_query
                               i_report = o_report ).

    o_report-&gt;check_syntax( ).

    return = abap_true.

  ENDMETHOD. &quot;check_query_syntax

  METHOD build_to_syntax_check.
    DATA: t_select       TYPE salv_wd_t_string,
          t_aux          TYPE salv_wd_t_string,
          l_split_1      TYPE string,
          l_split_2      TYPE string,
          l_query_aux    TYPE string,
          l_data         TYPE string,
          l_into         TYPE string,
          l_index        TYPE i VALUE 1,
          l_single       TYPE boolean,
          l_count        TYPE boolean,
          l_select_field TYPE string,
          l_out          TYPE boolean,
          l_aux TYPE string.
    FIELD-SYMBOLS &lt;fs_aux&gt; TYPE string.

    l_query_aux = i_query.

    &quot;$. Region Check Commands
    DATA: l_length TYPE i,
          l_length_aux TYPE i.
    l_length = STRLEN( lcl_commands=&gt;select ).
    l_length_aux = STRLEN( l_query_aux ).
    IF l_length_aux &lt; l_length.
      l_length = l_length_aux.
    ENDIF.
    IF l_query_aux(l_length) &lt;&gt; lcl_commands=&gt;select.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = &apos;No SELECT command found&apos;.
    ENDIF.

    FIND lcl_commands=&gt;from_check IN l_query_aux.
    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = &apos;No FROM command found&apos;.
    ENDIF.
    &quot;$. Endregion Check Commands

    SPLIT l_query_aux AT lcl_commands=&gt;from_check INTO l_split_1 l_split_2.
    CONDENSE: l_split_1, l_split_2.
    FIND lcl_commands=&gt;single_check IN l_split_1.
    IF sy-subrc IS INITIAL.
      l_single = abap_true.
    ENDIF.

    SPLIT l_split_1 AT space INTO TABLE t_select.
    READ TABLE t_select WITH KEY table_line = lcl_commands=&gt;select TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
      DELETE t_select INDEX sy-tabix.
    ENDIF.

    READ TABLE t_select WITH KEY table_line = lcl_commands=&gt;single TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
      DELETE t_select INDEX sy-tabix.
    ENDIF.

    IF l_single = abap_false.
      WHILE l_out = abap_false.
        CLEAR l_select_field.
        LOOP AT t_select ASSIGNING &lt;fs_aux&gt; FROM l_index.
          l_index = sy-tabix.
          AT LAST.
            l_out = abap_true.
          ENDAT.

          IF &lt;fs_aux&gt; = lcl_commands=&gt;count_check OR l_count = abap_true.
            l_count = abap_true.
            CONCATENATE l_select_field &lt;fs_aux&gt; INTO l_select_field SEPARATED BY space.
          ELSE.
            CONCATENATE l_select_field &lt;fs_aux&gt; INTO l_select_field SEPARATED BY space.
          ENDIF.

          IF l_count = abap_true.
            IF &lt;fs_aux&gt; = &apos;)&apos;.
              ADD 1 TO l_index.
              READ TABLE t_select INTO l_aux INDEX l_index.
              IF l_aux &lt;&gt; lcl_commands=&gt;as.
                l_count = abap_false. CONDENSE l_select_field.
                APPEND l_select_field TO t_aux.
                EXIT.
              ENDIF.
            ENDIF.
          ELSE.
            ADD 1 TO l_index.
            READ TABLE t_select INTO l_aux INDEX l_index.
            IF l_aux &lt;&gt; lcl_commands=&gt;as.
              CONDENSE l_select_field.
              APPEND l_select_field TO t_aux.
              EXIT.
            ENDIF.
          ENDIF.
        ENDLOOP.
        IF NOT sy-subrc IS INITIAL.
          l_out = abap_true.
        ENDIF.
      ENDWHILE.

      LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
        FIND lcl_commands=&gt;count_check IN &lt;fs_aux&gt;.
        IF sy-subrc IS INITIAL.
          DELETE t_aux.
        ENDIF.
      ENDLOOP.

      IF t_aux IS INITIAL.
        l_count = abap_true.
      ENDIF.
    ENDIF.

    IF l_single = abap_true OR l_count = abap_true.
      l_data = &apos;FIELD-SYMBOLS &lt;fs_wa&gt; TYPE ANY.&apos;.           &quot;#EC NOTEXT
      l_into = &apos;INTO &lt;fs_wa&gt;&apos;.
    ELSE.
      l_data = &apos;FIELD-SYMBOLS &lt;fs_tab&gt; TYPE STANDARD TABLE.&apos;. &quot;#EC NOTEXT
      l_into = &apos;INTO TABLE &lt;fs_tab&gt;&apos;.
    ENDIF.

    CONCATENATE lcl_commands=&gt;from l_split_2 &apos;.&apos; INTO l_split_2 SEPARATED BY space.

    i_report-&gt;add_report_name( ).
    i_report-&gt;add_source( ).
    i_report-&gt;add_source( l_data ).
    i_report-&gt;add_source( ).
    i_report-&gt;add_source( l_split_1 ).
    i_report-&gt;add_source( l_into ).
    i_report-&gt;add_source( l_split_2 ).

  ENDMETHOD. &quot;build_to_sysntax_check

  METHOD identify_query_elements.
    DATA: t_query         TYPE salv_wd_t_string,
          o_query_element TYPE REF TO lcl_query_element.
    FIELD-SYMBOLS: &lt;fs_command&gt; TYPE string.

    IF NOT i_element IS INITIAL.
      READ TABLE me-&gt;t_query WITH KEY table_line = i_element TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        return = lcl_query_element_factory=&gt;factory_query_element( i_element ).
        return-&gt;set_command_contents( i_query   = me-&gt;t_query
                                      i_command = i_element ).
      ENDIF.
    ELSE.
      LOOP AT lcl_commands=&gt;t_identify_commands ASSIGNING &lt;fs_command&gt;.
        READ TABLE me-&gt;t_query WITH KEY table_line = &lt;fs_command&gt; TRANSPORTING NO FIELDS.
        IF sy-subrc IS INITIAL.
          o_query_element = lcl_query_element_factory=&gt;factory_query_element( &lt;fs_command&gt; ).
          o_query_element-&gt;set_command_contents( i_query   = me-&gt;t_query
                                                 i_command = &lt;fs_command&gt; ).
          me-&gt;add_query_element( o_query_element ).
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;identify_query_elements

  METHOD get_query_element.
    READ TABLE me-&gt;t_query_elements INTO return WITH KEY table_line-&gt;v_element = i_element.
  ENDMETHOD.                    &quot;get_query_element

  METHOD get_fields_count.
    DATA: o_select TYPE REF TO lcl_select.
    o_select ?= me-&gt;get_query_element( lcl_commands=&gt;select ).
    return = o_select-&gt;get_fields_count( ).
  ENDMETHOD.                    &quot;get_fields_count

ENDCLASS. &quot;lcl_query IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_select IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select IMPLEMENTATION .

  &quot;$. Region Getters and Setters
  METHOD set_select_type.
    me-&gt;select_type = i_select_type .
  ENDMETHOD. &quot;set_select_type

  METHOD get_select_type.
    DATA: o_field  TYPE REF TO lcl_field,
          t_fields TYPE TABLE OF REF TO lcl_field,
          l_count TYPE boolean.

    me-&gt;get_fields( IMPORTING return = t_fields ).

    IF me-&gt;select_type = lcl_commands=&gt;single.
      return = me-&gt;select_type.
      RETURN.

    ELSEIF me-&gt;select_type = lcl_commands=&gt;distinct.
      return = me-&gt;select_type.
      RETURN.

    ELSEIF LINES( t_fields ) = 1.
      READ TABLE t_fields INTO o_field INDEX 1.
      IF o_field-&gt;get_field_name( ) = lcl_commands=&gt;asterisk AND o_field-&gt;get_count_field( ) = abap_true.
        return = lcl_commands=&gt;count.
        RETURN.
      ELSEIF o_field-&gt;get_field_name( ) = lcl_commands=&gt;asterisk.
        return = lcl_commands=&gt;asterisk.
        RETURN.
      ENDIF.

    ELSE.
      LOOP AT t_fields INTO o_field.
        IF o_field-&gt;get_count_field( ) = abap_true.
          l_count = abap_true.
        ELSE.
          l_count = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF l_count = abap_true.
        return = lcl_commands=&gt;single.
      ENDIF.

    ENDIF.

  ENDMETHOD. &quot;get_select_type
  &quot;$. Endregion Getters and Setters

  METHOD get_fields_count.
    DESCRIBE TABLE me-&gt;t_fields LINES return.
  ENDMETHOD.                    &quot;get_fields_count

  METHOD add_field.
    APPEND i_field TO me-&gt;t_fields.
  ENDMETHOD. &quot;add_field

  METHOD get_fields.
    return = me-&gt;t_fields.
  ENDMETHOD.                    &quot;get_fields

  METHOD set_command_contents.
    DATA: o_field      TYPE REF TO lcl_field,
          l_sql_func   TYPE char3,
          l_string     TYPE string,
          l_aux        TYPE string,
          l_index      TYPE sytabix,
          l_name       TYPE string,
          l_alias      TYPE string,
          l_table_name TYPE string,
          l_alias_on   TYPE boolean,
          l_count_on   TYPE boolean,
          l_out TYPE boolean.

    READ TABLE i_query WITH KEY table_line = i_command TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix.
      ADD 1 TO l_index.

      READ TABLE i_query INTO l_string INDEX l_index.
      IF l_string = lcl_commands=&gt;single OR
         l_string = lcl_commands=&gt;distinct.
        me-&gt;set_select_type( l_string ).
        ADD 1 TO l_index.

      ELSEIF l_string = lcl_commands=&gt;asterisk.
        me-&gt;set_select_type( lcl_commands=&gt;asterisk ).

      ENDIF.

      WHILE l_out = abap_false.
        LOOP AT i_query INTO l_string FROM l_index.
          l_index = sy-tabix.
          IF l_string = lcl_commands=&gt;from  OR
             l_string = lcl_commands=&gt;where OR
             l_string = lcl_commands=&gt;up.
            l_out = abap_true.
            EXIT.
          ENDIF.

          CASE l_string.
            WHEN lcl_commands=&gt;count_check.
              CREATE OBJECT o_field
                EXPORTING
                  i_field_name = space.
              o_field-&gt;set_count_field( abap_true ).

            WHEN lcl_commands=&gt;max_check OR
                 lcl_commands=&gt;sum_check OR
                 lcl_commands=&gt;min_check OR
                 lcl_commands=&gt;avg_check.
              CREATE OBJECT o_field
                EXPORTING
                  i_field_name = space.
              l_sql_func = l_string. l_string = l_sql_func.
              o_field-&gt;set_sql_function( l_string ).

            WHEN &apos;)&apos;.
              l_index = me-&gt;check_alias_existence( i_query = i_query
                                                   i_index = l_index
                                                   i_field = o_field ).
              CLEAR o_field. EXIT.

            WHEN OTHERS.
              IF o_field IS BOUND                        AND
                 o_field-&gt;get_count_field( ) = abap_true AND
                l_string &lt;&gt; lcl_commands=&gt;distinct.
                me-&gt;split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                o_field-&gt;set_field_name( l_name ).
                o_field-&gt;set_table_name( l_table_name ).

              ELSEIF o_field IS BOUND AND NOT o_field-&gt;get_sql_function( ) IS INITIAL.
                me-&gt;split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                o_field-&gt;set_field_name( l_name ).
                o_field-&gt;set_table_name( l_table_name ).

              ELSEIF NOT o_field IS BOUND.
                me-&gt;split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                CREATE OBJECT o_field
                  EXPORTING
                    i_field_name = l_name
                    i_table_name = l_table_name.

                l_index = me-&gt;check_alias_existence( i_query = i_query
                                                     i_index = l_index
                                                     i_field = o_field ).
                CLEAR o_field. EXIT.
              ENDIF.

          ENDCASE.

          APPEND l_string TO me-&gt;t_command_contents.
          CONCATENATE me-&gt;v_command l_string INTO me-&gt;v_command SEPARATED BY space.
        ENDLOOP.
      ENDWHILE.

    ENDIF.
  ENDMETHOD.                    &quot;set_command_contents

  METHOD split_field_name.
    DATA: l_aux_1 TYPE string,
          l_aux_2 TYPE string.

    SPLIT i_field AT &apos;~&apos; INTO l_aux_1 l_aux_2.
    IF l_aux_2 IS INITIAL.
      e_name = l_aux_1.
    ELSE.
      e_tabname = l_aux_1.
      e_name    = l_aux_2.
    ENDIF.
  ENDMETHOD.                    &quot;split_field_name

  METHOD check_alias_existence.
    DATA: l_index TYPE i,
          l_aux   TYPE string.

    l_index = i_index.
    ADD 1 TO l_index.
    READ TABLE i_query INTO l_aux INDEX l_index.
    IF l_aux = lcl_commands=&gt;as.
      ADD 1 TO l_index.
      READ TABLE i_query INTO l_aux INDEX l_index.
      i_field-&gt;set_field_alias( l_aux ).
      ADD 1 TO l_index.
    ENDIF.

    me-&gt;add_field( i_field ).

    return = l_index.

  ENDMETHOD.                    &quot;check_alias_existence

ENDCLASS. &quot;lcl_select IMPLEMENTATION
*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_field
*&amp;---------------------------------------------------------------------*
CLASS lcl_field IMPLEMENTATION .

  &quot;$. Region Getters and Setters
  METHOD set_field_alias.
    me-&gt;v_field_alias = i_field_alias .
  ENDMETHOD. &quot;set_field_alias

  METHOD get_field_alias.
    return = me-&gt;v_field_alias.
  ENDMETHOD. &quot;get_field_alias

  METHOD set_field_name.
    me-&gt;v_field_name = i_field_name .
  ENDMETHOD. &quot;set_field_name

  METHOD get_field_name.
    return = me-&gt;v_field_name.
  ENDMETHOD. &quot;get_field_name

  METHOD set_table_name.
    me-&gt;v_table_name = i_table_name.
  ENDMETHOD.                    &quot;set_table_name
  METHOD get_table_name.
    return = me-&gt;v_table_name.
  ENDMETHOD.                    &quot;get_table_name

  METHOD set_count_field.
    me-&gt;v_count_field = i_count.
  ENDMETHOD.                    &quot;set_count_field
  METHOD get_count_field.
    return = me-&gt;v_count_field.
  ENDMETHOD.                    &quot;get_count_field

  METHOD set_sql_function.
    me-&gt;v_sql_function = i_sql_function.
  ENDMETHOD.                    &quot;set_sql_function
  METHOD get_sql_function.
    return = me-&gt;v_sql_function.
  ENDMETHOD.                    &quot;get_sql_function
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_field_name( i_field_name ).
    me-&gt;set_field_alias( i_field_alias ).
    me-&gt;set_table_name( i_table_name ).
  ENDMETHOD.                    &quot;constructor

ENDCLASS. &quot;lcl_field

*----------------------------------------------------------------------*
*       CLASS lcl_join_fields IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_join_fields IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_fortable.
    me-&gt;v_fortable = i_fortable.
  ENDMETHOD.                    &quot;set_fortable
  METHOD get_fortable.
    return = me-&gt;v_fortable.
  ENDMETHOD.                    &quot;get_fortable

  METHOD set_forkey.
    me-&gt;v_forkey = i_forkey.
  ENDMETHOD.                    &quot;set_forkey
  METHOD get_forkey.
    return = me-&gt;v_forkey.
  ENDMETHOD.                    &quot;get_forkey

  METHOD set_checktable.
    me-&gt;v_checktable = i_checktable.
  ENDMETHOD.                    &quot;set_checktable
  METHOD get_checktable.
    return = me-&gt;v_checktable.
  ENDMETHOD.                    &quot;get_checktable

  METHOD set_checkfield.
    me-&gt;v_checkfield = i_checkfield.
  ENDMETHOD.                    &quot;set_checkfield
  METHOD get_checkfield.
    return = me-&gt;v_checkfield.
  ENDMETHOD.                    &quot;get_checkfield

  METHOD set_join_fields.
    me-&gt;t_join_fields = i_join_fields.
  ENDMETHOD.                    &quot;set_join_fields
  METHOD get_join_fields.
    e_join_fields = me-&gt;t_join_fields.
  ENDMETHOD.                    &quot;get_join_fields
  &quot;$. Endregion Getters and Setters

  METHOD add_join_field.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.
    APPEND INITIAL LINE TO me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt;.
    &lt;fs_join_field&gt;-fortable   = i_fortable. &quot;me-&gt;get_fortable( ).
    &lt;fs_join_field&gt;-forkey     = i_forkey. &quot;me-&gt;get_forkey( ).
    &lt;fs_join_field&gt;-checktable = i_checktable. &quot;me-&gt;get_checktable( ).
    &lt;fs_join_field&gt;-checkfield = i_checkfield. &quot;me-&gt;get_checkfield( ).
    &lt;fs_join_field&gt;-signal     = &apos;=&apos;.
    UNASSIGN &lt;fs_join_field&gt;.
  ENDMETHOD.                    &quot;add_join_field

  METHOD get_join_fields_count.
    DESCRIBE TABLE me-&gt;t_join_fields LINES return.
  ENDMETHOD.                    &quot;get_join_fields_count

ENDCLASS.                    &quot;lcl_join_fields DEFINITION

*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_table
*&amp;---------------------------------------------------------------------*
CLASS lcl_table IMPLEMENTATION .

  &quot;$. Region Getters and setters
  METHOD set_name.
    me-&gt;v_name = i_name .
  ENDMETHOD. &quot;set_name
  METHOD get_name.
    return = me-&gt;v_name.
  ENDMETHOD. &quot;get_name

  METHOD set_alias.
    me-&gt;v_alias = i_alias .
  ENDMETHOD. &quot;set_alias
  METHOD get_alias.
    return = me-&gt;v_alias.
  ENDMETHOD. &quot;get_alias

  METHOD set_outer_join.
    me-&gt;v_outer_join = i_outer_join.
  ENDMETHOD.                    &quot;set_outer_join
  METHOD get_outer_join.
    return = me-&gt;v_outer_join.
  ENDMETHOD.                    &quot;get_outer_join

  METHOD set_join_fields.
    me-&gt;t_join_fields = i_join_fields.
  ENDMETHOD.                    &quot;set_join_fields
  METHOD get_join_fields.
    e_join_fields = me-&gt;t_join_fields.
  ENDMETHOD.                    &quot;get_join_fields

  METHOD set_join_kind.
    me-&gt;v_join_kind = i_join_kind.
  ENDMETHOD.                    &quot;set_join_kind
  METHOD get_join_kind.
    return = me-&gt;v_join_kind.
  ENDMETHOD.                    &quot;get_join_kind
  &quot;$. Endregion Getters and setters

  METHOD constructor.
    me-&gt;set_name( i_name ).
    me-&gt;set_alias( i_alias ).
  ENDMETHOD.                    &quot;constructor

  METHOD get_table_fields.
    DATA: t_fcat TYPE lvc_t_fcat,
          l_name TYPE dd02l-tabname.

    FIELD-SYMBOLS: &lt;fs_fcat&gt;  TYPE lvc_s_fcat,
                   &lt;fs_field&gt; TYPE ty_table_fields.

    l_name = me-&gt;get_name( ).

    CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
      EXPORTING
        i_buffer_active        = abap_false
        i_structure_name       = l_name
        i_bypassing_buffer     = abap_true
      CHANGING
        ct_fieldcat            = t_fcat
      EXCEPTIONS
        inconsistent_interface = 1
        program_error          = 2
        OTHERS                 = 3.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    LOOP AT t_fcat ASSIGNING &lt;fs_fcat&gt;.
      APPEND INITIAL LINE TO e_fields ASSIGNING &lt;fs_field&gt;.
      &lt;fs_field&gt;-tabname       = &lt;fs_fcat&gt;-ref_table.
      &lt;fs_field&gt;-fieldname     = &lt;fs_fcat&gt;-fieldname.
      &lt;fs_field&gt;-descr         = &lt;fs_fcat&gt;-scrtext_l.
      &lt;fs_field&gt;-tab_alias     = me-&gt;get_alias( ).
      &lt;fs_field&gt;-internal_type = &lt;fs_fcat&gt;-inttype.
      UNASSIGN &lt;fs_field&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_table_fields

  METHOD check_table_name.
    SELECT COUNT( * )
      FROM dd02l
     WHERE tabname   = i_tabname
       AND as4local  = &apos;A&apos;
       AND tabclass &lt;&gt; &apos;INTTAB&apos;.
    IF sy-subrc IS INITIAL.
      return = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;check_table_name

  METHOD get_description_from_ddic.
    SELECT SINGLE ddtext
      INTO return
      FROM dd02t
     WHERE tabname    = me-&gt;v_name
       AND ddlanguage = sy-langu
       AND as4local   = &apos;A&apos;.
  ENDMETHOD.                    &quot;get_description_from_ddic

ENDCLASS. &quot;lcl_table
*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_from
*&amp;---------------------------------------------------------------------*
CLASS lcl_from IMPLEMENTATION .

  METHOD add_table.
    APPEND i_table TO me-&gt;t_tables.
  ENDMETHOD. &quot;add_table

  METHOD check_outer_join.

    DATA: l_tabix TYPE i.

    FIELD-SYMBOLS &lt;fs_aux&gt; TYPE string.

    return = abap_false.

    l_tabix = i_index.

    SUBTRACT 2 FROM l_tabix.
    READ TABLE i_query ASSIGNING &lt;fs_aux&gt; INDEX l_tabix.
    IF sy-subrc IS INITIAL.
      IF &lt;fs_aux&gt; = lcl_commands=&gt;left OR &lt;fs_aux&gt; = lcl_commands=&gt;outer OR &lt;fs_aux&gt; = lcl_commands=&gt;right.
        return = abap_true.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;check_outer_join

  METHOD set_command_contents.
    DATA: o_table      TYPE REF TO lcl_table,
          t_query      TYPE salv_wd_t_string,
          l_string     TYPE string,
          l_alias      TYPE string,
          l_index      TYPE sytabix,
          l_tabix      TYPE i,
          l_from_index TYPE sytabix,
          l_join_on    TYPE boolean,
          l_first      TYPE boolean,
          l_outer_join TYPE boolean,
          l_length     TYPE i,
          l_aux        TYPE string.

    FIELD-SYMBOLS: &lt;fs_aux&gt; TYPE string.

    t_query = i_query.
    DELETE t_query WHERE table_line = &apos;(&apos; OR table_line = &apos;)&apos; OR table_line = &apos;).&apos;.

    READ TABLE t_query WITH KEY table_line = lcl_commands=&gt;from TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix + 1.

      l_first = abap_true.
      LOOP AT t_query INTO l_string FROM l_index.
        IF l_string = lcl_commands=&gt;select OR
           l_string = lcl_commands=&gt;where  OR
           l_string = lcl_commands=&gt;order  OR
           l_string = lcl_commands=&gt;having OR
           l_string = lcl_commands=&gt;group  OR
           l_string = lcl_commands=&gt;up.
          EXIT.
        ENDIF.

        l_tabix = sy-tabix.

        l_length = STRLEN( l_string ).
        SUBTRACT 1 FROM l_length.
        IF l_string+l_length = &apos;.&apos; OR l_string+l_length = &apos;;&apos;.
          l_string = l_string(l_length).
        ENDIF.

        IF l_first = abap_true.

          CREATE OBJECT o_table
            EXPORTING
              i_name = l_string.
          l_alias = me-&gt;check_alias( i_query = t_query i_index = l_tabix ).
          IF NOT l_alias IS INITIAL.
            o_table-&gt;set_alias( l_alias ).
          ENDIF.
          me-&gt;add_table( o_table ).
          l_first = abap_false.
        ENDIF.

        IF l_join_on = abap_true.
          CREATE OBJECT o_table
            EXPORTING
              i_name = l_string.
          l_alias = me-&gt;check_alias( i_query = t_query i_index = l_tabix ).
          IF NOT l_alias IS INITIAL.
            o_table-&gt;set_alias( l_alias ).
          ENDIF.
          IF me-&gt;check_outer_join( i_query = t_query i_index = l_tabix ) = abap_true.
            o_table-&gt;set_outer_join( abap_true ).
          ENDIF.
          me-&gt;add_table( o_table ).
          me-&gt;check_join_fields( i_table = o_table
                                 i_query = t_query
                                 i_index = l_tabix ).
          l_join_on = abap_false.
        ENDIF.

        IF l_string = lcl_commands=&gt;join.
          l_join_on = abap_true.
        ENDIF.

        APPEND l_string TO me-&gt;t_command_contents.
        CONCATENATE me-&gt;v_command l_string INTO me-&gt;v_command SEPARATED BY space.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    &quot;set_command_contents

  METHOD get_table.
    DATA: l_name  TYPE string,
          l_alias TYPE string.

    FIELD-SYMBOLS &lt;fs_table&gt; TYPE REF TO lcl_table.

    IF NOT i_index IS INITIAL.
      READ TABLE me-&gt;t_tables INTO return INDEX i_index.
    ELSE.
      LOOP AT me-&gt;t_tables ASSIGNING &lt;fs_table&gt;.
        l_name = &lt;fs_table&gt;-&gt;get_name( ).
        l_alias = &lt;fs_table&gt;-&gt;get_alias( ).
        IF l_name = i_table OR l_alias = i_table.
          return = &lt;fs_table&gt;.
          RETURN.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF return IS INITIAL.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

  ENDMETHOD.                    &quot;get_table

  METHOD get_tables.
    e_tables = me-&gt;t_tables.
  ENDMETHOD.                    &quot;get_tables

  METHOD check_join_fields.
    DATA: o_aux         TYPE REF TO lcl_table,
          t_join_fields TYPE tyt_join_fields,
          l_subtract    TYPE i,
          l_index       TYPE i,
          l_string      TYPE string,
          l_out         TYPE boolean,
          l_split_1     TYPE string,
          l_split_2     TYPE string.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.

    l_index = i_index.
    SUBTRACT 2 FROM l_index.
    READ TABLE i_query INTO l_string INDEX l_index.
    IF sy-subrc IS INITIAL AND
      ( l_string = lcl_commands=&gt;inner OR
        l_string = lcl_commands=&gt;left  OR
        l_string = lcl_commands=&gt;right OR
        l_string = lcl_commands=&gt;outer ).
      CASE l_string.
        WHEN lcl_commands=&gt;inner.
          i_table-&gt;set_join_kind( lcl_commands=&gt;inner_join_command ).
        WHEN lcl_commands=&gt;left .
          i_table-&gt;set_join_kind( lcl_commands=&gt;left_join_command ).
        WHEN lcl_commands=&gt;right.
          i_table-&gt;set_join_kind( lcl_commands=&gt;right_join_command ).
        WHEN lcl_commands=&gt;outer.
          i_table-&gt;set_join_kind( lcl_commands=&gt;outer_join_command ).
        WHEN OTHERS.
          i_table-&gt;set_join_kind( lcl_commands=&gt;join ).
      ENDCASE.
    ELSEIF sy-subrc IS INITIAL.
      i_table-&gt;set_join_kind( lcl_commands=&gt;join ).
    ENDIF.

    ADD 2 TO l_index.
    READ TABLE i_query INTO l_string INDEX l_index.
    IF sy-subrc IS INITIAL AND l_string = lcl_commands=&gt;as.
      ADD 3 TO l_index. &quot;Jump ON command
    ELSE.
      ADD 2 TO l_index.
    ENDIF.

    WHILE l_out = abap_false.
      READ TABLE i_query INTO l_string INDEX l_index.
      IF ( sy-subrc IS INITIAL AND
         ( l_string = lcl_commands=&gt;inner  OR
           l_string = lcl_commands=&gt;join   OR
           l_string = lcl_commands=&gt;left   OR
           l_string = lcl_commands=&gt;outer  OR
           l_string = lcl_commands=&gt;right  OR
           l_string = lcl_commands=&gt;order  OR
           l_string = lcl_commands=&gt;having OR
           l_string = lcl_commands=&gt;group  OR
           l_string = lcl_commands=&gt;up ) ) OR
           NOT sy-subrc IS INITIAL.
        l_out = abap_true.
        EXIT.
      ENDIF.

      CLEAR: l_split_1, l_split_2.

      IF l_string = lcl_commands=&gt;and.
        UNASSIGN &lt;fs_join_field&gt;.
      ELSE.

        IF NOT &lt;fs_join_field&gt; IS ASSIGNED.
          APPEND INITIAL LINE TO t_join_fields ASSIGNING &lt;fs_join_field&gt;.
        ENDIF.

        IF l_string = lcl_commands=&gt;equal OR
               l_string = lcl_commands=&gt;eq    OR
               l_string = lcl_commands=&gt;lt    OR
               l_string = lcl_commands=&gt;le    OR
               l_string = lcl_commands=&gt;gt    OR
               l_string = lcl_commands=&gt;ge.
          &lt;fs_join_field&gt;-signal = l_string.
        ELSE.
          SPLIT l_string AT &apos;~&apos; INTO l_split_1 l_split_2.
          IF NOT l_split_2 IS INITIAL.
            IF i_table-&gt;get_name( ) = l_split_1 OR i_table-&gt;get_alias( ) = l_split_1.
              &lt;fs_join_field&gt;-fortable = i_table-&gt;get_name( ).
              &lt;fs_join_field&gt;-forkey   = l_split_2.
            ELSE.
              o_aux = me-&gt;get_table( i_table = l_split_1 ).
              IF o_aux IS BOUND.
                &lt;fs_join_field&gt;-checktable = o_aux-&gt;get_name( ).
                &lt;fs_join_field&gt;-checkfield = l_split_2.
              ELSE.
                &lt;fs_join_field&gt;-checkfield = l_split_1.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      ADD 1 TO l_index.

    ENDWHILE.

    i_table-&gt;set_join_fields( t_join_fields ).

  ENDMETHOD.                    &quot;check_join_fields

ENDCLASS. &quot;lcl_from

*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_commands
*&amp;---------------------------------------------------------------------*
CLASS lcl_commands IMPLEMENTATION .

  METHOD class_constructor.
    initialize_command_list( ).
    initialize_identify_commands( ).
  ENDMETHOD. &quot;class_constructor

  METHOD initialize_command_list.
    APPEND select TO t_commands.
    APPEND from   TO t_commands.
    APPEND join   TO t_commands.
    APPEND inner  TO t_commands.
    APPEND outer  TO t_commands.
    APPEND left   TO t_commands.
    APPEND right  TO t_commands.
    APPEND where  TO t_commands.
    APPEND having TO t_commands.
    APPEND group  TO t_commands.
    APPEND order  TO t_commands.
  ENDMETHOD. &quot;initialize_command_list

  METHOD initialize_identify_commands.
    APPEND select TO t_identify_commands.
    APPEND from   TO t_identify_commands.
*    APPEND where  TO t_identify_commands.
*    APPEND up     TO t_identify_commands.
*    APPEND having TO t_identify_commands.
*    APPEND group  TO t_identify_commands.
*    APPEND order  TO t_identify_commands.
  ENDMETHOD. &quot;initialize_identify_commands

  METHOD get_command_list.
    return = t_commands.
  ENDMETHOD. &quot;get_command_list

  METHOD get_identify_commands_list.
    return = t_identify_commands.
  ENDMETHOD. &quot;get_identify_commands_list

ENDCLASS. &quot;lcl_commands
*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_query_element_factory
*&amp;---------------------------------------------------------------------*
* Text
*----------------------------------------------------------------------*
CLASS lcl_query_element_factory IMPLEMENTATION .
  METHOD factory_query_element.
    CASE i_element.
      WHEN lcl_commands=&gt;select . &quot;SELECT
        CREATE OBJECT return TYPE lcl_select.

      WHEN lcl_commands=&gt;from . &quot;FROM
        CREATE OBJECT return TYPE lcl_from.

      WHEN lcl_commands=&gt;where . &quot;WHERE
        CREATE OBJECT return TYPE lcl_where.

    ENDCASE.
    return-&gt;v_element = i_element.
  ENDMETHOD. &quot;factory_query_element
ENDCLASS. &quot;lcl_query_element_factory

*----------------------------------------------------------------------*
*       CLASS lcl_screen_factory IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_factory IMPLEMENTATION.
  METHOD factory_screen.
    CASE i_screen.
      WHEN 100.
        CREATE OBJECT return
          TYPE
            lcl_screen_100
          EXPORTING
            i_screen       = i_screen.

      WHEN 200.
        CREATE OBJECT return
          TYPE
            lcl_screen_200
          EXPORTING
            i_screen       = i_screen.

      WHEN 300.
        CREATE OBJECT return
          TYPE
            lcl_screen_300
          EXPORTING
            i_screen       = i_screen.

      WHEN 400.
        CREATE OBJECT return
          TYPE
            lcl_screen_400
          EXPORTING
            i_screen       = i_screen.

      WHEN 500.
        CREATE OBJECT return
          TYPE
            lcl_screen_500
          EXPORTING
            i_screen       = i_screen.

      WHEN 600.
        CREATE OBJECT return
          TYPE
            lcl_screen_600
          EXPORTING
            i_screen       = i_screen.

      WHEN 700.
        CREATE OBJECT return
          TYPE
            lcl_screen_700
          EXPORTING
            i_screen       = i_screen.

    ENDCASE.

    IF return IS BOUND.
      APPEND return TO t_screens.
    ENDIF.

  ENDMETHOD.                    &quot;factory_screen

  METHOD get_screen.
    READ TABLE t_screens INTO return WITH KEY table_line-&gt;lif_screen~v_screen = i_screen.
  ENDMETHOD.                    &quot;get_screen
ENDCLASS.                    &quot;lcl_screen_factory IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp; Class (Implementation) lcl_query_agent
*&amp;---------------------------------------------------------------------*
* Text
*----------------------------------------------------------------------*
CLASS lcl_query_agent IMPLEMENTATION .

  &quot;$. Region Getters and Setters
  METHOD set_fieldcat.
    me-&gt;t_fieldcat = i_fieldcat.
  ENDMETHOD.                    &quot;set_fieldcat
  METHOD get_fieldcat.
    return = me-&gt;t_fieldcat.
  ENDMETHOD.                    &quot;get_fieldcat

  METHOD set_no_conversion.
    me-&gt;v_no_conversion = i_no_conversion.
  ENDMETHOD.                    &quot;set_no_conversion
  METHOD get_no_conversion.
    return = me-&gt;v_no_conversion.
  ENDMETHOD.                    &quot;get_no_conversion
  &quot;$. Endregion Getters and Setters

  METHOD get_alv.
    return = me-&gt;o_alv.
  ENDMETHOD. &quot;get_alv

  METHOD initialize_alv.
    IF me-&gt;o_alv IS BOUND.
      me-&gt;o_alv-&gt;free( ).
      CLEAR: me-&gt;o_alv, me-&gt;o_event_handler.
    ENDIF.

    CREATE OBJECT me-&gt;o_alv
      EXPORTING
        i_parent = i_container.

    CREATE OBJECT me-&gt;o_event_handler
      EXPORTING
        i_query_agent = me.

    SET HANDLER: me-&gt;o_event_handler-&gt;handle_toolbar FOR me-&gt;o_alv,
                 me-&gt;o_event_handler-&gt;handle_user_command FOR me-&gt;o_alv,
                 me-&gt;o_event_handler-&gt;handle_menu_button FOR me-&gt;o_alv.

  ENDMETHOD. &quot;initialize_alv

*  METHOD initialize_splitter.
*    CREATE OBJECT me-&gt;o_splitter
*      EXPORTING
*        parent  = i_container
*        rows    = i_rows
*        columns = i_cols.
*  ENDMETHOD. &quot;initialize_splitter

  METHOD get_query_agent.
    IF o_query_agent IS INITIAL.
      CREATE OBJECT o_query_agent.
    ENDIF.
    return = o_query_agent.
  ENDMETHOD. &quot;get_query_agent

  METHOD execute_query.

    DATA: o_data TYPE REF TO data,
          o_query_saver TYPE REF TO lcl_query_save.

    CREATE OBJECT me-&gt;o_analyzer.

    me-&gt;o_analyzer-&gt;start_runtime_analyzer( lcl_performance_analyzer=&gt;abap ).

    &quot;$. Region Check Query Syntax
    me-&gt;check_query_syntax( i_query ).
    &quot;$. Endregion Check Query Syntax

    &quot;$. Region Identify Query Elements
    me-&gt;o_query-&gt;identify_query_elements( ).
    &quot;$. Endregion Identify Query Elements

    &quot;$. Region Create Fieldcatalog
    me-&gt;create_fcat( ).
    &quot;$. Endregion Create Fieldcatalog

    &quot;$. Region Build Dynamic Structure
    o_data = me-&gt;build_dyn_struct( me-&gt;t_fieldcat ).
    me-&gt;o_query-&gt;set_data( o_data ).
    &quot;$. Endregion Build Dynamic Structure

    &quot;$. Region Check fields to Select
    me-&gt;check_fields_to_select( ).
    &quot;$. Endregion Check fields to Select

    me-&gt;o_analyzer-&gt;stop_runtime_analyzer( lcl_performance_analyzer=&gt;abap ).

    &quot;$. Region Select Data
    me-&gt;o_analyzer-&gt;start_runtime_analyzer( lcl_performance_analyzer=&gt;sql ).
    me-&gt;o_query-&gt;execute( ).
    me-&gt;o_analyzer-&gt;stop_runtime_analyzer( lcl_performance_analyzer=&gt;sql ).
    &quot;$. Endregion Select Data

  ENDMETHOD. &quot;execute_query

  METHOD check_fields_to_select.
    DATA: o_fieldcat   TYPE REF TO lcl_fieldcat,
          o_select_gen TYPE REF TO lcl_select_generator,
          o_from       TYPE REF TO lcl_from,
          o_select     TYPE REF TO lcl_select,
          o_data       TYPE REF TO data,

          t_query      TYPE salv_wd_t_string,
          t_select     TYPE salv_wd_t_string,

          l_select_type TYPE string,
          l_query      TYPE string.

    CREATE OBJECT o_fieldcat
      EXPORTING
        i_fieldcat = me-&gt;t_fieldcat.

    IF o_fieldcat-&gt;get_fieldcat_count_fields( ) &gt; lcl_select=&gt;c_max_fields.
      o_from   ?= me-&gt;o_query-&gt;get_query_element( lcl_commands=&gt;from ).
      o_select ?= me-&gt;o_query-&gt;get_query_element( lcl_commands=&gt;select ).

      CREATE OBJECT o_select_gen
        EXPORTING
          i_element = o_from.

      l_query  = me-&gt;o_query-&gt;get_query_string( ).
      l_select_type = o_select-&gt;get_select_type( ).

      t_select = o_select_gen-&gt;generate_by_fieldcat( o_fieldcat ).
      IF NOT l_select_type = lcl_commands=&gt;asterisk.
        o_select_gen-&gt;set_select_type( l_select_type ).
      ENDIF.

      t_query  = o_select_gen-&gt;generate_new_query_text( i_query_string = l_query
                                                        i_command_text = t_select ).

      o_data = me-&gt;o_query-&gt;get_data( ).

      CLEAR me-&gt;o_query.
      CREATE OBJECT me-&gt;o_query
        EXPORTING
          i_query = t_query.
      me-&gt;o_query-&gt;identify_query_elements( ).
      me-&gt;o_query-&gt;set_data( o_data ).

    ENDIF.

  ENDMETHOD.                    &quot;check_fields_to_select

  METHOD check_query_syntax.
    CREATE OBJECT me-&gt;o_query
      EXPORTING
        i_query = i_query.
    me-&gt;o_query-&gt;check_query_syntax( ).
  ENDMETHOD. &quot;check_query_syntax

  METHOD build_dyn_struct.

    TYPES: BEGIN OF yt_fields,
           field TYPE string,
           rand  TYPE salv_wd_t_string,
         END OF yt_fields.

    DATA: o_struct     TYPE REF TO cl_abap_structdescr,
          o_table      TYPE REF TO cl_abap_tabledescr,

          t_fields     TYPE TABLE OF yt_fields,
          t_components TYPE abap_component_tab,
          t_fieldcat   TYPE lvc_t_fcat,

          l_field      TYPE string,
          l_name       TYPE string,
          l_rand       TYPE string,
          l_out        TYPE boolean.

    FIELD-SYMBOLS: &lt;fs_field&gt;     TYPE yt_fields,
                   &lt;fs_fcat&gt;      TYPE lvc_s_fcat,
                   &lt;fs_component&gt; TYPE abap_componentdescr.

    t_fieldcat = i_fieldcat.

    LOOP AT t_fieldcat ASSIGNING &lt;fs_fcat&gt;.
      CLEAR: l_field, l_name, l_rand, l_out.

      READ TABLE t_fields ASSIGNING &lt;fs_field&gt; WITH KEY field = &lt;fs_fcat&gt;-fieldname.
      IF sy-subrc IS INITIAL.

        WHILE l_out = abap_false.

          CALL FUNCTION &apos;GENERAL_GET_RANDOM_STRING&apos;
            EXPORTING
              number_chars  = 2
            IMPORTING
              random_string = l_rand.

          TRANSLATE l_rand TO UPPER CASE.

          READ TABLE &lt;fs_field&gt;-rand WITH KEY table_line = l_rand TRANSPORTING NO FIELDS.
          IF NOT sy-subrc IS INITIAL.
            APPEND l_rand TO &lt;fs_field&gt;-rand.
            l_out = abap_true.
          ENDIF.

        ENDWHILE.

        CONCATENATE &lt;fs_fcat&gt;-fieldname l_rand INTO l_field SEPARATED BY &apos;_&apos;.

      ELSE.

        APPEND INITIAL LINE TO t_fields ASSIGNING &lt;fs_field&gt;.
        &lt;fs_field&gt;-field = l_field = &lt;fs_fcat&gt;-fieldname.
        UNASSIGN &lt;fs_field&gt;.

      ENDIF.

      APPEND INITIAL LINE TO t_components ASSIGNING &lt;fs_component&gt;.
      &lt;fs_component&gt;-name = l_field.

      IF NOT &lt;fs_fcat&gt;-ref_table IS INITIAL.
        CONCATENATE &lt;fs_fcat&gt;-ref_table &lt;fs_fcat&gt;-fieldname INTO l_name SEPARATED BY &apos;-&apos;.
        &lt;fs_component&gt;-type ?= cl_abap_structdescr=&gt;describe_by_name( l_name ).
      ELSE.
        &lt;fs_component&gt;-type ?= cl_abap_typedescr=&gt;describe_by_name( &lt;fs_fcat&gt;-inttype ).
      ENDIF.
      UNASSIGN &lt;fs_component&gt;.

      &lt;fs_fcat&gt;-ref_field = &lt;fs_fcat&gt;-fieldname.
      &lt;fs_fcat&gt;-fieldname = l_field.

    ENDLOOP.

    o_struct = cl_abap_structdescr=&gt;create( t_components ).
    o_table  = cl_abap_tabledescr=&gt;create( o_struct ).

    CREATE DATA return TYPE HANDLE o_table.

    me-&gt;set_fieldcat( t_fieldcat ).

  ENDMETHOD.                    &quot;build_dyn_struct

  METHOD create_fcat.
    DATA: o_select      TYPE REF TO lcl_select,
          o_from        TYPE REF TO lcl_from,
          o_table       TYPE REF TO lcl_table,
          o_fieldcat    TYPE REF TO lcl_fieldcat,
          t_fcat        TYPE lvc_t_fcat,
          t_fcat_aux    TYPE lvc_t_fcat,
          l_select_type TYPE string.

    CREATE OBJECT o_fieldcat.
    o_select ?= me-&gt;o_query-&gt;get_query_element( lcl_commands=&gt;select ).
    o_from   ?= me-&gt;o_query-&gt;get_query_element( lcl_commands=&gt;from ).

    DO.
      TRY.
          o_table    = o_from-&gt;get_table( sy-index ).
          t_fcat_aux = o_fieldcat-&gt;merge_fieldcat( i_table         = o_table
                                                   i_no_conversion = me-&gt;v_no_conversion ).
          APPEND LINES OF t_fcat_aux TO t_fcat.
        CATCH lcx_table_not_found.
          EXIT.
        CATCH lcx_no_fieldcat.
      ENDTRY.
    ENDDO.

    o_fieldcat-&gt;set_fieldcat( t_fcat ).
    o_fieldcat-&gt;compute_fieldcat_to_fields( i_select = o_select
                                            i_from   = o_from ).

    return = o_fieldcat-&gt;get_fieldcat( ).
    me-&gt;set_fieldcat( return ).

  ENDMETHOD.                    &quot;create_fcat

  METHOD get_query_results.
    return = me-&gt;o_query-&gt;get_data( ).
  ENDMETHOD.                    &quot;get_query_results

  METHOD show_results.

    DATA: o_data TYPE REF TO data,
          wa_layout TYPE lvc_s_layo.

    FIELD-SYMBOLS &lt;fs_tab&gt; TYPE ANY TABLE.

    o_data = me-&gt;get_query_results( ).
    ASSIGN o_data-&gt;* TO &lt;fs_tab&gt;.

    me-&gt;initialize_alv( i_container ).

    wa_layout = me-&gt;get_layout( ).

    me-&gt;o_alv-&gt;set_table_for_first_display(
      EXPORTING
        is_layout       = wa_layout
      CHANGING
        it_fieldcatalog = me-&gt;t_fieldcat
        it_outtab       = &lt;fs_tab&gt; ).

  ENDMETHOD.                    &quot;show_results

  METHOD generate_types.
    DATA: o_type_gen TYPE REF TO lcl_type_generator,
          o_select   TYPE REF TO lcl_select,
          l_select_type TYPE string.

    DATA: t_fcat TYPE lvc_t_fcat,
          l_type_name TYPE string.

    o_select ?= me-&gt;o_query-&gt;get_query_element( lcl_commands=&gt;select ).

    l_type_name = lcl_type_generator=&gt;get_type_name_by_user( ).

    CREATE OBJECT o_type_gen
      EXPORTING
        i_type_name = l_type_name.

    t_fcat = me-&gt;get_fieldcat( ).
    o_type_gen-&gt;generate_type_by_fcat( i_fieldcat   = t_fcat ).

    CHECK o_type_gen IS BOUND.

    DATA: o_screen_200 TYPE REF TO lcl_screen_200.
    o_screen_200 ?= lcl_screen=&gt;get_instance( 200 ).

    o_screen_200-&gt;set_type_gen_instance( o_type_gen ).
    o_screen_200-&gt;lif_screen~show( i_first_col = 10
                                   i_first_row = 2
                                   i_last_col  = 110
                                   i_last_row  = 23 ).

  ENDMETHOD.                    &quot;generate_types

  METHOD show_performance_analyzer.

    DATA: o_screen TYPE REF TO lcl_screen_300.

    o_screen ?= lcl_screen=&gt;get_instance( 300 ).
    o_screen-&gt;set_analyzer( me-&gt;o_analyzer ).
    o_screen-&gt;lif_screen~show( i_first_col = 5
                               i_first_row = 2
                               i_last_col  = 138
                               i_last_row  = 33 ).

  ENDMETHOD.                    &quot;show_performance_analyzer

  METHOD get_layout.
    DATA: o_data TYPE REF TO data,
          wa_layout TYPE lvc_s_layo,
          l_time    TYPE dec_16_02_s,
          l_time_s  TYPE char50,
          l_lines   TYPE char100.

    FIELD-SYMBOLS &lt;fs_tab&gt; TYPE ANY TABLE.

    wa_layout-zebra = abap_true.
    wa_layout-sel_mode = &apos;D&apos;.

    o_data = me-&gt;get_query_results( ).
    ASSIGN o_data-&gt;* TO &lt;fs_tab&gt;.
    IF &lt;fs_tab&gt; IS ASSIGNED.
      &quot;Records
      DESCRIBE TABLE &lt;fs_tab&gt;.
      WRITE sy-tfill TO l_lines. CONDENSE l_lines NO-GAPS.
    ENDIF.

    &quot;Time
    l_time = me-&gt;o_analyzer-&gt;calculate_runtime( i_id = lcl_performance_analyzer=&gt;sql ).
    WRITE l_time TO l_time_s. CONDENSE l_time_s.

    CONCATENATE l_lines &apos;record(s) retrieved -&apos; l_time_s &apos;seconds elapsed&apos; INTO wa_layout-grid_title SEPARATED BY space.
    CONDENSE wa_layout-grid_title.

    return = wa_layout.
  ENDMETHOD.                    &quot;get_layout

  METHOD generate_where.
    DATA: o_from      TYPE REF TO lcl_query_element,
          o_generator TYPE REF TO lcl_query_element_generator,
          t_where     TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string.

    me-&gt;check_query_syntax( i_query ).
    o_from = me-&gt;o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).

    CREATE OBJECT o_generator
      TYPE
        lcl_where_generator
      EXPORTING
        i_element           = o_from.

    t_where = o_generator-&gt;generate( ).
    t_query = o_generator-&gt;generate_new_query_text( i_query        = i_query
                                                    i_command_text = t_where ).
    return = t_query.
*    me-&gt;o_editor-&gt;set_selected_text_as_table( t_query ).
  ENDMETHOD.                    &quot;generate_where

  METHOD generate_select.
    DATA: o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_select_generator,
          t_select    TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string.

    me-&gt;check_query_syntax( i_query ).
    o_from = me-&gt;o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).
    o_select ?= me-&gt;o_query-&gt;identify_query_elements( lcl_commands=&gt;select ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    o_gen-&gt;set_select( o_select ).

    t_select = o_gen-&gt;generate( ).
    t_query = o_gen-&gt;generate_new_query_text( i_query        = i_query
                                              i_command_text = t_select ).
    return = t_query.
*    me-&gt;o_editor-&gt;set_selected_text_as_table( t_query ).

  ENDMETHOD.                    &quot;generate_select

  METHOD inverse_fieldcat_names.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat,
          t_fcat     TYPE lvc_t_fcat.
    CREATE OBJECT o_fieldcat.
    t_fcat = o_fieldcat-&gt;inverse_fieldcat_names( me-&gt;o_alv ).
    me-&gt;set_fieldcat( t_fcat ).
  ENDMETHOD.                    &quot;inverse_fieldcat_names

  METHOD no_routine_conversion.
    DATA: o_fieldcat  TYPE REF TO lcl_fieldcat,
          o_container TYPE REF TO cl_gui_container,
          o_screen    TYPE REF TO lcl_screen_100,
          t_fcat      TYPE lvc_t_fcat.
    CREATE OBJECT o_fieldcat.
    t_fcat = o_fieldcat-&gt;no_routine_conversion( me-&gt;o_alv ).
    me-&gt;set_fieldcat( t_fcat ).
  ENDMETHOD.                    &quot;no_routine_conversion

  METHOD flush_alv.
    IF me-&gt;o_alv IS BOUND.
      me-&gt;o_alv-&gt;free( ).
      CLEAR me-&gt;o_alv.
    ENDIF.
  ENDMETHOD.                    &quot;flush_alv

ENDCLASS. &quot;lcl_query_agent

*----------------------------------------------------------------------*
* CLASS lcl_screen IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_screen.
    me-&gt;lif_screen~v_screen = i_screen.
  ENDMETHOD.                    &quot;set_screen
  METHOD get_screen.
    return = me-&gt;lif_screen~v_screen.
  ENDMETHOD.                    &quot;get_screen

  METHOD set_exit_command.
    me-&gt;v_exit_command = i_exit_command.
  ENDMETHOD.                    &quot;set_exit_command
  METHOD get_exit_command.
    return = me-&gt;v_exit_command.
  ENDMETHOD.                    &quot;get_exit_command
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_screen( i_screen ).
  ENDMETHOD.                    &quot;constructor

  METHOD lif_screen~exit_command.
    me-&gt;set_exit_command( abap_true ).
    LEAVE TO SCREEN 0.
  ENDMETHOD. &quot;lif_screen~exit_command

  METHOD lif_screen~screen_status.
  ENDMETHOD. &quot;lif_screen~screen_status

  METHOD lif_screen~user_command.
    CASE i_ucomm.
      WHEN c_back.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD. &quot;lif_screen~user_command

  METHOD lif_screen~initialize_screen.
  ENDMETHOD. &quot;lif_screen~initialize_screen

  METHOD lif_screen~show.
    me-&gt;set_exit_command( abap_false ).
    IF i_first_col IS INITIAL AND
       i_first_row IS INITIAL AND
       i_last_col  IS INITIAL AND
       i_last_row  IS INITIAL.
      CALL SCREEN me-&gt;lif_screen~v_screen.
    ELSE.
      CALL SCREEN me-&gt;lif_screen~v_screen STARTING AT i_first_col i_first_row
                                            ENDING AT i_last_col  i_last_row.
    ENDIF.
  ENDMETHOD.                    &quot;lif_screen~show

  METHOD get_instance.
    return = lcl_screen_factory=&gt;get_screen( i_screen ).
    IF NOT return IS BOUND.
      return = lcl_screen_factory=&gt;factory_screen( i_screen ).
    ENDIF.
  ENDMETHOD.                    &quot;get_instance

ENDCLASS. &quot;lcl_screen IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_screen_100 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_100 IMPLEMENTATION.

  METHOD get_texted_query.
    DATA: o_editor TYPE REF TO cl_gui_abapedit,
          t_text TYPE TABLE OF string .

    o_editor = get_editor( ).

    o_editor-&gt;get_selected_text_as_table( IMPORTING table = t_text ).
    IF t_text IS INITIAL AND i_blank = abap_true.
      RETURN.
    ELSEIF t_text IS INITIAL AND i_selected = abap_false.
      o_editor-&gt;select_lines( from_line = 1 to_line = 9999 ).
      o_editor-&gt;get_selected_text_as_table( IMPORTING table = t_text ).
    ENDIF.

    IF t_text IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_query.
    ENDIF.
    return = t_text.
  ENDMETHOD. &quot;get_texted_query

  METHOD set_texted_query.
    DATA: t_aux TYPE salv_wd_t_string.
    me-&gt;o_editor-&gt;set_text( t_aux ).
    me-&gt;o_editor-&gt;set_text( i_query ).
  ENDMETHOD.                    &quot;set_texted_query

  METHOD get_container_from_splitter.
    return = me-&gt;o_splitter-&gt;get_container( row    = i_row
                                            column = i_col ).
  ENDMETHOD. &quot;get_container_from_splitter

  METHOD get_container_from_result.
    return = me-&gt;o_result_splitter-&gt;get_container( row    = i_row
                                                   column = i_col ).
  ENDMETHOD.                    &quot;get_container_from_result

  METHOD get_editor.
    return = me-&gt;o_editor.
  ENDMETHOD. &quot;get_editor

  METHOD lif_screen~user_command.

    DATA: l_message TYPE string,
          o_exception TYPE REF TO cx_root.

    TRY.
        super-&gt;lif_screen~user_command( i_ucomm ).

        CASE i_ucomm.
          WHEN c_exec.
            me-&gt;execute_query( ).
            me-&gt;show_results( ).

          WHEN c_exec_no.
            me-&gt;execute_query( abap_true ).
            me-&gt;show_results( ).

          WHEN c_check.
            me-&gt;check_query_syntax( ).
            l_message = &apos;Query is syntactically correct.&apos;(001).
            lcl_message=&gt;report_message( i_msg  = l_message
                                         i_type = &apos;S&apos; ).

          WHEN c_save.
            me-&gt;save_query( ).
            l_message = &apos;Query saved successfully.&apos;(002).
            lcl_message=&gt;report_message( i_msg  = l_message
                                         i_type = &apos;S&apos; ).

          WHEN c_open.
            me-&gt;open_query( ).

          WHEN c_mine.
            me-&gt;open_my_queries( ).

          WHEN c_select.
            me-&gt;generate_select( ).

          WHEN c_from.
            me-&gt;generate_from( ).

          WHEN c_where.
            me-&gt;generate_where( ).

        ENDCASE.

      CATCH lcx_no_query.
        l_message = &apos;No query entry to execute&apos;(e01).
        lcl_message=&gt;report_message( i_msg     = l_message
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
      CATCH lcx_cancel.
        l_message = &apos;Canceled&apos;(e02).
        lcl_message=&gt;report_message( i_msg     = l_message
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
      CATCH lcx_fields_overflow.
        l_message = &apos;Allowed only 70 fields or less&apos;(e03).
        lcl_message=&gt;report_message( i_msg     = l_message
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
      CATCH lcx_table_not_found.
        l_message = &apos;No queries found&apos;(e04).
        lcl_message=&gt;report_message( i_msg = l_message i_type = &apos;S&apos; i_disp_as = &apos;E&apos; ).

      CATCH lcx_query_element_not_found INTO o_exception.
        DATA: o_element_not_found TYPE REF TO lcx_query_element_not_found.
        o_element_not_found ?= o_exception.
        l_message = o_element_not_found-&gt;get_message( ).
        lcl_message=&gt;report_message( i_msg  = l_message
                                     i_type = &apos;E&apos; ).

      CATCH lcx_query_overflow.
        l_message = &apos;Please, select up to 3 queries at most.&apos;.
        lcl_message=&gt;report_message( i_msg = l_message i_type = &apos;S&apos; i_disp_as = &apos;W&apos; ).

      CATCH lcx_error_query_check INTO o_exception.
        DATA: o_query_check TYPE REF TO lcx_error_query_check.
        o_query_check ?= o_exception.
        l_message = o_query_check-&gt;get_message( ).
        lcl_message=&gt;report_message( i_msg  = l_message
                                     i_type = &apos;E&apos; ).

      CATCH lcx_no_fields_selected. &quot;EC NO_HANDLE
    ENDTRY.

  ENDMETHOD. &quot;lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS &apos;PF_0100&apos;.
    SET TITLEBAR &apos;TITLE_0100&apos;.
  ENDMETHOD. &quot;lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me-&gt;o_cust_cont IS INITIAL.
      DATA o_container TYPE REF TO cl_gui_container.

      CREATE OBJECT me-&gt;o_cust_cont
        EXPORTING
          container_name = &apos;C_CONTAINER&apos;.

      me-&gt;initialize_splitter( i_container = me-&gt;o_cust_cont
                               i_rows      = 2
                               i_cols      = 1 ).

      o_container = me-&gt;get_container_from_splitter( i_row = 1
                                                     i_col = 1 ).
      me-&gt;initialize_editor( o_container ).
    ENDIF.
  ENDMETHOD. &quot;lif_screen~initialize_screen

  METHOD execute_query.
    DATA: o_query_agent  TYPE REF TO lcl_query_agent,
          o_query_saver  TYPE REF TO lcl_query_save,
          t_texted_query TYPE salv_wd_t_string,
          t_queries      TYPE yt_t_query.
    FIELD-SYMBOLS &lt;fs_query&gt; TYPE salv_wd_t_string.

    CLEAR me-&gt;t_query_agents.

    t_texted_query = me-&gt;get_texted_query( ).

    me-&gt;split_queries( EXPORTING i_text    = t_texted_query
                       IMPORTING e_queries = t_queries ).

    LOOP AT t_queries ASSIGNING &lt;fs_query&gt;.
      CREATE OBJECT o_query_agent.
      o_query_agent-&gt;set_no_conversion( i_no_conversion ).
      o_query_agent-&gt;execute_query( &lt;fs_query&gt; ).
      me-&gt;add_query_agent( o_query_agent ).
    ENDLOOP.

    &quot;$. Region Buffer Texted Query
    o_query_saver = lcl_query_save=&gt;get_instance( ).
    o_query_saver-&gt;buffer_query_texted( t_texted_query ).
    &quot;$. Endregion Buffer Texted Query

  ENDMETHOD. &quot;execute_query

  METHOD split_queries.
    DATA: t_text    TYPE salv_wd_t_string,
          t_aux     TYPE salv_wd_t_string,
          t_queries TYPE yt_t_query,
          t_query   TYPE salv_wd_t_string,
          l_query   TYPE string,
          l_length  TYPE i.

    FIELD-SYMBOLS &lt;fs_text&gt; TYPE string.

    t_aux = i_text.
    lcl_report=&gt;delete_comments( CHANGING i_text = t_aux ).

    LOOP AT t_aux ASSIGNING &lt;fs_text&gt;.
      SPLIT &lt;fs_text&gt; AT space INTO TABLE t_query.
      APPEND LINES OF t_query TO t_text.
    ENDLOOP.

    CLEAR: t_query.

    DELETE t_text WHERE table_line IS INITIAL.

    LOOP AT t_text ASSIGNING &lt;fs_text&gt;.
      l_length = STRLEN( &lt;fs_text&gt; ).
      SUBTRACT 1 FROM l_length.
      CONCATENATE l_query &lt;fs_text&gt; INTO l_query SEPARATED BY space.
      IF &lt;fs_text&gt;+l_length(1) = &apos;.&apos;.
        CONDENSE l_query.
        t_query = lcl_query=&gt;split_text( i_text      = l_query
                                         i_outputlen = 100 ).
        APPEND t_query TO e_queries.
        AT LAST.
          EXIT.
        ENDAT.
        CLEAR l_query.
      ENDIF.

      AT LAST.
        CONDENSE l_query.
        t_query = lcl_query=&gt;split_text( i_text      = l_query
                                         i_outputlen = 100 ).
        APPEND t_query TO e_queries.
        EXIT.
      ENDAT.

    ENDLOOP.

    IF LINES( e_queries ) &gt; 3.
      RAISE EXCEPTION TYPE lcx_query_overflow.
    ENDIF.

  ENDMETHOD.                    &quot;split_queries

  METHOD check_query_syntax.
    DATA: o_query_agent  TYPE REF TO lcl_query_agent,
          t_texted_query TYPE salv_wd_t_string,
          t_queries      TYPE yt_t_query.

    t_texted_query = me-&gt;get_texted_query( ).

    me-&gt;split_queries( EXPORTING i_text = t_texted_query
                       IMPORTING e_queries = t_queries ).

    LOOP AT t_queries INTO t_texted_query.
      CREATE OBJECT o_query_agent.
      o_query_agent-&gt;check_query_syntax( t_texted_query ).
    ENDLOOP.

  ENDMETHOD. &quot;check_query_syntax

  METHOD show_results.
    DATA: o_container TYPE REF TO cl_gui_container,
          o_alv_cont  TYPE REF TO cl_gui_container,
          l_lines     TYPE i.
    FIELD-SYMBOLS &lt;fs_query_agent&gt; TYPE REF TO lcl_query_agent.

    IF o_result_splitter IS BOUND.
      o_result_splitter-&gt;free( ).
      CLEAR o_result_splitter.
    ENDIF.

    l_lines = me-&gt;get_query_agents_lines( ).

    CHECK l_lines &gt; 0.

    o_container = me-&gt;get_container_from_splitter( i_row = 2
                                                   i_col = 1 ).

    CREATE OBJECT me-&gt;o_result_splitter
      EXPORTING
        parent  = o_container
        rows    = l_lines
        columns = 1.

    LOOP AT me-&gt;t_query_agents ASSIGNING &lt;fs_query_agent&gt;.
      o_alv_cont = me-&gt;o_result_splitter-&gt;get_container( row    = sy-tabix
                                                         column = 1 ).
      &lt;fs_query_agent&gt;-&gt;show_results( o_alv_cont ).
    ENDLOOP.

  ENDMETHOD.                    &quot;show_results

  METHOD save_query.
    DATA: o_save  TYPE REF TO lcl_query_save,
          l_name  TYPE string,
          t_query TYPE salv_wd_t_string.

    o_save = lcl_query_save=&gt;get_instance( ).
    l_name = o_save-&gt;get_query_name( ).
    t_query = me-&gt;get_texted_query( ).
    o_save-&gt;save_query( i_name  = l_name
                        i_query = t_query ).
  ENDMETHOD.                    &quot;save_query

  METHOD open_query.
    DATA: o_selection_screen TYPE REF TO lcl_selection_screen.
    CLEAR: p_qname, s_user.

    o_selection_screen ?= lcl_screen=&gt;get_instance( 400 ).
    o_selection_screen-&gt;lif_screen~show( i_first_col = 10
                                         i_first_row = 3 ).


  ENDMETHOD.                    &quot;open_query

  METHOD open_my_queries.
    DATA: o_save    TYPE REF TO lcl_query_save,
          o_agent   TYPE REF TO lcl_query_agent,
          o_400     TYPE REF TO lcl_screen_400,
          t_user    TYPE tyt_user_range,
          l_query_name TYPE string,

          t_queries TYPE tyt_query,
          t_aux     TYPE tyt_query,
          t_texted_query TYPE salv_wd_t_string.

    o_save  = lcl_query_save=&gt;get_instance( ).
    o_agent = lcl_query_agent=&gt;get_query_agent( ).
    o_400  ?= lcl_screen=&gt;get_instance( 400 ).

    o_400-&gt;compute_user_range( EXPORTING i_user = sy-uname
                               IMPORTING e_user_range = t_user ).
    l_query_name = o_400-&gt;compute_query_name( ).

    o_save-&gt;search_queries( EXPORTING
                              i_user       = t_user
                              i_query_name = l_query_name
                            IMPORTING
                              e_queries    = t_queries ).
    o_save-&gt;set_selected_query( t_queries ).

    o_save-&gt;display_queries( EXPORTING
                               i_queries = t_queries
                               i_mine    = abap_true
                             IMPORTING
                               e_selected = t_aux ).

    t_texted_query = o_save-&gt;compute_selected_queries( t_aux ).
    me-&gt;set_texted_query( t_texted_query ).

  ENDMETHOD.                    &quot;open_my_queries

  METHOD generate_where.
    DATA: o_from         TYPE REF TO lcl_query_element,
          o_generator    TYPE REF TO lcl_query_element_generator,
          o_query        TYPE REF TO lcl_query,
          t_texted_query TYPE salv_wd_t_string,
          t_where        TYPE salv_wd_t_string,
          t_query        TYPE salv_wd_t_string.

    t_texted_query = me-&gt;get_texted_query( abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.

    o_from = o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).

    CREATE OBJECT o_generator
      TYPE
        lcl_where_generator
      EXPORTING
        i_element           = o_from.

    t_where = o_generator-&gt;generate( ).
    t_query = o_generator-&gt;generate_new_query_text( i_query        = t_texted_query
                                                    i_command_text = t_where ).
    me-&gt;o_editor-&gt;set_selected_text_as_table( t_query ).

  ENDMETHOD.                    &quot;generate_where

  METHOD generate_select.
    DATA: t_texted_query TYPE salv_wd_t_string,
          o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_select_generator,
          o_query     TYPE REF TO lcl_query,
          t_select    TYPE salv_wd_t_string,
          l_select_type TYPE string,
          t_query     TYPE salv_wd_t_string.

    t_texted_query = me-&gt;get_texted_query( abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.

    o_query-&gt;check_query_syntax( ).
    o_from    = o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).
    o_select ?= o_query-&gt;identify_query_elements( lcl_commands=&gt;select ).
    l_select_type = o_select-&gt;get_select_type( ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    o_gen-&gt;set_select( o_select ).
    IF l_select_type &lt;&gt; lcl_commands=&gt;asterisk.
      o_gen-&gt;set_select_type( l_select_type ).
    ENDIF.

    t_select = o_gen-&gt;generate( ).
    t_query = o_gen-&gt;generate_new_query_text( i_query        = t_texted_query
                                              i_command_text = t_select ).
    me-&gt;o_editor-&gt;set_selected_text_as_table( t_query ).

  ENDMETHOD.                    &quot;generate_select

  METHOD generate_from.
    DATA: t_texted_query TYPE salv_wd_t_string,
          o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_from_generator,
          o_query     TYPE REF TO lcl_query,
          t_from      TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string,
          l_from_line	TYPE i,
          l_from_pos  TYPE i.


    t_texted_query = me-&gt;get_texted_query( i_blank = abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.
    IF NOT t_texted_query IS INITIAL.
      o_query-&gt;check_query_syntax( ).
    ENDIF.

    o_from = o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    t_from  = o_gen-&gt;generate( ).
    t_query = o_gen-&gt;generate_new_query_text( i_query        = t_texted_query
                                              i_command_text = t_from ).
    IF t_texted_query IS INITIAL.
      me-&gt;o_editor-&gt;get_selection_pos( IMPORTING from_line = l_from_line
                                                 from_pos  = l_from_pos ).

      me-&gt;o_editor-&gt;insert_block_at_position( line     = l_from_line
                                              pos      = l_from_pos
                                              text_tab = t_query ).
    ELSE.
      me-&gt;o_editor-&gt;set_selected_text_as_table( t_query ).
    ENDIF.

  ENDMETHOD.                    &quot;generate_from

  METHOD initialize_splitter.
    CREATE OBJECT me-&gt;o_splitter
      EXPORTING
        parent  = i_container
        rows    = i_rows
        columns = i_cols.
  ENDMETHOD. &quot;initialize_splitter

  METHOD initialize_editor.

    DATA: o_query_saver TYPE REF TO lcl_query_save,
          t_query TYPE salv_wd_t_string.

    CLEAR me-&gt;o_editor.

    CREATE OBJECT o_editor
      EXPORTING
        parent = i_container.

    TRY.
        o_query_saver = lcl_query_save=&gt;get_instance( ).
        t_query = o_query_saver-&gt;get_buffered_query( ).
      CATCH: lcx_existent_object, cx_root.               &quot;#EC NO_HANDLE
    ENDTRY.

    me-&gt;o_editor-&gt;set_text( t_query ).
    me-&gt;o_editor-&gt;set_source_type( &apos;ABAP&apos; ).
    me-&gt;o_editor-&gt;set_focus( i_container ).

  ENDMETHOD. &quot;initialize_editor

  METHOD add_query_agent.
    APPEND i_query_agent TO me-&gt;t_query_agents.
  ENDMETHOD.                    &quot;add_query_agent

  METHOD get_query_agents_lines.
    return = LINES( me-&gt;t_query_agents ).
  ENDMETHOD.                    &quot;get_query_agents_lines

  METHOD flush.
    IF me-&gt;o_result_splitter IS BOUND.
      me-&gt;o_result_splitter-&gt;free( ).
    ENDIF.
    CLEAR: me-&gt;t_query_agents, me-&gt;o_result_splitter.
  ENDMETHOD.                    &quot;flush

ENDCLASS. &quot;lcl_screen_100 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_200 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_200 IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_type_gen_instance.
    me-&gt;o_type_generator = i_type_gen.
  ENDMETHOD.                    &quot;set_type_gen_instance
  METHOD get_type_gen_instance.
    return = me-&gt;o_type_generator.
  ENDMETHOD.                    &quot;get_type_gen_instance

  METHOD set_editor.
    me-&gt;o_editor = i_editor.
  ENDMETHOD.                    &quot;set_editor
  METHOD get_editor.
    return = me-&gt;o_editor.
  ENDMETHOD.                    &quot;get_editor
  &quot;$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    CASE sy-ucomm.
      WHEN c_enter.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD.                    &quot;lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS &apos;PF_0200&apos;.
  ENDMETHOD.                    &quot;lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me-&gt;o_cust_cont IS INITIAL.
      CREATE OBJECT me-&gt;o_cust_cont
        EXPORTING
          container_name = &apos;C_TYPE_CONTAINER&apos;.
      CREATE OBJECT me-&gt;o_editor
        EXPORTING
          parent = me-&gt;o_cust_cont.
    ENDIF.

    DATA t_type TYPE salv_wd_t_string.
    t_type = me-&gt;o_type_generator-&gt;get_command_line( ).
    me-&gt;o_editor-&gt;set_selected_text_as_table( t_type ).
    me-&gt;o_editor-&gt;set_first_visible_line( ).
    me-&gt;o_editor-&gt;set_focus( me-&gt;o_cust_cont ).

    DESCRIBE TABLE t_type.
    me-&gt;o_editor-&gt;select_lines( from_line = 1 to_line = sy-tfill ).

  ENDMETHOD.                    &quot;lif_screen~initialize_screen

ENDCLASS.                    &quot;lcl_screen_200 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_300 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_300 IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_analyzer.
    me-&gt;o_analyzer = i_analyzer.
  ENDMETHOD.                    &quot;set_analyzer
  METHOD get_analyzer.
    return = me-&gt;o_analyzer.
  ENDMETHOD.                    &quot;get_analyzer
  &quot;$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    CASE sy-ucomm.
      WHEN c_enter.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD.                    &quot;lif_screen~user_command

  METHOD lif_screen~screen_status.
*    SET PF-STATUS &apos;PF_0300&apos;.
  ENDMETHOD.                    &quot;lif_screen~screen_status

  METHOD lif_screen~initialize_screen.

    CLEAR: me-&gt;t_texts, me-&gt;t_values.

    me-&gt;generate_graphic_data( me-&gt;o_analyzer ).
    me-&gt;display_graphic( ).

  ENDMETHOD.                    &quot;lif_screen~initialize_screen

  METHOD add_text.
    APPEND i_text TO me-&gt;t_texts.
  ENDMETHOD.                    &quot;add_text

  METHOD add_value.

    DATA: l_field TYPE string,
          l_id    TYPE string.

    FIELD-SYMBOLS: &lt;fs_value&gt; TYPE gprval,
                   &lt;fs_aux&gt;   TYPE ANY.

    APPEND INITIAL LINE TO me-&gt;t_values ASSIGNING &lt;fs_value&gt;.
    &lt;fs_value&gt;-rowtxt = i_rowtxt.

    l_id = i_id.
    CONCATENATE &apos;VAL&apos; l_id INTO l_field. CONDENSE l_field NO-GAPS.
    ASSIGN COMPONENT l_field OF STRUCTURE &lt;fs_value&gt; TO &lt;fs_aux&gt;.
    IF sy-subrc IS INITIAL.
      &lt;fs_aux&gt; = i_val.
    ENDIF.

    UNASSIGN &lt;fs_value&gt;.

  ENDMETHOD.                    &quot;add_value

  METHOD display_graphic.

    CALL FUNCTION &apos;GFW_PRES_SHOW&apos;
      EXPORTING
        container         = &apos;GRAPH_CONTAINER&apos;
        presentation_type = gfw_prestype_vertical_bars
        header            = &apos;Performance Analyzer&apos;(003)
      TABLES
        values            = me-&gt;t_values
        column_texts      = me-&gt;t_texts
      EXCEPTIONS
        error_occurred    = 1
        OTHERS            = 2.

  ENDMETHOD.                    &quot;display_graphic

  METHOD generate_graphic_data.

    DATA: t_analyzer TYPE tyt_analyzer,

          l_description TYPE string,
          l_rowtxt      TYPE char100,
          l_runtime     TYPE dec_16_02_s.

    FIELD-SYMBOLS &lt;fs_analyzer&gt; TYPE yt_analyzer.

    i_analyzer-&gt;get_analyzer_table( IMPORTING t_analyzer = t_analyzer ).

    LOOP AT t_analyzer ASSIGNING &lt;fs_analyzer&gt;.

      l_runtime = i_analyzer-&gt;calculate_runtime( i_start = &lt;fs_analyzer&gt;-start_runtime
                                                 i_end   = &lt;fs_analyzer&gt;-end_runtime ).
      WRITE l_runtime TO l_rowtxt.
      l_description = l_rowtxt. CONDENSE l_description.
      CONCATENATE l_description &apos;seconds&apos; INTO l_description SEPARATED BY space.
      me-&gt;add_text( l_description ).

      l_description = lcl_performance_analyzer=&gt;get_analyzer_description( &lt;fs_analyzer&gt;-analyzer_id ).
      me-&gt;add_value( i_rowtxt = l_description
                     i_val    = l_runtime
                     i_id     = &lt;fs_analyzer&gt;-analyzer_id ).

    ENDLOOP.


  ENDMETHOD.                    &quot;generate_values

ENDCLASS.                    &quot;lcl_screen_300 IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_message IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_message IMPLEMENTATION.
  METHOD report_message.
    IF i_disp_as IS INITIAL.
      MESSAGE i_msg TYPE i_type.
    ELSE.
      MESSAGE i_msg TYPE i_type DISPLAY LIKE i_disp_as.
    ENDIF.
  ENDMETHOD. &quot;report_message

  METHOD user_choice.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        titlebar      = i_title
        text_question = i_question
        text_button_1 = i_option_1
        text_button_2 = i_option_2
        popup_type    = i_icon
      IMPORTING
        answer        = return.
  ENDMETHOD.                    &quot;user_choice

ENDCLASS. &quot;lcl_message IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_element IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_element IMPLEMENTATION.

  METHOD get_command_contents.
    return = me-&gt;t_command_contents.
  ENDMETHOD.                    &quot;set_command_contents

  METHOD check_alias.

    DATA: l_tabix TYPE i.

    FIELD-SYMBOLS &lt;fs_aux&gt; TYPE string.

    l_tabix = i_index.

    ADD 1 TO l_tabix.
    READ TABLE i_query ASSIGNING &lt;fs_aux&gt; INDEX l_tabix.
    IF sy-subrc IS INITIAL AND &lt;fs_aux&gt; = lcl_commands=&gt;as.
      ADD 1 TO l_tabix.
      READ TABLE i_query ASSIGNING &lt;fs_aux&gt; INDEX l_tabix.
      return = &lt;fs_aux&gt;.
    ENDIF.

  ENDMETHOD.                    &quot;check_alias

  METHOD to_string.
    CONDENSE me-&gt;v_command.
    return = me-&gt;v_command.
  ENDMETHOD.                    &quot;to_string

ENDCLASS.                    &quot;lcl_query_element IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp;       Class (Implementation)  lcl_where
*&amp;---------------------------------------------------------------------*
CLASS lcl_where IMPLEMENTATION.

  METHOD set_command_contents.

    DATA: l_string     TYPE string,
          l_index      TYPE sytabix,
          l_tabix      TYPE i,
          l_first      TYPE boolean,
          l_length     TYPE i.

    FIELD-SYMBOLS: &lt;fs_aux&gt; TYPE string.

    READ TABLE i_query WITH KEY table_line = i_command TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix + 1.

      l_first = abap_true.
      LOOP AT i_query INTO l_string FROM l_index.
        IF l_string = lcl_commands=&gt;having OR
           l_string = lcl_commands=&gt;group  OR
           l_string = lcl_commands=&gt;up.
          EXIT.
        ENDIF.

        l_tabix = sy-tabix.

        l_length = STRLEN( l_string ).
        SUBTRACT 1 FROM l_length.
        IF l_string+l_length = &apos;.&apos; OR l_string+l_length = &apos;;&apos;.
          l_string = l_string(l_length).
        ENDIF.

        APPEND l_string TO me-&gt;t_command_contents.
        CONCATENATE me-&gt;v_command l_string INTO me-&gt;v_command SEPARATED BY space.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    &quot;set_command_contents

ENDCLASS.               &quot;lcl_where

*----------------------------------------------------------------------*
*       CLASS lcl_event_handler IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_event_handler IMPLEMENTATION.

  METHOD constructor.
    me-&gt;o_query_agent = i_query_agent.
  ENDMETHOD.                    &quot;constructor

  METHOD handle_added_function.

    CASE e_salv_function.
      WHEN c_del.
        DATA: o_save TYPE REF TO lcl_query_save.
        o_save = lcl_query_save=&gt;get_instance( ).
        o_save-&gt;delete_selected_query( ).
    ENDCASE.

  ENDMETHOD.                    &quot;handle_added_function

  METHOD handle_user_command.
    DATA o_query_agent TYPE REF TO lcl_query_agent.

    CASE e_ucomm.
      WHEN lcl_event_handler=&gt;c_tech.
        me-&gt;o_query_agent-&gt;inverse_fieldcat_names( ).

      WHEN lcl_event_handler=&gt;c_type.
        TRY.
            me-&gt;o_query_agent-&gt;generate_types( ).
          CATCH lcx_cancel.                              &quot;#EC NO_HANDLE
        ENDTRY.

      WHEN lcl_event_handler=&gt;c_perf.
        me-&gt;o_query_agent-&gt;show_performance_analyzer( ).

      WHEN lcl_event_handler=&gt;c_no_conv.
        me-&gt;o_query_agent-&gt;no_routine_conversion( ).

    ENDCASE.
  ENDMETHOD.                    &quot;handle_user_command

  METHOD handle_toolbar.

    me-&gt;add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_tech
                      i_icon      = &apos;@B_ACTY@&apos;
                      i_quickinfo = &apos;Inverse Names&apos;(004)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = &apos;Inverse Names&apos;(004)
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_type
                      i_icon      = &apos;@MSGTYP@&apos;
                      i_quickinfo = &apos;Generate Type&apos;(005)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = &apos;Generate Type&apos;(005)
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_perf
                      i_icon      = &apos;@B_TINA@&apos;
                      i_quickinfo = &apos;Performance Analyzer&apos;(006)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = &apos;Performance Analyzer&apos;(006)
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

*    me-&gt;add_button( EXPORTING
*                      i_function  = lcl_event_handler=&gt;c_no_conv
*                      i_icon      = &apos;@F_UNDO@&apos;
*                      i_quickinfo = &apos;No Conversion&apos;
*                      i_butn_type = 0
*                      i_disabled  = abap_false
*                      i_text      = &apos;No Conversion&apos;
*                    CHANGING
*                      t_toolbar = e_object-&gt;mt_toolbar ).

*    me-&gt;add_button( EXPORTING
*                      i_function  = &apos;TESTE&apos;
*                      i_quickinfo = &apos;Teste botão&apos;(006)
*                      i_butn_type = 2
*                      i_disabled  = abap_false
*                      i_text      = &apos;Teste botão&apos;(006)
*                    CHANGING
*                      t_toolbar = e_object-&gt;mt_toolbar ).

  ENDMETHOD.                    &quot;handle_toolbar

  METHOD add_button.

    FIELD-SYMBOLS &lt;fs_button&gt; TYPE stb_button.

    APPEND INITIAL LINE TO t_toolbar ASSIGNING &lt;fs_button&gt;.
    &lt;fs_button&gt;-function  = i_function.
    &lt;fs_button&gt;-icon      = i_icon.
    &lt;fs_button&gt;-quickinfo = i_quickinfo.
    &lt;fs_button&gt;-butn_type = i_butn_type.
    &lt;fs_button&gt;-disabled  = i_disabled.
    &lt;fs_button&gt;-text      = i_text.
    UNASSIGN &lt;fs_button&gt;.

  ENDMETHOD.                    &quot;add_button

  METHOD handle_menu_button.
*    e_object-&gt;add_function( fcode = &apos;TESTE&apos;
*                            text  = &apos;Teste 1&apos; ).
    &quot;icon  = &apos;@B_ACTY@&apos; ).
  ENDMETHOD.                    &quot;handle_menu_button

  METHOD handle_row_drag.
    DATA: o_drag_drop TYPE REF TO lcl_drag_drop,
          o_screen    TYPE REF TO lcl_screen_500,
          t_fields    TYPE tyt_table_fields,
          l_index     TYPE i.

    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.

    o_screen ?= lcl_screen=&gt;get_instance( 500 ).
    o_screen-&gt;check_changed_data( ).
    o_screen-&gt;get_fields( IMPORTING e_fields = t_fields ).

    l_index = e_row-index.

    READ TABLE t_fields ASSIGNING &lt;fs_field&gt; INDEX l_index.
    CHECK sy-subrc IS INITIAL.

    CREATE OBJECT o_drag_drop.
    o_drag_drop-&gt;set_index( l_index ).
    o_drag_drop-&gt;set_data( &lt;fs_field&gt; ).

    e_dragdropobj-&gt;object = o_drag_drop.
  ENDMETHOD.                    &quot;handle_row_drag

  METHOD handle_row_drop.
    DATA: o_drag_drop TYPE REF TO lcl_drag_drop,
          o_screen    TYPE REF TO lcl_screen_500,

          t_fields    TYPE tyt_table_fields,

          wa_stable   TYPE lvc_s_stbl,
          wa_field    TYPE ty_table_fields,

          l_index     TYPE i.

    wa_stable-row = abap_true. wa_stable-col = abap_true.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      o_drag_drop ?= e_dragdropobj-&gt;object.
      wa_field = o_drag_drop-&gt;get_data( ).

      o_screen ?= lcl_screen=&gt;get_instance( 500 ).
      o_screen-&gt;get_fields( IMPORTING e_fields = t_fields ).

      l_index = o_drag_drop-&gt;get_index( ).

      DELETE t_fields INDEX l_index.
      INSERT wa_field INTO t_fields INDEX e_row-index.

      o_screen-&gt;set_fields( t_fields ).
      o_screen-&gt;refresh_alv( i_soft_refresh = abap_true
                             i_stable       = wa_stable ).

    ENDCATCH.
    IF sy-subrc IS INITIAL.
      e_dragdropobj-&gt;abort( ).
    ENDIF.

  ENDMETHOD.                    &quot;handle_row_drop

  METHOD handle_toolbar_select_gen.
    me-&gt;add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_sall
                      i_icon      = &apos;@B_MRKA@&apos;
                      i_quickinfo = &apos;Select All&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_dall
                      i_icon      = &apos;@B_MRKD@&apos;
                      i_quickinfo = &apos;Deselect All&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

  ENDMETHOD.                    &quot;handle_toolbar_select_gen

  METHOD handle_user_command_select_gen.
    DATA: o_screen TYPE REF TO lcl_screen_500.
    o_screen ?= lcl_screen=&gt;get_instance( 500 ).

    CASE e_ucomm.
      WHEN c_sall.
        o_screen-&gt;mark_fields( ).
        o_screen-&gt;refresh_alv( ).

      WHEN c_dall.
        o_screen-&gt;unmark_fields( ).
        o_screen-&gt;refresh_alv( ).

    ENDCASE.

  ENDMETHOD.                    &quot;handle_user_command_select_gen

  METHOD handle_toolbar_from_gen.
    me-&gt;add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_add
                      i_icon      = &apos;@B_INSR@&apos;
                      i_quickinfo = &apos;Add join table&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_del
                      i_icon      = &apos;@B_DELR@&apos;
                      i_quickinfo = &apos;Delete join table&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_sugest
                      i_icon      = &apos;@B_RESH@&apos;
                      i_quickinfo = &apos;Suggest join tabls&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = &apos;Suggest Join&apos;
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

  ENDMETHOD.                    &quot;handle_toolbar_from_gen

  METHOD handle_user_command_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=&gt;get_instance( 600 ).

    TRY.
        CASE e_ucomm.
          WHEN c_add.
            o_screen-&gt;add_line( ).
            o_screen-&gt;refresh_alv( ).

          WHEN c_del.
            o_screen-&gt;delete_line( ).
            o_screen-&gt;refresh_alv( ).

          WHEN c_sugest.
            o_screen-&gt;suggest_join( ).
            o_screen-&gt;refresh_alv( ).

        ENDCASE.

      CATCH lcx_no_fields_selected.
        lcl_message=&gt;report_message( i_msg     = &apos;Please, select at least one row&apos;
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
    ENDTRY.

  ENDMETHOD.                    &quot;handle_user_command_from_gen

  METHOD handle_hotspot_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=&gt;get_instance( 600 ).
    o_screen-&gt;open_join_fields( e_row_id-index ).
  ENDMETHOD.                    &quot;handle_hotspot_from_gen

  METHOD handle_f4_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=&gt;get_instance( 600 ).
    o_screen-&gt;search_help_for_tabname( es_row_no-row_id ).
  ENDMETHOD.                    &quot;handle_f4_from_gen

  METHOD handle_toolbar_join.
    me-&gt;add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_add
                      i_icon      = &apos;@B_INSR@&apos;
                      i_quickinfo = &apos;Add Field&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

    me-&gt;add_button( EXPORTING
                      i_function  = lcl_event_handler=&gt;c_del
                      i_icon      = &apos;@B_DELR@&apos;
                      i_quickinfo = &apos;Delete Field(s)&apos;
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object-&gt;mt_toolbar ).

  ENDMETHOD.                    &quot;handle_toolbar_join

  METHOD handle_user_command_join.
    DATA: o_screen TYPE REF TO lcl_screen_700.
    o_screen ?= lcl_screen=&gt;get_instance( 700 ).

    TRY.
        CASE e_ucomm.
          WHEN c_add.
            o_screen-&gt;add_line( ).
            o_screen-&gt;refresh_alv( ).

          WHEN c_del.
            o_screen-&gt;delete_line( ).
            o_screen-&gt;refresh_alv( ).

        ENDCASE.

      CATCH lcx_no_fields_selected.
        lcl_message=&gt;report_message( i_msg     = &apos;Please, select at least one row&apos;
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
    ENDTRY.

  ENDMETHOD.                    &quot;handle_user_command_join

  METHOD handle_data_change_join.
    DATA: o_screen TYPE REF TO lcl_screen_700,
          wa_stable TYPE lvc_s_stbl.

    FIELD-SYMBOLS &lt;fs_mod_cells&gt; TYPE lvc_s_modi.

    o_screen ?= lcl_screen=&gt;get_instance( 700 ).

    LOOP AT er_data_changed-&gt;mt_mod_cells ASSIGNING &lt;fs_mod_cells&gt;.
      IF &lt;fs_mod_cells&gt;-fieldname = &apos;CHECKTABLE&apos;.
        o_screen-&gt;set_handle_checkfield( i_index = &lt;fs_mod_cells&gt;-row_id
                                         i_value = &lt;fs_mod_cells&gt;-value ).

        wa_stable-col = abap_true. wa_stable-row = abap_true.
        o_screen-&gt;refresh_alv( i_stable	      = wa_stable
                               i_soft_refresh = abap_true ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot;handle_data_change_join

ENDCLASS.                   &quot;lcl_event_handler IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_drag_drop IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_drag_drop IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_index.
    me-&gt;v_index = i_index.
  ENDMETHOD.                    &quot;set_index
  METHOD get_index.
    return = me-&gt;v_index.
  ENDMETHOD.                    &quot;get_index

  METHOD set_data.
*    GET REFERENCE OF i_data INTO me-&gt;o_data.
    me-&gt;o_data = i_data.
  ENDMETHOD.                    &quot;set_data
  METHOD get_data.
    return = me-&gt;o_data.
  ENDMETHOD.                    &quot;get_data
  &quot;$. Endregion Getters and Setters

ENDCLASS.                    &quot;lcl_drag_drop IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_type_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_type_generator IMPLEMENTATION.
  &quot;$. Region Getters and Setters
  METHOD set_type_name.
    me-&gt;v_type_name = i_type_name.
  ENDMETHOD.                    &quot;set_type_name
  METHOD get_type_name.
    return = me-&gt;v_type_name.
  ENDMETHOD.                    &quot;get_type_name

  METHOD get_command_line.
    return = me-&gt;t_command_line.
  ENDMETHOD.                    &quot;get_command_line
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_type_name( i_type_name ).
  ENDMETHOD.                    &quot;constructor

  METHOD generate_generic_type.

    DATA: l_tabname TYPE string,
          l_line TYPE string.

    l_tabname = i_table_name.
    TRANSLATE l_tabname TO LOWER CASE.

    CONCATENATE &apos;DATA t_&apos; l_tabname &apos; TYPE TABLE OF &apos; l_tabname &apos;. &quot;Internal table&apos; INTO l_line RESPECTING BLANKS. &quot;#EC NOTEXT
    me-&gt;add_command_line( l_line ).

    CONCATENATE &apos;DATA wa_&apos; l_tabname &apos; TYPE &apos; l_tabname &apos;. &quot;Structure&apos; l_tabname INTO l_line RESPECTING BLANKS. &quot;#EC NOTEXT
    me-&gt;add_command_line( l_line ).

    CONCATENATE &apos;FIELD-SYMBOLS &lt;fs_&apos; l_tabname &apos;&gt; TYPE &apos; l_tabname &apos;. &quot;Memory pointer structure&apos; INTO l_line RESPECTING BLANKS. &quot;#EC NOTEXT
    me-&gt;add_command_line( l_line ).

  ENDMETHOD.                    &quot;generate_generic_type

  METHOD generate_type_by_fcat.

    DATA: l_line    TYPE string,
          l_tabname TYPE string.

    FIELD-SYMBOLS: &lt;fs_fcat&gt; TYPE lvc_s_fcat.

    me-&gt;add_command_line( &apos;TYPES:&apos; ).

    CONCATENATE  cl_abap_char_utilities=&gt;horizontal_tab
                 &apos;BEGIN OF &apos;
                 me-&gt;v_type_name &apos;, &apos; INTO l_line RESPECTING BLANKS.
    me-&gt;add_command_line( l_line ).

    LOOP AT i_fieldcat ASSIGNING &lt;fs_fcat&gt;.

      CONCATENATE &lt;fs_fcat&gt;-ref_table &apos;-&apos; &lt;fs_fcat&gt;-ref_field INTO l_line.
      CONDENSE l_line NO-GAPS.

      CONCATENATE cl_abap_char_utilities=&gt;horizontal_tab
                  cl_abap_char_utilities=&gt;horizontal_tab
                  &lt;fs_fcat&gt;-fieldname
                  &apos; TYPE &apos;
                  l_line
                  &apos;, &quot;&apos;
                  &lt;fs_fcat&gt;-scrtext_l
             INTO l_line RESPECTING BLANKS.

      CONDENSE l_line.
      me-&gt;add_command_line( l_line ).

    ENDLOOP.

    CONCATENATE cl_abap_char_utilities=&gt;horizontal_tab &apos;END OF &apos; me-&gt;v_type_name &apos;.&apos; INTO l_line RESPECTING BLANKS.
    me-&gt;add_command_line( l_line ).

    me-&gt;add_command_line( ).

    me-&gt;generate_generic_type( me-&gt;v_type_name ).

  ENDMETHOD.                    &quot;generate_type_by_fcat

  METHOD add_command_line.
    IF i_line IS INITIAL.
      APPEND INITIAL LINE TO me-&gt;t_command_line.
    ELSE.
      APPEND i_line TO me-&gt;t_command_line.
    ENDIF.
  ENDMETHOD.                    &quot;add_command_line

  METHOD get_type_name_by_user.

    DATA l_targettext TYPE trm080-text.

    CALL FUNCTION &apos;TRM_POPUP_TEXT_INPUT&apos;
      EXPORTING
        titel        = &apos;Type name&apos;(007)
        start_column = 10
        start_row    = 2
      CHANGING
        targettext   = l_targettext.

    IF l_targettext IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    return = l_targettext.

  ENDMETHOD.                    &quot;get_type_name_by_user

ENDCLASS.                    &quot;lcl_type_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_performance_analyzer IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_performance_analyzer IMPLEMENTATION.

  METHOD class_constructor.
*    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;check_syntax
*                                               i_descr = &apos;Syntax Check&apos; ).
*    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;identify_query_elements
*                                               i_descr = &apos;Identify Query Elements&apos; ).
*    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;fieldcat_creation
*                                               i_descr = &apos;Fieldcatalog Creation&apos; ).
*    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;build_dynamic_structure
*                                               i_descr = &apos;Dymanic Structure Creation&apos; ).
    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;sql
                                               i_descr = &apos;SQL Statement&apos;(008) ).
    lcl_performance_analyzer=&gt;add_analyzer_id( i_id    = lcl_performance_analyzer=&gt;abap
                                               i_descr = &apos;ABAP Procedures&apos;(009) ).
  ENDMETHOD.                    &quot;class_constructor

  METHOD add_analyzer_id.
    FIELD-SYMBOLS &lt;fs_analyzer_id&gt; TYPE yt_analyzer_ids.
    APPEND INITIAL LINE TO t_analyzer_ids ASSIGNING &lt;fs_analyzer_id&gt;.
    &lt;fs_analyzer_id&gt;-analyzer_id = i_id.
    &lt;fs_analyzer_id&gt;-description = i_descr.
    UNASSIGN &lt;fs_analyzer_id&gt;.
  ENDMETHOD.                    &quot;add_analyzer_id

  METHOD get_analyzer_description.
    FIELD-SYMBOLS &lt;fs_analyzer_id&gt; TYPE yt_analyzer_ids.
    READ TABLE t_analyzer_ids ASSIGNING &lt;fs_analyzer_id&gt; WITH KEY analyzer_id = i_id.
    IF sy-subrc IS INITIAL.
      return = &lt;fs_analyzer_id&gt;-description.
    ENDIF.
  ENDMETHOD.                    &quot;get_analyzer_description

  METHOD start_runtime_analyzer.
    me-&gt;add_analyzer( i_analyzer_id ).
  ENDMETHOD.                    &quot;start_runtime_analyzer

  METHOD stop_runtime_analyzer.
    FIELD-SYMBOLS: &lt;fs_analyzer&gt; TYPE yt_analyzer.
    READ TABLE me-&gt;t_analyzer ASSIGNING &lt;fs_analyzer&gt; WITH KEY analyzer_id = i_analyzer_id.
    &lt;fs_analyzer&gt;-end_runtime = me-&gt;get_runtime_field( ).
    UNASSIGN &lt;fs_analyzer&gt;.
  ENDMETHOD.                    &quot;stop_runtime_analyzer

  METHOD add_analyzer.
    FIELD-SYMBOLS &lt;fs_analyzer&gt; TYPE yt_analyzer.
    APPEND INITIAL LINE TO me-&gt;t_analyzer ASSIGNING &lt;fs_analyzer&gt;.
    &lt;fs_analyzer&gt;-analyzer_id = i_id.
    &lt;fs_analyzer&gt;-start_runtime = me-&gt;get_runtime_field( ).
    UNASSIGN &lt;fs_analyzer&gt;.
  ENDMETHOD.                    &quot;add_analyzer

  METHOD get_runtime_field.
    GET RUN TIME FIELD return.
  ENDMETHOD.                    &quot;get_runtime_field

  METHOD get_analyzer.
    READ TABLE me-&gt;t_analyzer INTO return WITH KEY analyzer_id = i_id.
  ENDMETHOD.                    &quot;get_analyzer

  METHOD get_analyzer_table.
    t_analyzer = me-&gt;t_analyzer.
  ENDMETHOD.                    &quot;get_analyzer_table

  METHOD calculate_runtime.
    DATA: wa_analyzer TYPE yt_analyzer,
          l_time_diff TYPE f,
          l_time_dec  TYPE p DECIMALS 2,
          l_start     TYPE i,
          l_end       TYPE i.

    IF NOT i_id IS INITIAL.
      wa_analyzer = me-&gt;get_analyzer( i_id ).
      l_start = wa_analyzer-start_runtime.
      l_end   = wa_analyzer-end_runtime.
    ELSE.
      l_start = i_start.
      l_end   = i_end.
    ENDIF.

    l_time_diff = l_end - l_start.
    l_time_dec = l_time_diff.
    return = l_time_dec / 1000000.
  ENDMETHOD.                    &quot;calculate_runtime

ENDCLASS.                    &quot;lcl_performance_analyzer IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_saver IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_save IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_selected_query.
    me-&gt;t_selected_query = i_query.
  ENDMETHOD.                    &quot;set_selected_query
  METHOD get_selected_query.
    e_query = me-&gt;t_selected_query.
  ENDMETHOD.                    &quot;get_selected_query

  METHOD set_refresh.
    me-&gt;v_refresh = i_refresh.
  ENDMETHOD.                    &quot;set_refresh
  &quot;$. Endregion Getters and Setters

  METHOD get_instance.
    IF o_instance IS INITIAL.
      CREATE OBJECT o_instance.
    ENDIF.
    return = o_instance.
  ENDMETHOD.                    &quot;get_instance

  METHOD buffer_query_texted.
    DATA: t_lines   TYPE TABLE OF tline,
          t_query   TYPE salv_wd_t_string,
          t_aux     TYPE salv_wd_t_string,
          wa_header TYPE thead.

    FIELD-SYMBOLS: &lt;fs_line&gt;  TYPE tline,
                   &lt;fs_query&gt; TYPE string.

    LOOP AT i_query ASSIGNING &lt;fs_query&gt;.
      t_aux = lcl_query=&gt;split_text( i_text = &lt;fs_query&gt;
                                     i_outputlen = 200 ).
      APPEND LINES OF t_aux TO t_query.
    ENDLOOP.


    CONCATENATE me-&gt;c_buffer_prefix sy-uname INTO wa_header-tdname RESPECTING BLANKS.
    wa_header-tdobject   = &apos;TEXT&apos;.
    wa_header-tdid       = &apos;ST&apos;.
    wa_header-tdspras    = &apos;E&apos;.
    wa_header-tdlinesize = 250.

    LOOP AT t_query ASSIGNING &lt;fs_query&gt;.
      APPEND INITIAL LINE TO t_lines ASSIGNING &lt;fs_line&gt;.
      &lt;fs_line&gt;-tdformat = &apos;/(&apos;.
      &lt;fs_line&gt;-tdline = &lt;fs_query&gt;.
      UNASSIGN &lt;fs_line&gt;.
    ENDLOOP.

    CALL FUNCTION &apos;SAVE_TEXT&apos;
      EXPORTING
        client          = sy-mandt
        header          = wa_header
        savemode_direct = &apos;X&apos;
      TABLES
        lines           = t_lines
      EXCEPTIONS
        id              = 1
        language        = 2
        name            = 3
        object          = 4
        OTHERS          = 5.

  ENDMETHOD.                    &quot;buffer_query

  METHOD get_buffered_query.
    DATA l_qname TYPE string.
    CONCATENATE c_buffer_prefix sy-uname INTO l_qname RESPECTING BLANKS.
    return = me-&gt;read_query( l_qname ).
  ENDMETHOD.                    &quot;get_buffered_query

  METHOD get_query_name.

    DATA l_targettext TYPE trm080-text.

    CALL FUNCTION &apos;TRM_POPUP_TEXT_INPUT&apos;
      EXPORTING
        titel        = &apos;Query name&apos;(010)
        start_column = 10
        start_row    = 2
      CHANGING
        targettext   = l_targettext.

    IF l_targettext IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    CONCATENATE c_zquery_prefix l_targettext INTO return.
    CONDENSE return NO-GAPS. TRANSLATE return TO UPPER CASE.

  ENDMETHOD.                    &quot;get_query_name

  METHOD save_query.

    DATA: o_exception TYPE REF TO lcx_existent_object,
          t_lines TYPE TABLE OF tline,
          wa_header TYPE thead.

    TRY.
        me-&gt;check_existent_query( i_name ).
      CATCH lcx_existent_object INTO o_exception.
        DATA: l_question TYPE string.
        l_question = &apos;Overwrite existing query?&apos;(011).
        IF o_exception-&gt;continue_process( l_question ) = abap_false.
          RAISE EXCEPTION TYPE lcx_cancel.
        ENDIF.
    ENDTRY.

    me-&gt;compute_query( EXPORTING
                         i_query = i_query
                       IMPORTING
                         e_lines = t_lines ).

    wa_header-tdname     = i_name.
    wa_header-tdobject   = &apos;TEXT&apos;.
    wa_header-tdid       = &apos;ST&apos;.
    wa_header-tdspras    = &apos;E&apos;.
    wa_header-tdlinesize = 132.

    CALL FUNCTION &apos;SAVE_TEXT&apos;
      EXPORTING
        client          = sy-mandt
        header          = wa_header
        savemode_direct = &apos;X&apos;
      TABLES
        lines           = t_lines
      EXCEPTIONS
        id              = 1
        language        = 2
        name            = 3
        object          = 4
        OTHERS          = 5.

  ENDMETHOD.                    &quot;save_query

  METHOD delete_query.
    DATA: l_qname TYPE thead-tdname.
    l_qname = i_query_name.
    CALL FUNCTION &apos;DELETE_TEXT&apos;
      EXPORTING
        client    = sy-mandt
        id        = &apos;ST&apos;
        language  = &apos;E&apos;
        name      = l_qname
        object    = &apos;TEXT&apos;
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.
  ENDMETHOD.                    &quot;delete_query

  METHOD check_existent_query.
    me-&gt;read_query( i_query_name = i_name
                    i_check      = abap_true ).
  ENDMETHOD.                    &quot;check_existent_query

  METHOD compute_query.
    FIELD-SYMBOLS: &lt;fs_query&gt; TYPE string,
                   &lt;fs_line&gt;  TYPE tline.
    LOOP AT i_query ASSIGNING &lt;fs_query&gt;.
      APPEND INITIAL LINE TO e_lines ASSIGNING &lt;fs_line&gt;.
      &lt;fs_line&gt;-tdformat = &apos;/(&apos;.
      &lt;fs_line&gt;-tdline = &lt;fs_query&gt;.
      UNASSIGN &lt;fs_line&gt;.
    ENDLOOP.
  ENDMETHOD.                    &quot;compute_query

  METHOD read_query.
    DATA: t_lines TYPE TABLE OF tline,
          l_qname TYPE thead-tdname.
    FIELD-SYMBOLS &lt;fs_line&gt; TYPE tline.

    l_qname = i_query_name.

    CALL FUNCTION &apos;READ_TEXT&apos;
      EXPORTING
        client                  = sy-mandt
        id                      = &apos;ST&apos;
        language                = &apos;E&apos;
        name                    = l_qname
        object                  = &apos;TEXT&apos;
      TABLES
        lines                   = t_lines
      EXCEPTIONS
        id                      = 1
        language                = 2
        name                    = 3
        not_found               = 4
        object                  = 5
        reference_check         = 6
        wrong_access_to_archive = 7
        OTHERS                  = 8.
    IF sy-subrc IS INITIAL AND i_check = abap_true.
      RAISE EXCEPTION TYPE lcx_existent_object.
    ENDIF.

    IF sy-subrc IS INITIAL AND NOT t_lines IS INITIAL.
      LOOP AT t_lines ASSIGNING &lt;fs_line&gt;.
        APPEND &lt;fs_line&gt;-tdline TO return.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    &quot;read_query

  METHOD get_queries.

    TYPES: BEGIN OF yt_stxh,
             tdname  TYPE stxh-tdname,
             tdfuser TYPE stxh-tdfuser,
             tdfdate TYPE stxh-tdfdate,
           END OF yt_stxh.

    DATA: t_stxh TYPE TABLE OF yt_stxh,
          l_length TYPE i.

    FIELD-SYMBOLS: &lt;fs_stxh&gt; TYPE yt_stxh,
                   &lt;fs_query&gt; TYPE yt_query.

    SELECT tdname
           tdfuser
           tdfdate
      FROM stxh
      INTO TABLE t_stxh
     WHERE tdobject  = &apos;TEXT&apos;
       AND tdname LIKE i_query_name &quot;LIKE &apos;YZQUERY%&apos;
       AND tdid      = &apos;ST&apos;
       AND tdfuser  IN i_user &quot;= sy-uname
       AND tdspras   = &apos;E&apos;.

    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

    l_length = STRLEN( lcl_query_save=&gt;c_zquery_prefix ).

    LOOP AT t_stxh ASSIGNING &lt;fs_stxh&gt;.
      APPEND INITIAL LINE TO e_queries ASSIGNING &lt;fs_query&gt;.
      &lt;fs_query&gt;-query  = &lt;fs_stxh&gt;-tdname+l_length.
      &lt;fs_query&gt;-date   = &lt;fs_stxh&gt;-tdfdate.
      &lt;fs_query&gt;-user   = &lt;fs_stxh&gt;-tdfuser.
      UNASSIGN &lt;fs_query&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_queries

  METHOD search_queries.
    me-&gt;get_queries( EXPORTING
                       i_user       = i_user
                       i_query_name = i_query_name
                     IMPORTING
                       e_queries    = e_queries ).
  ENDMETHOD.                    &quot;search_queries

  METHOD display_queries.

    DATA: o_selections TYPE REF TO cl_salv_selections,
          o_columns    TYPE REF TO cl_salv_columns_table,
          o_column     TYPE REF TO cl_salv_column,
          t_queries    TYPE tyt_query,
          t_rows       TYPE salv_t_row.

    FIELD-SYMBOLS: &lt;fs_query&gt;     TYPE yt_query,
                   &lt;fs_cell_type&gt; TYPE salv_s_int4_column,
                   &lt;fs_row&gt;       TYPE i.

    me-&gt;set_selected_query( i_queries ).

    me-&gt;set_refresh( abap_true ).
    WHILE me-&gt;is_refresh( ) = abap_true.
      TRY.
          cl_salv_table=&gt;factory( IMPORTING
                                  r_salv_table = me-&gt;o_table
                                CHANGING
                                  t_table = me-&gt;t_selected_query ).
        CATCH cx_salv_msg.
          RETURN.
      ENDTRY.

      o_selections = me-&gt;o_table-&gt;get_selections( ).
      o_selections-&gt;set_selection_mode( if_salv_c_selection_mode=&gt;multiple ).

      me-&gt;o_table-&gt;set_screen_popup( start_column = 20
                                     end_column   = 85
                                     start_line   = 3
                                     end_line     = 20 ).

      LOOP AT me-&gt;t_selected_query ASSIGNING &lt;fs_query&gt;.
        CLEAR &lt;fs_query&gt;-check.
        APPEND INITIAL LINE TO &lt;fs_query&gt;-t_cell_type ASSIGNING &lt;fs_cell_type&gt;.
        &lt;fs_cell_type&gt;-columnname = &apos;CHECK&apos;.
        &lt;fs_cell_type&gt;-value = cl_salv_column_list=&gt;button.
        UNASSIGN &lt;fs_cell_type&gt;.
      ENDLOOP.

      TRY.
          o_columns = me-&gt;o_table-&gt;get_columns( ).
          o_columns-&gt;set_cell_type_column( value = &apos;T_CELL_TYPE&apos; ).
          o_column = o_columns-&gt;get_column( &apos;CHECK&apos; ).
          IF o_column IS BOUND.
            o_column-&gt;set_output_length( 2 ).
          ENDIF.
        CATCH: cx_salv_not_found, cx_salv_data_error.
          RETURN.
      ENDTRY.

      IF i_mine = abap_true.
        DATA: o_handler TYPE REF TO lcl_event_handler,
              o_events  TYPE REF TO cl_salv_events.
        CREATE OBJECT o_handler.
        me-&gt;o_table-&gt;set_screen_status( report   = sy-repid
                                        pfstatus = &apos;PF_SALV_STATUS&apos; ).
        o_events = me-&gt;o_table-&gt;get_event( ).
        SET HANDLER o_handler-&gt;handle_added_function FOR o_events.
      ENDIF.


      me-&gt;set_refresh( abap_false ).
      me-&gt;o_table-&gt;display( ).
*      IF me-&gt;is_refresh( ) = abap_true.
*        me-&gt;o_table-&gt;set_data( CHANGING t_table = me-&gt;t_selected_query ).
*      ENDIF.
    ENDWHILE.


    t_rows = o_selections-&gt;get_selected_rows( ).
    IF t_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    LOOP AT t_rows ASSIGNING &lt;fs_row&gt;.
      READ TABLE me-&gt;t_selected_query ASSIGNING &lt;fs_query&gt; INDEX &lt;fs_row&gt;.
      APPEND &lt;fs_query&gt; TO e_selected.
    ENDLOOP.

  ENDMETHOD.                    &quot;display_queries

  METHOD compute_selected_queries.
    DATA: o_query_save TYPE REF TO lcl_query_save,
          t_queries    TYPE tyt_query,
          t_text       TYPE salv_wd_t_string,
          l_query_name TYPE string.
    FIELD-SYMBOLS: &lt;fs_query&gt; TYPE yt_query.

    o_query_save = lcl_query_save=&gt;get_instance( ).
    t_queries = i_queries.
    LOOP AT t_queries ASSIGNING &lt;fs_query&gt;.
      CLEAR: l_query_name, t_text.
      CONCATENATE lcl_query_save=&gt;c_zquery_prefix &lt;fs_query&gt;-query INTO l_query_name RESPECTING BLANKS.
      t_text = o_query_save-&gt;read_query( l_query_name ).
      APPEND LINES OF t_text TO return.
      APPEND INITIAL LINE TO return.
    ENDLOOP.

  ENDMETHOD.                    &quot;compute_selected_queries

  METHOD delete_selected_query.
    DATA: o_selections TYPE REF TO cl_salv_selections,
          t_rows       TYPE salv_t_row,
          t_aux        TYPE tyt_query,
          l_answer     TYPE c.

    o_selections = me-&gt;o_table-&gt;get_selections( ).
    t_rows = o_selections-&gt;get_selected_rows( ).

    CHECK NOT t_rows IS INITIAL.

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question         = &apos;The selected record(s) will be deleted. Are you sure?&apos;(012)
        text_button_1         = &apos;Yes&apos;(018)
        text_button_2         = &apos;No&apos;(019)
        default_button        = &apos;1&apos;
        display_cancel_button = &apos;X&apos;
      IMPORTING
        answer                = l_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF l_answer &lt;&gt; &apos;1&apos;.
      RETURN.
    ENDIF.

    me-&gt;get_selected_queries_by_rows( EXPORTING i_rows = t_rows
                                      IMPORTING e_query = t_aux ).
    me-&gt;process_delete_query( t_aux ).

    me-&gt;set_refresh( abap_true ).

    me-&gt;o_table-&gt;close_screen( ).

  ENDMETHOD.                    &quot;delete_selected_query

  METHOD get_selected_queries_by_rows.
    FIELD-SYMBOLS: &lt;fs_row&gt; TYPE i,
                   &lt;fs_query&gt; TYPE yt_query.
    LOOP AT i_rows ASSIGNING &lt;fs_row&gt;.
      READ TABLE me-&gt;t_selected_query ASSIGNING &lt;fs_query&gt; INDEX &lt;fs_row&gt;.
      IF sy-subrc IS INITIAL.
        APPEND &lt;fs_query&gt; TO e_query.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;get_selected_queries_by_rows

  METHOD process_delete_query.
    DATA: l_name TYPE string.
    FIELD-SYMBOLS &lt;fs_query&gt; TYPE yt_query.
    LOOP AT i_query ASSIGNING &lt;fs_query&gt;.
      CLEAR: l_name.
      CONCATENATE lcl_query_save=&gt;c_zquery_prefix &lt;fs_query&gt;-query INTO l_name RESPECTING BLANKS.
      me-&gt;delete_query( l_name ).
      READ TABLE me-&gt;t_selected_query WITH KEY query = &lt;fs_query&gt;-query TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        DELETE me-&gt;t_selected_query INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot;process_delete_query

  METHOD is_refresh.
    return = me-&gt;v_refresh.
  ENDMETHOD.                    &quot;is_refresh

ENDCLASS.                    &quot;lcl_query_saver IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_error_query_check IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_error_query_check IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    me-&gt;v_message = i_message.
  ENDMETHOD.                    &quot;constructor

  METHOD get_message.
    return = me-&gt;v_message.
  ENDMETHOD.                    &quot;get_message
ENDCLASS.                    &quot;lcx_error_query_check IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_existent_object IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_existent_object IMPLEMENTATION.
  METHOD continue_process.

    DATA: l_answer TYPE c.

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question         = i_question
        text_button_1         = &apos;Yes&apos;
        text_button_2         = &apos;No&apos;
        default_button        = &apos;1&apos;
        display_cancel_button = &apos;X&apos;
      IMPORTING
        answer                = l_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc IS INITIAL AND l_answer = &apos;1&apos;.
      return = abap_true.
    ENDIF.

  ENDMETHOD.                    &quot;continue_process
ENDCLASS.                    &quot;lcx_existent_object IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_selection_screen IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_selection_screen IMPLEMENTATION.

  METHOD lif_screen~show.
    IF i_first_col IS INITIAL AND
       i_first_row IS INITIAL AND
       i_last_col  IS INITIAL AND
       i_last_row  IS INITIAL.
      CALL SELECTION-SCREEN me-&gt;lif_screen~v_screen.
    ELSE.
      CALL SELECTION-SCREEN me-&gt;lif_screen~v_screen STARTING AT i_first_col i_first_row
                                                      ENDING AT i_last_col  i_last_row.
    ENDIF.
  ENDMETHOD.                    &quot;lif_screen~show

ENDCLASS.                    &quot;lcl_selection_screen IMPLEMENTATION
*&amp;---------------------------------------------------------------------*
*&amp;       Class (Implementation)  lcl_screen_400
*&amp;---------------------------------------------------------------------*
CLASS lcl_screen_400 IMPLEMENTATION.

  METHOD lif_screen~user_command.
    TRY.
        CASE i_ucomm.
          WHEN c_exec.
            me-&gt;execute( ).
        ENDCASE.
      CATCH lcx_table_not_found.
    ENDTRY.
  ENDMETHOD.                    &quot;lif_screen~user_command

  METHOD execute.
    DATA: o_save    TYPE REF TO lcl_query_save,
          o_agent   TYPE REF TO lcl_query_agent,
          o_screen  TYPE REF TO lcl_screen_100,
          t_user    TYPE tyt_user_range,
          l_query_name TYPE string,

          t_queries TYPE tyt_query,
          t_aux     TYPE tyt_query,
          t_texted_query TYPE salv_wd_t_string.

    o_save  = lcl_query_save=&gt;get_instance( ).
    o_agent = lcl_query_agent=&gt;get_query_agent( ).

    me-&gt;compute_user_range( EXPORTING i_user = i_user
                            IMPORTING e_user_range = t_user ).
    l_query_name = me-&gt;compute_query_name( ).

    o_save-&gt;search_queries( EXPORTING
                              i_user       = t_user
                              i_query_name = l_query_name
                            IMPORTING
                              e_queries    = t_queries ).

    o_save-&gt;display_queries( EXPORTING
                               i_queries = t_queries
                             IMPORTING
                               e_selected = t_aux ).
    o_save-&gt;set_selected_query( t_aux ).

    t_texted_query = o_save-&gt;compute_selected_queries( t_aux ).

    o_screen ?= lcl_screen=&gt;get_instance( 100 ).
    o_screen-&gt;set_texted_query( t_texted_query ).

  ENDMETHOD.                    &quot;execute

  METHOD compute_user_range.
    FIELD-SYMBOLS &lt;fs_user&gt; LIKE LINE OF s_user.
    IF NOT i_user IS INITIAL.
      APPEND INITIAL LINE TO e_user_range ASSIGNING &lt;fs_user&gt;.
      &lt;fs_user&gt;-sign = &apos;I&apos;.
      &lt;fs_user&gt;-option = &apos;EQ&apos;.
      &lt;fs_user&gt;-low = i_user.
      UNASSIGN &lt;fs_user&gt;.
    ELSE.
      LOOP AT s_user ASSIGNING &lt;fs_user&gt;.
        APPEND &lt;fs_user&gt; TO e_user_range.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;compute_user_range

  METHOD compute_query_name.
    DATA l_name TYPE string.
    l_name = p_qname.
    TRANSLATE p_qname USING &apos;*%&apos;.
    CONCATENATE lcl_query_save=&gt;c_zquery_prefix l_name &apos;%&apos; INTO return RESPECTING BLANKS.
  ENDMETHOD.                    &quot;compute_query_name

ENDCLASS.               &quot;lcl_screen_400

*----------------------------------------------------------------------*
*       CLASS lcl_where_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_where_generator IMPLEMENTATION.

  METHOD generate.
    DATA: o_from   TYPE REF TO lcl_from,
          t_fields TYPE tyt_where_fields,
          t_tables TYPE yt_t_table.
    o_from ?= me-&gt;get_query_element( ).
    me-&gt;get_fields( EXPORTING i_from = o_from
                    IMPORTING e_fields = t_fields ).
    o_from-&gt;get_tables( IMPORTING e_tables = t_tables ).
    me-&gt;select_fields( CHANGING c_fields = t_fields ).
    return = me-&gt;get_dynamic_selections( i_fields = t_fields
                                         i_tables = t_tables ).
  ENDMETHOD.                    &quot;generate_where

  METHOD generate_new_query_text.
    DATA: t_text TYPE salv_wd_t_string,
          t_new_text TYPE TABLE OF string,
          l_string   TYPE string,
          l_result   TYPE string,
          l_garbage  TYPE string,
          l_split    TYPE boolean,
          l_lines    TYPE i,
          l_length   TYPE i.
    FIELD-SYMBOLS &lt;fs_aux&gt; TYPE string.
    t_text = i_query.

    LOOP AT t_text INTO l_string.
      CLEAR: l_result, l_garbage.
      IF NOT l_string = lcl_commands=&gt;where.
        SPLIT l_string AT lcl_commands=&gt;where INTO l_result l_garbage.
        IF l_garbage IS INITIAL.
          APPEND l_result TO t_new_text.
        ELSE.
          IF NOT l_result IS INITIAL.
            APPEND l_result TO t_new_text.
          ENDIF.
          EXIT.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

    l_lines = LINES( t_new_text ).
    READ TABLE t_new_text ASSIGNING &lt;fs_aux&gt; INDEX l_lines.
    IF sy-subrc IS INITIAL.
      l_length = STRLEN( &lt;fs_aux&gt; ). SUBTRACT 1 FROM l_length.
      IF &lt;fs_aux&gt;+l_length(1) = lcl_commands=&gt;dot.
        &lt;fs_aux&gt; = &lt;fs_aux&gt;(l_length).
      ENDIF.
    ENDIF.

    LOOP AT i_command_text INTO l_result.
      IF sy-tabix = 1.
        CONCATENATE lcl_commands=&gt;where l_result INTO l_string SEPARATED BY space.
      ELSE.
        l_string = l_result.
      ENDIF.
      AT LAST.
        CONCATENATE l_string lcl_commands=&gt;dot INTO l_string RESPECTING BLANKS.
      ENDAT.
      CONDENSE l_string.
      APPEND l_string TO t_new_text.
    ENDLOOP.

    return = t_new_text.

  ENDMETHOD.                    &quot;generate_new_query_text

  METHOD get_fields.
    DATA: o_table TYPE REF TO lcl_table,
          o_fieldcat TYPE REF TO lcl_fieldcat,
          t_fcat  TYPE lvc_t_fcat,
          t_fcat_aux TYPE lvc_t_fcat.

    FIELD-SYMBOLS: &lt;fs_fcat&gt; TYPE lvc_s_fcat,
                   &lt;fs_field&gt; TYPE ty_where_fields.

    CREATE OBJECT o_fieldcat.

    DO.
      TRY.
          o_table = i_from-&gt;get_table( i_index = sy-index ).
          t_fcat_aux = o_fieldcat-&gt;merge_fieldcat( o_table ).
          APPEND LINES OF t_fcat_aux TO t_fcat.
        CATCH lcx_table_not_found.
          EXIT.
        CATCH lcx_no_fieldcat.
          EXIT.
      ENDTRY.
    ENDDO.

    LOOP AT t_fcat ASSIGNING &lt;fs_fcat&gt;.
      CHECK &lt;fs_fcat&gt;-fieldname &lt;&gt; &apos;MANDT&apos;.
      APPEND INITIAL LINE TO e_fields ASSIGNING &lt;fs_field&gt;.
      &lt;fs_field&gt;-tabname     = &lt;fs_fcat&gt;-ref_table.
      &lt;fs_field&gt;-fieldname   = &lt;fs_fcat&gt;-fieldname.
      &lt;fs_field&gt;-description = &lt;fs_fcat&gt;-scrtext_l.
      &lt;fs_field&gt;-type        = &lt;fs_fcat&gt;-inttype.
      &lt;fs_field&gt;-where_leng  = &lt;fs_fcat&gt;-intlen.
      &lt;fs_field&gt;-sign        = &lt;fs_fcat&gt;-no_sign.
      &lt;fs_field&gt;-decimals    = &lt;fs_fcat&gt;-decimals_o.
      UNASSIGN &lt;fs_field&gt;.
    ENDLOOP.
  ENDMETHOD.                    &quot;get_fields

  METHOD select_fields.
    DATA: t_fields TYPE tyt_where_fields,
          t_fcat       TYPE slis_t_fieldcat_alv.

    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE slis_fieldcat_alv.

    t_fields = c_fields.

    &quot;$. Region Fieldcat
    APPEND INITIAL LINE TO t_fcat ASSIGNING &lt;fs_fcat&gt;.
    &lt;fs_fcat&gt;-fieldname = &apos;TABNAME&apos;.
    &lt;fs_fcat&gt;-reptext_ddic = &apos;Table Name&apos;(013).
    &lt;fs_fcat&gt;-outputlen = 10.
    UNASSIGN &lt;fs_fcat&gt;.

    APPEND INITIAL LINE TO t_fcat ASSIGNING &lt;fs_fcat&gt;.
    &lt;fs_fcat&gt;-fieldname = &apos;FIELDNAME&apos;.
    &lt;fs_fcat&gt;-reptext_ddic = &apos;Field Name&apos;(014).
    &lt;fs_fcat&gt;-outputlen = 10.
    UNASSIGN &lt;fs_fcat&gt;.

    APPEND INITIAL LINE TO t_fcat ASSIGNING &lt;fs_fcat&gt;.
    &lt;fs_fcat&gt;-fieldname = &apos;DESCRIPTION&apos;.
    &lt;fs_fcat&gt;-reptext_ddic = &apos;Description&apos;(015).
    &lt;fs_fcat&gt;-outputlen = 40.
    UNASSIGN &lt;fs_fcat&gt;.
    &quot;$. Endregion Fieldcat

    CALL FUNCTION &apos;REUSE_ALV_POPUP_TO_SELECT&apos;
      EXPORTING
        i_title               = &apos;Select fields to WHERE clause&apos;(016)
        i_zebra               = abap_true
        i_screen_start_column = 10
        i_screen_start_line   = 2
        i_checkbox_fieldname  = &apos;MARK&apos;
        i_tabname             = &apos;T_FIELDS&apos;
        it_fieldcat           = t_fcat
      TABLES
        t_outtab              = t_fields
      EXCEPTIONS
        program_error         = 1
        OTHERS                = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    DELETE t_fields WHERE mark = abap_false.
    DESCRIBE TABLE t_fields.
    IF sy-tfill &gt; 70.
      RAISE EXCEPTION TYPE lcx_fields_overflow.
    ELSEIF sy-tfill = 0.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    c_fields = t_fields.
  ENDMETHOD.                    &quot;select_fields

  METHOD get_dynamic_selections.
    DATA: t_tables     TYPE yt_t_table,
          t_tables_tab TYPE yt_rsdstabs,
          t_fields_tab TYPE yt_rsdsfields,
          t_twhere     TYPE rsds_twhere,
          l_selid      TYPE rsdynsel-selid.

    me-&gt;build_fields_to_selection( EXPORTING i_fields = i_fields
                                             i_tables = i_tables
                                   IMPORTING e_tables_tab = t_tables_tab
                                             e_fields_tab = t_fields_tab ).
    me-&gt;init_free_selection( CHANGING c_tables_tab = t_tables_tab
                                      c_fields_tab = t_fields_tab
                                      c_selid      = l_selid ).
    me-&gt;call_select_dialog( CHANGING c_selid      = l_selid
                                     c_fields_tab = t_fields_tab
                                     c_twhere     = t_twhere  ).
    return = me-&gt;get_dynamic_where( i_tables = i_tables
                                    i_fields = i_fields
                                    i_twhere = t_twhere ).

  ENDMETHOD.                    &quot;get_dynamic_selections

  METHOD build_fields_to_selection.
    DATA: o_table TYPE REF TO lcl_table.
    FIELD-SYMBOLS: &lt;fs_field&gt; TYPE ty_where_fields,
                   &lt;fs_field_tab&gt; TYPE rsdsfields,
                   &lt;fs_tab&gt;       TYPE rsdstabs.

    LOOP AT i_fields ASSIGNING &lt;fs_field&gt;.
      APPEND INITIAL LINE TO e_fields_tab ASSIGNING &lt;fs_field_tab&gt;.
      &lt;fs_field_tab&gt;-tablename  = &lt;fs_field&gt;-tabname.
      &lt;fs_field_tab&gt;-fieldname  = &lt;fs_field&gt;-fieldname.
      &lt;fs_field_tab&gt;-type       = &lt;fs_field&gt;-type.
      &lt;fs_field_tab&gt;-where_leng = &lt;fs_field&gt;-where_leng.
      &lt;fs_field_tab&gt;-sign       = &lt;fs_field&gt;-sign.
      &lt;fs_field_tab&gt;-decimals   = &lt;fs_field&gt;-decimals.
      UNASSIGN &lt;fs_field_tab&gt;.
    ENDLOOP.

    LOOP AT i_tables INTO o_table.
      APPEND INITIAL LINE TO e_tables_tab ASSIGNING &lt;fs_tab&gt;.
      &lt;fs_tab&gt;-prim_tab = o_table-&gt;get_name( ).
      UNASSIGN &lt;fs_tab&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;build_fields_to_selection

  METHOD init_free_selection.
    CALL FUNCTION &apos;FREE_SELECTIONS_INIT&apos;
      EXPORTING
        kind                     = &apos;T&apos;
      IMPORTING
        selection_id             = c_selid
      TABLES
        tables_tab               = c_tables_tab
        fields_tab               = c_fields_tab
      EXCEPTIONS
        fields_incomplete        = 01
        fields_no_join           = 02
        field_not_found          = 03
        no_tables                = 04
        table_not_found          = 05
        expression_not_supported = 06
        incorrect_expression     = 07
        illegal_kind             = 08
        area_not_found           = 09
        inconsistent_area        = 10
        kind_f_no_fields_left    = 11
        kind_f_no_fields         = 12
        too_many_fields          = 13.
  ENDMETHOD.                    &quot;init_free_selection

  METHOD call_select_dialog.
    CALL FUNCTION &apos;FREE_SELECTIONS_DIALOG&apos;
      EXPORTING
        selection_id    = c_selid
        title           = &apos;WHERE Generator&apos;(017)
        tree_visible    = &apos; &apos;
        as_window       = &apos;X&apos;
        start_row       = 2
        start_col       = 3
      IMPORTING
        where_clauses   = c_twhere
      TABLES
        fields_tab      = c_fields_tab
      EXCEPTIONS
        internal_error  = 1
        no_action       = 2
        selid_not_found = 3
        illegal_status  = 4.
    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.
  ENDMETHOD.                    &quot;call_select_dialog

  METHOD get_dynamic_where.
    DATA: o_table        TYPE REF TO lcl_table,
          t_where_fields TYPE tyt_where_fields,
          t_twhere       TYPE rsds_twhere,
          t_result       TYPE TABLE OF string,
          t_char72       TYPE TABLE OF rsdswhere,
          t_aux          TYPE TABLE OF string,
          l_tabname      TYPE string,
          l_alias        TYPE string,
          l_field        TYPE string,
          l_first_time   TYPE boolean VALUE &apos;X&apos;,
          l_where        TYPE string,
          l_aux          TYPE string,
          l_index        TYPE sy-tabix,
          l_replace      TYPE string.

    FIELD-SYMBOLS: &lt;fs_where_fields&gt; TYPE ty_where_fields,
                   &lt;fs_aux&gt;          TYPE string,
                   &lt;fs_rsdswhere&gt;    TYPE rsdswhere,
                   &lt;fs_where&gt;        TYPE rsds_where.

    t_where_fields = i_fields.
    t_twhere       = i_twhere.

    SORT: t_twhere       BY tablename,
          t_where_fields BY tabname.

    IF t_twhere IS INITIAL.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = &apos;No WHERE criteria inputed&apos;.
    ENDIF.

    LOOP AT i_tables INTO o_table.
      l_tabname = o_table-&gt;get_name( ).
      l_alias   = o_table-&gt;get_alias( ).

      READ TABLE t_twhere ASSIGNING &lt;fs_where&gt; WITH KEY tablename = l_tabname BINARY SEARCH.
      CHECK sy-subrc IS INITIAL.

      READ TABLE t_where_fields WITH KEY tabname = l_tabname TRANSPORTING NO FIELDS BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        l_index = sy-tabix.
        CLEAR: t_aux, l_where.
        LOOP AT &lt;fs_where&gt;-where_tab ASSIGNING &lt;fs_rsdswhere&gt;.
          CONDENSE &lt;fs_rsdswhere&gt;. l_aux = &lt;fs_rsdswhere&gt;.
          l_aux = lcl_report=&gt;compute_apostrophes( l_aux ).
*          CONCATENATE l_where &lt;fs_rsdswhere&gt; INTO l_where SEPARATED BY space.
          CONCATENATE l_where l_aux INTO l_where SEPARATED BY space.
        ENDLOOP.

        CONDENSE l_where.
        SPLIT l_where AT space INTO TABLE t_aux.

        LOOP AT t_where_fields ASSIGNING &lt;fs_where_fields&gt; FROM l_index.
          IF &lt;fs_where_fields&gt;-tabname &lt;&gt; l_tabname.
            EXIT.
          ENDIF.

          CLEAR: l_field.

          IF l_alias IS INITIAL.
            CONCATENATE l_tabname &apos;~&apos; &lt;fs_where_fields&gt;-fieldname INTO l_field RESPECTING BLANKS.
          ELSE.
            CONCATENATE l_alias &apos;~&apos; &lt;fs_where_fields&gt;-fieldname INTO l_field RESPECTING BLANKS.
          ENDIF.


          LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
            IF &lt;fs_aux&gt; = &lt;fs_where_fields&gt;-fieldname.
              &lt;fs_aux&gt; = l_field.
            ENDIF.
          ENDLOOP.

          AT END OF tabname.
            CLEAR l_where.
            LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
              CONCATENATE l_where &lt;fs_aux&gt; INTO l_where SEPARATED BY space.
            ENDLOOP.

            IF l_first_time = abap_true.
              l_first_time = abap_false.
            ELSE.
              CONCATENATE &apos;AND&apos; l_where INTO l_where SEPARATED BY space.
            ENDIF.

            CONDENSE l_where.

            t_aux = lcl_query=&gt;split_text( i_text      = l_where
                                           i_outputlen = 72 ).
            APPEND LINES OF t_aux TO return.
          ENDAT.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_dynamic_where

ENDCLASS.                    &quot;lcl_where_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_element_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_element_generator IMPLEMENTATION.
  &quot;$. Region Getters and Setters
  METHOD set_query_element.
    me-&gt;o_query_element = i_element.
  ENDMETHOD.                    &quot;set_query_element
  METHOD get_query_element.
    return = me-&gt;o_query_element.
  ENDMETHOD.                    &quot;get_query_element
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_query_element( i_element ).
  ENDMETHOD.                    &quot;constructor

  METHOD find_command.
    DATA: t_split TYPE salv_wd_t_string.
    SPLIT i_text AT space INTO TABLE t_split.
    FIND i_command IN TABLE t_split.
    return = sy-subrc.
  ENDMETHOD.                    &quot;find_command

ENDCLASS.                    &quot;lcl_query_element_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_select_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_generator IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_select_type.
    me-&gt;v_select_type = i_select_type.
  ENDMETHOD.                    &quot;set_select_type
  METHOD get_select_type.
    return = me-&gt;v_select_type.
  ENDMETHOD.                    &quot;get_select_type

  METHOD set_select.
    me-&gt;o_select = i_select.
  ENDMETHOD.                    &quot;set_select
  METHOD get_select.
    return = me-&gt;o_select.
  ENDMETHOD.                    &quot;get_select

  METHOD set_aggregation.
    me-&gt;v_aggregation = i_aggregation.
  ENDMETHOD.                    &quot;set_aggregation
  METHOD get_aggregation.
    return = me-&gt;v_aggregation.
  ENDMETHOD.                    &quot;get_aggregation
  &quot;$. Endregion Getters and Setters

  METHOD generate.
    DATA: o_from TYPE REF TO lcl_from,
          t_tables TYPE yt_t_table,
          t_fields TYPE tyt_table_fields,
          t_text TYPE salv_wd_t_string.

    o_from ?= me-&gt;get_query_element( ).
    o_from-&gt;get_tables( IMPORTING e_tables = t_tables ).
    me-&gt;get_fields( EXPORTING i_tables = t_tables
                    IMPORTING e_fields = t_fields ).

    me-&gt;select_fields( CHANGING e_fields = t_fields ).
    return = me-&gt;compute_fields( t_fields ).
    me-&gt;t_fields = t_fields.
  ENDMETHOD.                    &quot;generate

  METHOD generate_new_query_text.
    DATA: t_text     TYPE salv_wd_t_string,
          t_new_text TYPE TABLE OF string,
          t_split    TYPE TABLE OF string,

          l_find     TYPE boolean,
          l_string   TYPE string,
          l_result   TYPE string,
          l_garbage  TYPE string,
          l_split    TYPE boolean,
          l_select_type TYPE string.

    CHECK NOT i_command_text IS INITIAL.

    IF i_query IS INITIAL.
      APPEND i_query_string TO t_text.
    ELSE.
      t_text = i_query.
    ENDIF.

    l_select_type = me-&gt;get_select_type( ).

    IF l_select_type = lcl_commands=&gt;count.
      CONCATENATE lcl_commands=&gt;select lcl_commands=&gt;count_command INTO l_string SEPARATED BY space.
      APPEND l_string TO t_new_text.
    ELSE.
      LOOP AT i_command_text INTO l_result.
        IF sy-tabix = 1.
          CONCATENATE lcl_commands=&gt;select l_select_type l_result INTO l_string SEPARATED BY space.
        ELSE.
          l_string = l_result.
        ENDIF.
        CONDENSE l_string.
        APPEND l_string TO t_new_text.
      ENDLOOP.
    ENDIF.

    CLEAR: l_string, l_result.

    LOOP AT t_text INTO l_string.
      IF l_find = abap_false.
        CLEAR t_split.
        SPLIT l_string AT space INTO TABLE t_split.
        FIND lcl_commands=&gt;from IN TABLE t_split.
        IF sy-subrc IS INITIAL.
          l_find = abap_true.
        ENDIF.
      ENDIF.

      CHECK l_find = abap_true.

      SPLIT l_string AT lcl_commands=&gt;from INTO l_result l_garbage.
      IF NOT l_garbage IS INITIAL.
*        CONCATENATE cl_abap_char_utilities=&gt;horizontal_tab lcl_commands=&gt;from l_garbage INTO l_garbage SEPARATED BY space.
        CONCATENATE lcl_commands=&gt;from l_garbage INTO l_garbage SEPARATED BY space.
        CONDENSE l_garbage.
        APPEND l_garbage TO t_new_text.
      ELSE.
        IF NOT l_result IS INITIAL.
          CONDENSE l_result.
          APPEND l_result TO t_new_text.
        ELSE.
          APPEND lcl_commands=&gt;from TO t_new_text.
        ENDIF.
      ENDIF.

    ENDLOOP.

    IF me-&gt;get_aggregation( ) = abap_true.
      DATA: t_group_by TYPE salv_wd_t_string.
      t_group_by = me-&gt;compute_aggregation_clause( ).
      APPEND LINES OF t_group_by TO t_new_text.
    ENDIF.

    return = t_new_text.

  ENDMETHOD.                    &quot;generate_new_query_text

  METHOD get_fields.
    DATA: o_table TYPE REF TO lcl_table,
          t_aux   TYPE tyt_table_fields.
    FIELD-SYMBOLS: &lt;fs_field&gt; TYPE ty_table_fields.

    LOOP AT i_tables INTO o_table.
      CLEAR t_aux.
      o_table-&gt;get_table_fields( IMPORTING e_fields = t_aux ).
      APPEND LINES OF t_aux TO e_fields.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_fields

  METHOD mark_fields.
    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.

    IF me-&gt;o_select IS BOUND.
      IF me-&gt;o_select-&gt;get_select_type( ) = lcl_commands=&gt;asterisk.
        LOOP AT e_fields ASSIGNING &lt;fs_field&gt;.
          &lt;fs_field&gt;-mark = abap_true.
        ENDLOOP.
      ELSE.

        DATA: o_field         TYPE REF TO lcl_field,
              t_select_fields TYPE yt_t_fields,
              l_name          TYPE string,
              l_table_name    TYPE string.

        me-&gt;o_select-&gt;get_fields( IMPORTING return = t_select_fields ).
        IF me-&gt;o_select-&gt;get_fields_count( ) = 1.
          READ TABLE t_select_fields INTO o_field INDEX 1.
          IF o_field-&gt;get_field_name( ) = lcl_commands=&gt;asterisk.
            LOOP AT e_fields ASSIGNING &lt;fs_field&gt;.
              &lt;fs_field&gt;-mark = abap_true.
            ENDLOOP.
            RETURN.
          ENDIF.
        ENDIF.

        LOOP AT t_select_fields INTO o_field.
          l_name = o_field-&gt;get_field_name( ).
          l_table_name = o_field-&gt;get_table_name( ).
          IF l_table_name IS INITIAL.
            READ TABLE e_fields ASSIGNING &lt;fs_field&gt; WITH KEY fieldname = l_name.
            IF sy-subrc IS INITIAL.
              &lt;fs_field&gt;-mark = abap_true.
            ENDIF.
          ELSE.
            READ TABLE e_fields ASSIGNING &lt;fs_field&gt; WITH KEY tabname   = l_table_name
                                                              fieldname = l_name.
            IF sy-subrc IS INITIAL.
              &lt;fs_field&gt;-mark = abap_true.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    &quot;mark_fields

  METHOD select_fields.
    DATA: o_screen      TYPE REF TO lcl_screen_500,
          t_fields      TYPE tyt_table_fields,
          t_fcat        TYPE slis_t_fieldcat_alv,
          l_select_type TYPE string.

    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE slis_fieldcat_alv.

    t_fields = e_fields.

    me-&gt;mark_fields( CHANGING e_fields = t_fields ).

    o_screen ?= lcl_screen=&gt;get_instance( 500 ).
    o_screen-&gt;flush( ).
    o_screen-&gt;set_select_type( me-&gt;v_select_type ).
    o_screen-&gt;set_fields( t_fields ).
    o_screen-&gt;show( i_first_col = 10
                    i_first_row = 2
                    i_last_col  = 130
                    i_last_row  = 20 ).

    IF o_screen-&gt;get_exit_command( ) = abap_true.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    o_screen-&gt;get_fields( IMPORTING e_fields = t_fields ).
    l_select_type = o_screen-&gt;get_select_type( ).
    me-&gt;set_select_type( l_select_type ).
    me-&gt;check_aggregation( t_fields ).

    e_fields = t_fields.

  ENDMETHOD.                    &quot;select_fields

  METHOD compute_fields.
    DATA: l_field          TYPE string,
          l_aux            TYPE string,
          l_select_command TYPE string.

    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.

    CHECK NOT i_fields IS INITIAL.

    LOOP AT i_fields ASSIGNING &lt;fs_field&gt;.
      IF NOT &lt;fs_field&gt;-tab_alias IS INITIAL.
        CONCATENATE &lt;fs_field&gt;-tab_alias &apos;~&apos; &lt;fs_field&gt;-fieldname INTO l_field.
      ELSE.
        CONCATENATE &lt;fs_field&gt;-tabname &apos;~&apos; &lt;fs_field&gt;-fieldname INTO l_field.
      ENDIF.

      TRANSLATE l_field TO LOWER CASE.

      IF NOT &lt;fs_field&gt;-sql_function IS INITIAL.
        CONCATENATE &lt;fs_field&gt;-sql_function &apos;(&apos; INTO l_aux. CONDENSE l_aux NO-GAPS.
        CONCATENATE l_aux l_field &apos;)&apos; INTO l_field SEPARATED BY space.
      ENDIF.

      IF NOT &lt;fs_field&gt;-field_alias IS INITIAL.
        CONCATENATE l_field &apos;AS&apos; &lt;fs_field&gt;-field_alias INTO l_field SEPARATED BY space.
      ENDIF.

      CONCATENATE l_select_command l_field INTO l_select_command SEPARATED BY space.
    ENDLOOP.

    CONDENSE l_select_command.

    return = lcl_query=&gt;split_text( i_text      = l_select_command
                                    i_outputlen = 80 ).

  ENDMETHOD.                    &quot;compute_fields

  METHOD check_aggregation.
    DATA: t_fields TYPE tyt_table_fields.
    t_fields = i_fields.
    DELETE t_fields WHERE sql_function IS INITIAL.
    IF LINES( t_fields ) &gt; 0.
      me-&gt;set_aggregation( abap_true ).
    ENDIF.
  ENDMETHOD.                    &quot;check_aggregation

  METHOD compute_aggregation_clause.
    DATA: t_fields           TYPE tyt_table_fields,
          l_field            TYPE string,
          l_aux              TYPE string,
          l_group_by_command TYPE string.

    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.

    t_fields = me-&gt;t_fields.
    DELETE t_fields WHERE sql_function IS NOT INITIAL.

    CHECK NOT t_fields IS INITIAL.

    CONCATENATE cl_abap_char_utilities=&gt;horizontal_tab lcl_commands=&gt;group lcl_commands=&gt;by
           INTO l_group_by_command SEPARATED BY space.


    LOOP AT t_fields ASSIGNING &lt;fs_field&gt;.
      IF NOT &lt;fs_field&gt;-tab_alias IS INITIAL.
        CONCATENATE &lt;fs_field&gt;-tab_alias &apos;~&apos; &lt;fs_field&gt;-fieldname INTO l_field.
      ELSE.
        CONCATENATE &lt;fs_field&gt;-tabname &apos;~&apos; &lt;fs_field&gt;-fieldname INTO l_field.
      ENDIF.

      TRANSLATE l_field TO LOWER CASE.

      CONCATENATE l_group_by_command l_field INTO l_group_by_command SEPARATED BY space.
    ENDLOOP.

    CONDENSE l_group_by_command.

    return = lcl_query=&gt;split_text( i_text      = l_group_by_command
                                    i_outputlen = 80 ).
  ENDMETHOD.                    &quot;compute_aggregation_clause

  METHOD generate_by_fieldcat.
    DATA: o_table    TYPE REF TO lcl_table,
          o_from     TYPE REF TO lcl_from,
          t_fieldcat TYPE lvc_t_fcat,
          t_fields   TYPE tyt_table_fields,
          l_table    TYPE string.

    FIELD-SYMBOLS: &lt;fs_fcat&gt; TYPE lvc_s_fcat,
                   &lt;fs_field&gt; TYPE ty_table_fields.

    t_fieldcat = i_fieldcat-&gt;get_fieldcat( ).
    o_from ?= me-&gt;get_query_element( ).

    LOOP AT t_fieldcat ASSIGNING &lt;fs_fcat&gt;.
      APPEND INITIAL LINE TO t_fields ASSIGNING &lt;fs_field&gt;.
      l_table = &lt;fs_fcat&gt;-ref_table.
      o_table = o_from-&gt;get_table( i_table = l_table ).
      &lt;fs_field&gt;-tabname     = &lt;fs_fcat&gt;-ref_table.
      &lt;fs_field&gt;-tab_alias   = o_table-&gt;get_alias( ).
      &lt;fs_field&gt;-fieldname   = &lt;fs_fcat&gt;-ref_field.
      &lt;fs_field&gt;-field_alias = &lt;fs_fcat&gt;-fieldname.
      UNASSIGN &lt;fs_field&gt;.
    ENDLOOP.

    return = me-&gt;compute_fields( t_fields ).

  ENDMETHOD.                    &quot;generate_by_fieldcat

ENDCLASS.                    &quot;lcl_select_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*       CLASS lcl_screen_500 IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_screen_500 IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_fields.
    me-&gt;t_fields = i_fields.
  ENDMETHOD.                    &quot;set_fields
  METHOD get_fields.
    e_fields = me-&gt;t_fields.
  ENDMETHOD.                    &quot;get_fields
  &quot;$. Endregion Getters and Setters

  METHOD flush.
    IF me-&gt;o_grid IS BOUND.
      me-&gt;o_grid-&gt;free( ).
      me-&gt;o_container-&gt;free( ).
      CLEAR: me-&gt;o_grid, me-&gt;o_container, v_select_type, me-&gt;t_fields,
             me-&gt;o_select_type, me-&gt;o_event_handler, me-&gt;o_behaviour_alv.
    ENDIF.
  ENDMETHOD.                    &quot;flush

  METHOD lif_screen~user_command.
    me-&gt;o_grid-&gt;check_changed_data( ).
    CASE i_ucomm.
      WHEN c_enter.
        IF me-&gt;verify_selected_fields( ) = abap_true.
          LEAVE TO SCREEN 0.
        ENDIF.

    ENDCASE.
  ENDMETHOD.                    &quot;user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS &apos;PF_0500&apos;.
  ENDMETHOD.                    &quot;screen_status

  METHOD lif_screen~initialize_screen.
    me-&gt;initialize_alv( ).
    me-&gt;initialize_select_type( ).
  ENDMETHOD.                    &quot;initialize_screen

  METHOD create_fcat.
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;MARK&apos;
                             i_edit      = abap_true
                             i_descr     = &apos;Select Field&apos;
                             i_outputlen = 10
                             i_checkbox  = abap_true
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;TABNAME&apos;
                             i_edit      = abap_false
                             i_descr     = &apos;Table Name&apos;
                             i_outputlen = 12
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;FIELDNAME&apos;
                             i_edit      = abap_false
                             i_descr     = &apos;Fieldname Name&apos;
                             i_outputlen = 15
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;DESCR&apos;
                             i_edit      = abap_false
                             i_descr     = &apos;Field Description&apos;
                             i_outputlen = 20
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;TAB_ALIAS&apos;
                             i_edit      = abap_false
                             i_descr     = &apos;Table Alias&apos;
                             i_outputlen = 12
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname = &apos;FIELD_ALIAS&apos;
                             i_edit      = abap_true
                             i_descr     = &apos;Field Alias&apos;
                             i_outputlen = 15
                           CHANGING
                             e_fieldcat = return ).
    me-&gt;add_field_to_fcat( EXPORTING
                             i_fieldname  = &apos;SQL_FUNCTION&apos;
                             i_edit       = abap_true
                             i_descr      = &apos;SQL Function&apos;
                             i_outputlen  = 20
                             i_drop_down  = 1
                             i_drop_alias = abap_true
                           CHANGING
                             e_fieldcat = return ).
  ENDMETHOD.                    &quot;create_fcat

  METHOD add_field_to_fcat.
    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.
    APPEND INITIAL LINE TO e_fieldcat ASSIGNING &lt;fs_fcat&gt;.
    &lt;fs_fcat&gt;-fieldname  = i_fieldname.
    &lt;fs_fcat&gt;-coltext    = i_descr.
    &lt;fs_fcat&gt;-edit       = i_edit.
    &lt;fs_fcat&gt;-outputlen  = i_outputlen.
    &lt;fs_fcat&gt;-drdn_hndl  = i_drop_down.
    &lt;fs_fcat&gt;-drdn_alias = i_drop_alias.
    &lt;fs_fcat&gt;-checkbox   = i_checkbox.
    UNASSIGN &lt;fs_fcat&gt;.
  ENDMETHOD.                    &quot;add_field_to_fcat

  METHOD create_layout.
    return-stylefname = &apos;STYLE&apos;.
  ENDMETHOD.                    &quot;create_layout

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    &quot;exclude_functions

  METHOD get_sql_functions_drop_down.
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = space
                                   i_int_value = space
                                 CHANGING
                                   e_drop_down = return ).
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;sum
                                   i_int_value = lcl_commands=&gt;sum
                                 CHANGING
                                   e_drop_down = return ).
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;avg
                                   i_int_value = lcl_commands=&gt;avg
                                 CHANGING
                                   e_drop_down = return ).
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;max
                                   i_int_value = lcl_commands=&gt;max
                                 CHANGING
                                   e_drop_down = return ).
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;min
                                   i_int_value = lcl_commands=&gt;min
                                 CHANGING
                                   e_drop_down = return ).
  ENDMETHOD.                    &quot;get_sql_functions_drop_down

  METHOD add_option_to_drop_down.
    FIELD-SYMBOLS &lt;fs_drop_down&gt; TYPE lvc_s_dral.
    APPEND INITIAL LINE TO e_drop_down ASSIGNING &lt;fs_drop_down&gt;.
    &lt;fs_drop_down&gt;-handle    = i_handle.
    &lt;fs_drop_down&gt;-value     = i_value.
    &lt;fs_drop_down&gt;-int_value = i_int_value.
    UNASSIGN &lt;fs_drop_down&gt;.
  ENDMETHOD.                    &quot;add_option_to_drop_down

  METHOD initialize_alv.
    IF me-&gt;o_grid IS INITIAL.
      DATA: t_fcat      TYPE lvc_t_fcat,
            t_exclude   TYPE ui_functions,
            t_drop_down TYPE lvc_t_dral,
            wa_layout   TYPE lvc_s_layo,
            l_effect    TYPE i.

      CREATE OBJECT me-&gt;o_container
        EXPORTING
          container_name = &apos;CONTAINER&apos;.

      CREATE OBJECT me-&gt;o_grid
        EXPORTING
          i_parent = me-&gt;o_container.

      CREATE OBJECT me-&gt;o_event_handler.
      SET HANDLER: me-&gt;o_event_handler-&gt;handle_row_drag                FOR me-&gt;o_grid,
                   me-&gt;o_event_handler-&gt;handle_row_drop                FOR me-&gt;o_grid,
                   me-&gt;o_event_handler-&gt;handle_toolbar_select_gen      FOR me-&gt;o_grid,
                   me-&gt;o_event_handler-&gt;handle_user_command_select_gen FOR me-&gt;o_grid.

      CREATE OBJECT me-&gt;o_behaviour_alv.
      l_effect = cl_dragdrop=&gt;move.
      me-&gt;o_behaviour_alv-&gt;add( flavor     = &apos;Line&apos;         &quot;#EC NOTEXT
                                dragsrc    = abap_true
                                droptarget = abap_true
                                effect     = l_effect ).

      wa_layout = me-&gt;create_layout( ).
      me-&gt;o_behaviour_alv-&gt;get_handle( IMPORTING handle = wa_layout-s_dragdrop-row_ddid ).

      t_fcat      = me-&gt;create_fcat( ).
      t_exclude   = me-&gt;exclude_functions( ).
      t_drop_down = me-&gt;get_sql_functions_drop_down( ).
      me-&gt;lock_drop_down( ).

      me-&gt;o_grid-&gt;set_ready_for_input( 1 ).
      me-&gt;o_grid-&gt;set_table_for_first_display( EXPORTING
                                                 is_layout            = wa_layout
                                                 it_toolbar_excluding = t_exclude
                                               CHANGING
                                                 it_outtab            = t_fields
                                                 it_fieldcatalog      = t_fcat ).
      me-&gt;o_grid-&gt;set_drop_down_table( it_drop_down_alias = t_drop_down ).
      me-&gt;o_grid-&gt;refresh_table_display( ).
    ENDIF.
  ENDMETHOD.                    &quot;initialize_alv

  METHOD initialize_select_type.
    IF me-&gt;o_select_type IS INITIAL.
      DATA: t_values TYPE vrm_values.

      GET REFERENCE OF v_select_type INTO me-&gt;o_select_type.

      t_values = me-&gt;create_vrm_values( ).

      CALL FUNCTION &apos;VRM_SET_VALUES&apos;
        EXPORTING
          id     = &apos;V_SELECT_TYPE&apos;
          values = t_values.
    ENDIF.
  ENDMETHOD.                    &quot;initialize_select_type

  METHOD create_vrm_values.
    me-&gt;add_vrm_value( EXPORTING
                         i_key    = space
                         i_text   = &apos;Default&apos;
                       CHANGING
                         e_values = return ).
    me-&gt;add_vrm_value( EXPORTING
                         i_key    = lcl_commands=&gt;single
                         i_text   = lcl_commands=&gt;single
                       CHANGING
                         e_values = return ).
    me-&gt;add_vrm_value( EXPORTING
                         i_key    = lcl_commands=&gt;distinct
                         i_text   = lcl_commands=&gt;distinct
                       CHANGING
                         e_values = return ).
  ENDMETHOD.                    &quot;create_vrm_values

  METHOD add_vrm_value.
    FIELD-SYMBOLS &lt;fs_value&gt; TYPE vrm_value.
    APPEND INITIAL LINE TO e_values ASSIGNING &lt;fs_value&gt;.
    &lt;fs_value&gt;-key  = i_key.
    &lt;fs_value&gt;-text = i_text.
    UNASSIGN &lt;fs_value&gt;.
  ENDMETHOD.                    &quot;add_vrm_value

  METHOD get_select_type.
    FIELD-SYMBOLS &lt;fs_aux&gt; TYPE ANY.
    ASSIGN o_select_type-&gt;* TO &lt;fs_aux&gt;.
    CHECK sy-subrc IS INITIAL.
    return = &lt;fs_aux&gt;.
  ENDMETHOD.                    &quot;get_select_type

  METHOD set_select_type.
    v_select_type = i_select_type.
  ENDMETHOD.                    &quot;set_select_type

  METHOD check_changed_data.
    me-&gt;o_grid-&gt;check_changed_data( ).
  ENDMETHOD.                    &quot;check_changed_data

  METHOD refresh_alv.
    me-&gt;o_grid-&gt;refresh_table_display( is_stable      = i_stable
                                       i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    &quot;refresh_alv

  METHOD lock_drop_down.
    DATA: wa_style TYPE lvc_s_styl.
    FIELD-SYMBOLS: &lt;fs_field&gt; TYPE ty_table_fields.
    IF i_all = abap_true.
      LOOP AT me-&gt;t_fields ASSIGNING &lt;fs_field&gt;.
        CLEAR &lt;fs_field&gt;-style.
        wa_style-fieldname = &apos;SQL_FUNCTION&apos;.
        wa_style-style = cl_gui_alv_grid=&gt;mc_style_disabled.
        APPEND wa_style TO &lt;fs_field&gt;-style.
      ENDLOOP.
    ELSE.
      LOOP AT me-&gt;t_fields ASSIGNING &lt;fs_field&gt;.
        IF &lt;fs_field&gt;-internal_type &lt;&gt; &apos;I&apos; AND
           &lt;fs_field&gt;-internal_type &lt;&gt; &apos;P&apos; AND
           &lt;fs_field&gt;-internal_type &lt;&gt; &apos;F&apos;.
          CLEAR &lt;fs_field&gt;-style.
          wa_style-fieldname = &apos;SQL_FUNCTION&apos;.
          wa_style-style = cl_gui_alv_grid=&gt;mc_style_disabled.
          APPEND wa_style TO &lt;fs_field&gt;-style.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;lock_drop_down

  METHOD mark_fields.
    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.
    LOOP AT me-&gt;t_fields ASSIGNING &lt;fs_field&gt;.
      &lt;fs_field&gt;-mark = abap_true.
    ENDLOOP.
  ENDMETHOD.                    &quot;mark_fields

  METHOD unmark_fields.
    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.
    LOOP AT me-&gt;t_fields ASSIGNING &lt;fs_field&gt;.
      &lt;fs_field&gt;-mark = abap_false.
    ENDLOOP.
  ENDMETHOD.                    &quot;unmark_fields

  METHOD verify_selected_fields.
    DATA: t_aux TYPE tyt_table_fields.

    me-&gt;get_fields( IMPORTING e_fields = t_aux ).

    DELETE t_aux WHERE mark IS INITIAL.
    IF t_aux IS INITIAL.
      lcl_message=&gt;report_message( i_msg     = &apos;Please, select at least one row&apos;
                                   i_type    = &apos;I&apos;
                                   i_disp_as = &apos;E&apos; ).
    ELSE.
      me-&gt;set_fields( t_aux ).
      return = abap_true.
    ENDIF.

  ENDMETHOD.                    &quot;verify_selected_fields

ENDCLASS.               &quot;lcl_screen_500

*----------------------------------------------------------------------*
*       CLASS lcx_query_element_not_found IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcx_query_element_not_found IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    me-&gt;v_text = i_text.
  ENDMETHOD.                    &quot;constructor
  METHOD get_message.
    return = me-&gt;v_text.
  ENDMETHOD.                    &quot;get_message
ENDCLASS.                    &quot;lcx_query_element_not_found IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_join_error IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_join_error IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    me-&gt;v_index = i_index.
    me-&gt;v_field = i_field.
    me-&gt;v_message = i_message.
  ENDMETHOD.                    &quot;constructor

  METHOD get_index.
    return = me-&gt;v_index.
  ENDMETHOD.                    &quot;get_index
  METHOD get_field.
    return = me-&gt;v_field.
  ENDMETHOD.                    &quot;get_field
  METHOD get_message.
    return = me-&gt;v_message.
  ENDMETHOD.                    &quot;get_message

ENDCLASS.                    &quot;lcx_join_error IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_report IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_report IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_report_name.
    me-&gt;v_report_name = i_report_name.
  ENDMETHOD.                    &quot;set_report_name
  METHOD get_report_name.
    return = me-&gt;v_report_name.
  ENDMETHOD.                    &quot;get_report_name
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_report_name( i_report_name ).
  ENDMETHOD.                    &quot;constructor

  METHOD get_source.
    return = me-&gt;t_source.
  ENDMETHOD.                    &quot;get_source

  METHOD add_source.
    APPEND i_line TO me-&gt;t_source.
  ENDMETHOD.                    &quot;add_source

  METHOD check_syntax.
    DATA: t_program TYPE salv_wd_t_string,
          l_error   TYPE string,
          l_line    TYPE i,
          l_word    TYPE string.

    IF i_source IS INITIAL.
      t_program = me-&gt;t_source.
    ELSE.
      t_program = i_source.
    ENDIF.

    SYNTAX-CHECK FOR t_program MESSAGE l_error LINE l_line WORD l_word. &quot;#EC *

    IF sy-subrc = 4.
      RAISE EXCEPTION TYPE lcx_error_query_check EXPORTING i_message = l_error.
    ENDIF.

  ENDMETHOD.                    &quot;check_syntax

  METHOD add_report_name.
    DATA: l_report TYPE string.
    CONCATENATE &apos;REPORT &apos; me-&gt;v_report_name &apos;.&apos; INTO l_report RESPECTING BLANKS.
    me-&gt;add_source( l_report ).
  ENDMETHOD.                    &quot;add_report_name

  METHOD generate_report.
    DATA: BEGIN OF syn_msg,
                   l1(72),
                   l2(72),
                   l3(72),
          END OF syn_msg.
    DATA: syn_lin TYPE i, syn_wrd(30).                      &quot;#EC NEEDED
    DATA: l_report TYPE progname,
          l_message TYPE string.

    l_report = return = me-&gt;v_report_name.

    INSERT REPORT l_report FROM me-&gt;t_source.
*    GENERATE REPORT me-&gt;t_source
*    GENERATE SUBROUTINE POOL me-&gt;t_source
*                        NAME return
*                     MESSAGE syn_msg
*                        LINE syn_lin
*                        WORD syn_wrd.

    IF NOT sy-subrc IS INITIAL.
      CONCATENATE syn_msg-l1 syn_msg-l2 syn_msg-l3 INTO l_message SEPARATED BY space.
      CONDENSE l_message.
      RAISE EXCEPTION TYPE lcx_error_query_check EXPORTING i_message = l_message.
    ENDIF.

  ENDMETHOD.                    &quot;generate_subroutine

  METHOD execute_report.
    PERFORM (i_form_name) IN PROGRAM (i_report_name).
  ENDMETHOD.                    &quot;execute_subroutine

  METHOD delete_comments.
    DATA: t_text TYPE salv_wd_t_string,
          l_offset TYPE sy-fdpos.
    FIELD-SYMBOLS &lt;fs_text&gt; TYPE string.

    t_text = i_text.
    DELETE t_text WHERE table_line IS INITIAL.
    LOOP AT t_text ASSIGNING &lt;fs_text&gt;.
      IF &lt;fs_text&gt;(1) = lcl_commands=&gt;asterisk.
        DELETE t_text.
      ELSE.
        FIND &apos;&quot;&apos; IN &lt;fs_text&gt; MATCH OFFSET l_offset.
        IF sy-subrc IS INITIAL.
          &lt;fs_text&gt; = &lt;fs_text&gt;(l_offset).
        ENDIF.
      ENDIF.
    ENDLOOP.

    i_text = t_text.

  ENDMETHOD.                    &quot;delete_comments

  METHOD compute_apostrophes.
    DATA: l_on     TYPE boolean,
          l_length TYPE i,
          l_index  TYPE i.

    l_length = STRLEN( i_text ).

    DO l_length TIMES.
      l_index = sy-index - 1.

      IF i_text+l_index(1) CA cl_abap_char_utilities=&gt;get_simple_spaces_for_cur_cp( )  AND
         l_on = abap_true.
        ADD 1 TO l_index.
        IF i_text+l_index(1) = &apos;&apos;&apos;&apos;.
          CONTINUE.
        ENDIF.

      ELSEIF i_text+l_index(1) = &apos;&apos;&apos;&apos; AND l_on = abap_false.
        l_on = abap_true.

      ELSEIF i_text+l_index(1) = &apos;&apos;&apos;&apos; AND l_on = abap_true.
        l_on = abap_false.
      ENDIF.

      CONCATENATE return i_text+l_index(1) INTO return RESPECTING BLANKS.
    ENDDO.

  ENDMETHOD.                    &quot;compute_apostrophes

  METHOD delete_report.
    DATA: l_report TYPE progname.
    l_report = i_report_name.
    DELETE REPORT l_report.
  ENDMETHOD.                    &quot;delete_report

ENDCLASS.                    &quot;lcl_report IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_fieldcat IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_fieldcat IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_fieldcat.
    me-&gt;t_fieldcat = i_fieldcat.
  ENDMETHOD.                    &quot;set_fieldcat
  METHOD get_fieldcat.
    return = me-&gt;t_fieldcat.
  ENDMETHOD.                    &quot;get_fieldcat
  &quot;$. Endregion Getters and Setters

  METHOD constructor.
    me-&gt;set_fieldcat( i_fieldcat ).
  ENDMETHOD.                    &quot;constructor

  METHOD add_field_to_fcat.
    IF NOT i_fieldcat_tab IS INITIAL.
      APPEND LINES OF i_fieldcat_tab TO me-&gt;t_fieldcat.
    ELSEIF NOT i_fieldcat IS INITIAL.
      APPEND i_fieldcat TO me-&gt;t_fieldcat.
    ELSE.
      FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.
      APPEND INITIAL LINE TO me-&gt;t_fieldcat ASSIGNING &lt;fs_fcat&gt;.
      &lt;fs_fcat&gt;-fieldname  = i_fieldname.
      &lt;fs_fcat&gt;-scrtext_s = &lt;fs_fcat&gt;-scrtext_m = &lt;fs_fcat&gt;-scrtext_l = i_scrtext.
      &lt;fs_fcat&gt;-coltext    = i_descr.
      &lt;fs_fcat&gt;-edit       = i_edit.
      &lt;fs_fcat&gt;-outputlen  = i_outputlen.
      &lt;fs_fcat&gt;-inttype    = i_inttype.
      &lt;fs_fcat&gt;-intlen     = i_intlen.
      &lt;fs_fcat&gt;-drdn_hndl  = i_drop_down.
      &lt;fs_fcat&gt;-drdn_alias = i_drop_alias.
      &lt;fs_fcat&gt;-drdn_field = i_drdn_field.
      &lt;fs_fcat&gt;-checkbox   = i_checkbox.
      &lt;fs_fcat&gt;-icon       = i_icon.
      &lt;fs_fcat&gt;-hotspot    = i_hotspot.
      &lt;fs_fcat&gt;-just       = i_just.
      &lt;fs_fcat&gt;-f4availabl = i_f4_avaliable.
      &lt;fs_fcat&gt;-checktable = i_checktable.
      UNASSIGN &lt;fs_fcat&gt;.
    ENDIF.
  ENDMETHOD.                    &quot;add_field_to_fcat

  METHOD merge_fieldcat.
    DATA: t_fcat TYPE lvc_t_fcat,
          l_name TYPE dd02l-tabname.

    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.

    l_name = i_table-&gt;get_name( ).

    CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
      EXPORTING
        i_buffer_active        = abap_false
        i_structure_name       = l_name
        i_bypassing_buffer     = abap_true
      CHANGING
        ct_fieldcat            = t_fcat
      EXCEPTIONS
        inconsistent_interface = 1
        program_error          = 2
        OTHERS                 = 3.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE lcx_no_fieldcat.
    ENDIF.

    LOOP AT t_fcat ASSIGNING &lt;fs_fcat&gt;.
      &lt;fs_fcat&gt;-no_out = &lt;fs_fcat&gt;-tech = abap_false.
      &lt;fs_fcat&gt;-ref_field = &lt;fs_fcat&gt;-fieldname.
      &lt;fs_fcat&gt;-no_convext = i_no_conversion.
    ENDLOOP.

    return = t_fcat.
  ENDMETHOD.                    &quot;merge_fieldcat_by_struct_name

  METHOD inverse_fieldcat_names.

    DATA: t_fcat TYPE lvc_t_fcat.
    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.

    i_alv-&gt;get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = t_fcat ).

    LOOP AT t_fcat ASSIGNING &lt;fs_fcat&gt;.
      IF &lt;fs_fcat&gt;-coltext IS INITIAL.
        &lt;fs_fcat&gt;-coltext = &lt;fs_fcat&gt;-fieldname.
      ELSE.
        CLEAR &lt;fs_fcat&gt;-coltext.
      ENDIF.
    ENDLOOP.

    i_alv-&gt;set_frontend_fieldcatalog( t_fcat ).
    i_alv-&gt;refresh_table_display( ).
    return = t_fcat.
  ENDMETHOD.                    &quot;inverse_fieldcat_names

  METHOD no_routine_conversion.

    DATA: t_fcat TYPE lvc_t_fcat.
    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.

    i_alv-&gt;get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = t_fcat ).

    LOOP AT t_fcat ASSIGNING &lt;fs_fcat&gt;.
      IF &lt;fs_fcat&gt;-no_convext = abap_true.
        CLEAR &lt;fs_fcat&gt;-no_convext.
      ELSE.
        &lt;fs_fcat&gt;-no_convext = abap_true.
      ENDIF.
    ENDLOOP.

*    i_alv-&gt;set_frontend_fieldcatalog( t_fcat ).
*    i_alv-&gt;refresh_table_display( ).
    return = t_fcat.
  ENDMETHOD.                    &quot;no_routine_conversion

  METHOD compute_fieldcat_to_fields.
    DATA: o_table      TYPE REF TO lcl_table,
          t_fields     TYPE TABLE OF REF TO lcl_field,
          t_fcat       TYPE lvc_t_fcat,

          wa_fcat      TYPE lvc_s_fcat,

          l_table_name TYPE string,
          l_name       TYPE string,
          l_descr      TYPE string.

    FIELD-SYMBOLS: &lt;fs_field&gt; TYPE REF TO lcl_field,
                   &lt;fs_fcat&gt;  TYPE lvc_s_fcat.

    i_select-&gt;get_fields( IMPORTING return = t_fields ).
    t_fcat = me-&gt;get_fieldcat( ). CLEAR me-&gt;t_fieldcat.

    LOOP AT t_fields ASSIGNING &lt;fs_field&gt;.
      CLEAR: wa_fcat, l_name, l_table_name.
      l_name       = &lt;fs_field&gt;-&gt;get_field_name( ).
      l_table_name = &lt;fs_field&gt;-&gt;get_table_name( ).

      IF &lt;fs_field&gt;-&gt;get_count_field( ) = abap_true.
        IF &lt;fs_field&gt;-&gt;get_field_name( ) = lcl_commands=&gt;asterisk.
          me-&gt;add_field_to_fcat( i_fieldname  = &apos;COUNT&apos;
                                 i_scrtext    = &apos;Count&apos;
                                 i_inttype    = &apos;I&apos; ).
        ELSE.
          TRY.
              wa_fcat = me-&gt;get_fieldcat_struct( i_field_name = l_name
                                                 i_table_name = l_table_name
                                                 i_from       = i_from
                                                 i_fieldcat   = t_fcat ).

              CONCATENATE &apos;COUNT&apos; wa_fcat-fieldname INTO l_name SEPARATED BY &apos;_&apos;.
              l_descr = wa_fcat-scrtext_l.
              me-&gt;add_field_to_fcat( i_fieldname  = l_name
                                     i_scrtext    = l_descr
                                     i_inttype    = &apos;I&apos; ).
            CATCH lcx_table_not_found.                   &quot;#EC NO_HANDLE
          ENDTRY.

        ENDIF.

      ELSEIF &lt;fs_field&gt;-&gt;get_field_name( ) = lcl_commands=&gt;asterisk.
        me-&gt;add_field_to_fcat( t_fcat ).

      ELSE.
        wa_fcat = me-&gt;get_fieldcat_struct( i_field_name = l_name
                                           i_table_name = l_table_name
                                           i_from       = i_from
                                           i_fieldcat   = t_fcat ).
        me-&gt;add_field_to_fcat( i_fieldcat = wa_fcat ).

      ENDIF.

    ENDLOOP.

    me-&gt;adjust_column_positions( ).

  ENDMETHOD.                    &quot;compute_fieldcat_to_fields

  METHOD get_fieldcat_struct.
    DATA: o_table TYPE REF TO lcl_table,
          l_table TYPE string.
    IF NOT i_table_name IS INITIAL.
      o_table = i_from-&gt;get_table( i_table = i_table_name ).
      l_table = o_table-&gt;get_name( ).
      READ TABLE i_fieldcat INTO return WITH KEY fieldname = i_field_name
                                                 ref_table = l_table.
    ELSE.
      READ TABLE i_fieldcat INTO return WITH KEY fieldname = i_field_name.
    ENDIF.
  ENDMETHOD.                    &quot;get_fieldcat_struct

  METHOD adjust_column_positions.
    FIELD-SYMBOLS &lt;fs_fcat&gt; TYPE lvc_s_fcat.
    LOOP AT me-&gt;t_fieldcat ASSIGNING &lt;fs_fcat&gt;.
      &lt;fs_fcat&gt;-col_pos = sy-tabix.
    ENDLOOP.
  ENDMETHOD.                    &quot;adjust_column_positions

  METHOD get_fieldcat_count_fields.
    DESCRIBE TABLE me-&gt;t_fieldcat LINES return.
  ENDMETHOD.                    &quot;get_fieldcat_count_fields

ENDCLASS.                    &quot;lcl_fieldcat IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_600 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_600 IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_tabname.
    v_tabname = i_tabname.
  ENDMETHOD.                    &quot;set_tabname
  METHOD get_tabname.
    return = v_tabname.
  ENDMETHOD.                    &quot;get_tabname

  METHOD set_tabalias.
    v_tabalias = i_tabalias.
  ENDMETHOD.                    &quot;set_tabalias
  METHOD get_tabalias.
    return = v_tabalias.
  ENDMETHOD.                    &quot;get_tabalias

  METHOD set_tabdescr.
    v_tabdescr = i_descr.
  ENDMETHOD.                    &quot;set_tabdescr
  METHOD get_tabdescr.
    return = v_tabdescr.
  ENDMETHOD.                    &quot;get_tabdescr

  METHOD set_join_tables.
    me-&gt;t_join_tables = i_join_tables.
  ENDMETHOD.                    &quot;set_join_tables
  METHOD get_join_tables.
    FIELD-SYMBOLS &lt;fs_join_table&gt; TYPE ty_join_table.
    INSERT INITIAL LINE INTO me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt; INDEX 1.
    &lt;fs_join_table&gt;-tabname = me-&gt;get_tabname( ).
    &lt;fs_join_table&gt;-alias   = me-&gt;get_tabalias( ).
    UNASSIGN &lt;fs_join_table&gt;.
    e_join_tables = me-&gt;t_join_tables.
  ENDMETHOD.                    &quot;get_join_tables

  METHOD get_create_select.
    return = v_create_select.
  ENDMETHOD.                    &quot;get_create_select
  METHOD get_create_where.
    return = v_create_where.
  ENDMETHOD.                    &quot;get_create_where

  METHOD set_block_flags.
    me-&gt;v_block_flags = i_block.
  ENDMETHOD.                    &quot;set_block_flags
  METHOD get_block_flags.
    return = me-&gt;v_block_flags.
  ENDMETHOD.                    &quot;get_block_flags

  METHOD set_direct_initialize.
    me-&gt;v_direct_initialize = i_direct_initialize.
  ENDMETHOD.                    &quot;set_direct_initialize
  &quot;$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    DATA: o_error   TYPE REF TO lcx_join_error,
          l_message TYPE string.

    TRY.
        super-&gt;user_command( i_ucomm ).
        CASE i_ucomm.
          WHEN c_tabname.
            me-&gt;check_table_name( ).
            me-&gt;initialize_join_grid( ).

          WHEN c_tabalias.
            me-&gt;check_table_alias( ).

          WHEN c_save.
            IF me-&gt;o_alv IS BOUND.
              me-&gt;o_alv-&gt;check_changed_data( ).
            ENDIF.
            me-&gt;check_join_tables( abap_true ).
            LEAVE TO SCREEN 0.

        ENDCASE.

      CATCH lcx_table_not_found.
        l_message = &apos;Table is unknown!&apos;.
        lcl_message=&gt;report_message( i_msg  = l_message
                                     i_type = &apos;E&apos; ).

      CATCH lcx_table_alias.
        lcl_message=&gt;report_message( i_msg  = &apos;Table alias invalid!&apos;
                                     i_type = &apos;E&apos; ).

      CATCH lcx_join_error INTO o_error.
        DATA: wa_row_id    TYPE lvc_s_row,
              wa_column_id TYPE lvc_s_col,
              wa_row_no    TYPE lvc_s_roid .
        l_message = o_error-&gt;get_message( ).
        wa_row_no-row_id = wa_row_id-index = o_error-&gt;get_index( ).
        wa_column_id-fieldname = o_error-&gt;get_field( ).
        me-&gt;o_alv-&gt;set_current_cell_via_id( is_row_id    = wa_row_id
                                            is_column_id = wa_column_id
                                            is_row_no    = wa_row_no ).
        lcl_message=&gt;report_message( i_msg     = l_message
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
    ENDTRY.

  ENDMETHOD.                    &quot;lif_screen~user_command

  METHOD lif_screen~initialize_screen.
    LOOP AT SCREEN.
      IF screen-name = &apos;V_CREATE_SELECT&apos; OR screen-name = &apos;V_CREATE_WHERE&apos;.
        IF me-&gt;get_block_flags( ) = abap_true.
          screen-input = 0.
        ELSE.
          screen-input = 1.
        ENDIF.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

    IF me-&gt;v_direct_initialize = abap_true AND me-&gt;o_container IS INITIAL.
      me-&gt;initialize_container( ).
      me-&gt;initialize_alv( ).
      CLEAR me-&gt;v_direct_initialize.
    ENDIF.

  ENDMETHOD.                    &quot;lif_screen~initialize_screen

  METHOD lif_screen~screen_status.
    SET PF-STATUS &apos;PF_0600&apos;.
  ENDMETHOD.                    &quot;lif_screen~screen_status

  METHOD check_table_name.
    DATA: o_table   TYPE REF TO lcl_table,
          l_tabname TYPE string,
          l_descr   TYPE string.

    l_tabname = me-&gt;get_tabname( ).
    IF lcl_table=&gt;check_table_name( l_tabname ) = abap_false.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

    me-&gt;flush( abap_true ).

    CREATE OBJECT o_table
      EXPORTING
        i_name = l_tabname.
    l_descr = o_table-&gt;get_description_from_ddic( ).
    me-&gt;set_tabname( l_tabname ).
    me-&gt;set_tabdescr( l_descr ).

  ENDMETHOD.                    &quot;check_table_name

  METHOD check_table_alias.
    DATA: l_tabalias TYPE string.
    l_tabalias = me-&gt;get_tabalias( ).
    IF l_tabalias CO &apos;0123456789 &apos;.
      RAISE EXCEPTION TYPE lcx_table_alias.
    ENDIF.
  ENDMETHOD.                    &quot;check_table_alias

  METHOD initialize_join_grid.
    IF me-&gt;o_container IS INITIAL.
      me-&gt;initialize_container( ).
      me-&gt;initialize_alv( ).
    ENDIF.
  ENDMETHOD.                    &quot;initialize_join_grid

  METHOD initialize_container.
    CREATE OBJECT me-&gt;o_container
      EXPORTING
        container_name = &apos;CONTAINER_FROM&apos;.
  ENDMETHOD.                    &quot;initialize_container

  METHOD initialize_alv.
    DATA: t_exclude  TYPE ui_functions,
          t_fieldcat TYPE lvc_t_fcat,
          t_dropdown TYPE lvc_t_dral,
          t_f4       TYPE lvc_t_f4,

          wa_layout  TYPE lvc_s_layo.

    CREATE OBJECT me-&gt;o_alv
      EXPORTING
        i_parent = me-&gt;o_container.

    CREATE OBJECT me-&gt;o_handler.
    SET HANDLER: me-&gt;o_handler-&gt;handle_user_command_from_gen FOR me-&gt;o_alv,
                 me-&gt;o_handler-&gt;handle_toolbar_from_gen      FOR me-&gt;o_alv,
                 me-&gt;o_handler-&gt;handle_hotspot_from_gen      FOR me-&gt;o_alv,
                 me-&gt;o_handler-&gt;handle_f4_from_gen           FOR me-&gt;o_alv.

    t_exclude  = me-&gt;exclude_functions( ).
    t_fieldcat = me-&gt;get_fieldcat( ).
    t_dropdown = me-&gt;get_drop_down( ).
    t_f4       = me-&gt;get_f4_fields( ).
    wa_layout-stylefname = &apos;STYLE&apos;.

    me-&gt;o_alv-&gt;set_ready_for_input( 1 ).
    me-&gt;o_alv-&gt;set_drop_down_table( it_drop_down_alias = t_dropdown ).
    me-&gt;o_alv-&gt;register_f4_for_fields( t_f4 ).

    me-&gt;o_alv-&gt;set_table_for_first_display( EXPORTING
                                              is_layout            = wa_layout
                                              it_toolbar_excluding = t_exclude
                                            CHANGING
                                              it_outtab            = me-&gt;t_join_tables
                                              it_fieldcatalog      = t_fieldcat ).
    me-&gt;o_alv-&gt;set_focus( me-&gt;o_container ).

  ENDMETHOD.                    &quot;initialize_alv

  METHOD refresh_alv.
    me-&gt;o_alv-&gt;refresh_table_display( is_stable      = i_stable
                                      i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    &quot;refresh_alv

  METHOD add_option_to_drop_down.
    FIELD-SYMBOLS &lt;fs_drop_down&gt; TYPE lvc_s_dral.
    APPEND INITIAL LINE TO e_drop_down ASSIGNING &lt;fs_drop_down&gt;.
    &lt;fs_drop_down&gt;-handle    = i_handle.
    &lt;fs_drop_down&gt;-value     = i_value.
    &lt;fs_drop_down&gt;-int_value = i_int_value.
    UNASSIGN &lt;fs_drop_down&gt;.
  ENDMETHOD.                    &quot;add_option_to_drop_down

  METHOD get_drop_down.
    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;join
                                   i_int_value = lcl_commands=&gt;join
                                 CHANGING
                                   e_drop_down = return ).

    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;inner_join_command
                                   i_int_value = lcl_commands=&gt;inner_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;outer_join_command
                                   i_int_value = lcl_commands=&gt;outer_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;left_join_command
                                   i_int_value = lcl_commands=&gt;left_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me-&gt;add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=&gt;right_join_command
                                   i_int_value = lcl_commands=&gt;right_join_command
                                 CHANGING
                                   e_drop_down = return ).
  ENDMETHOD.                    &quot;get_drop_down

  METHOD get_fieldcat.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat.
    CREATE OBJECT o_fieldcat.
    o_fieldcat-&gt;add_field_to_fcat( i_fieldname    = &apos;TABNAME&apos;
                                   i_edit         = abap_true
                                   i_descr        = &apos;Table Name&apos;
                                   i_f4_avaliable = abap_true
                                   i_outputlen    = 20 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;ALIAS&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Table Alias&apos;
                                   i_outputlen  = 10 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;JOIN_KIND&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Kind of Join&apos;
                                   i_outputlen  = 20
                                   i_drop_down  = 1
                                   i_drop_alias = abap_true ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;ICON&apos;
                                   i_edit       = abap_false
                                   i_descr      = &apos;Join Fields&apos;
                                   i_outputlen  = 11
                                   i_icon       = abap_true
                                   i_hotspot    = abap_true ).

    return = o_fieldcat-&gt;get_fieldcat( ).
  ENDMETHOD.                    &quot;get_fieldcat

  METHOD flush.
    IF NOT me-&gt;o_container IS INITIAL.
      me-&gt;o_alv-&gt;free( ).
      me-&gt;o_container-&gt;free( ).
    ENDIF.

    CLEAR: v_tabname, v_tabdescr, me-&gt;o_container, me-&gt;o_alv, me-&gt;t_join_tables.

    IF i_no_flags = abap_false.
      CLEAR: v_create_select, v_create_where, v_tabalias.
    ENDIF.

  ENDMETHOD.                    &quot;flush

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    &quot;exclude_functions

  METHOD add_line.
    FIELD-SYMBOLS &lt;fs_join_table&gt; TYPE ty_join_table.
    APPEND INITIAL LINE TO me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt;.
    &lt;fs_join_table&gt;-icon = icon_enter_more.
    UNASSIGN &lt;fs_join_table&gt;.
  ENDMETHOD.                    &quot;add_line

  METHOD delete_line.
    DATA: t_index_rows  TYPE lvc_t_row,
          t_aux         TYPE tyt_join_table,
          l_answer      TYPE c.

    FIELD-SYMBOLS: &lt;fs_index_row&gt; TYPE lvc_s_row,
                   &lt;fs_aux&gt;       TYPE ty_join_table.

    me-&gt;o_alv-&gt;get_selected_rows( IMPORTING et_index_rows	= t_index_rows ).
    IF t_index_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    l_answer = lcl_message=&gt;user_choice( i_title    = &apos;Delete join tables&apos;
                                         i_question = &apos;Delete selected lines?&apos;
                                         i_option_1 = &apos;Yes&apos;
                                         i_option_2 = &apos;No&apos;
                                         i_icon     = &apos;@M_QUES@&apos; ).
    CHECK l_answer = &apos;1&apos;.

    LOOP AT t_index_rows ASSIGNING &lt;fs_index_row&gt;.
      READ TABLE me-&gt;t_join_tables ASSIGNING &lt;fs_aux&gt; INDEX &lt;fs_index_row&gt;-index.
      IF sy-subrc IS INITIAL.
        APPEND &lt;fs_aux&gt; TO t_aux.
      ENDIF.
    ENDLOOP.

    LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
      DELETE me-&gt;t_join_tables WHERE tabname = &lt;fs_aux&gt;-tabname.
    ENDLOOP.

  ENDMETHOD.                    &quot;delete_line

  METHOD suggest_join.
    DATA: t_tables TYPE dd05mttyp,
          l_tabname TYPE string.

    IF NOT me-&gt;t_join_tables IS INITIAL.
      DATA: l_answer TYPE c.
      l_answer = lcl_message=&gt;user_choice( i_question = &apos;Are you sure you want a suggested join?&apos;
                                           i_option_1 = &apos;Yes&apos;
                                           i_option_2 = &apos;No&apos; ).
      IF l_answer &lt;&gt; &apos;1&apos;.
        RETURN.
      ENDIF.
    ENDIF.

    CLEAR me-&gt;t_join_tables.
    l_tabname = me-&gt;get_tabname( ).
    t_tables = me-&gt;get_related_tables( l_tabname ).
    me-&gt;compute_related_tables( t_tables ).

  ENDMETHOD.                    &quot;suggest_join

  METHOD get_related_tables.
    DATA: l_name TYPE dcobjdef-name.
    l_name = i_tabname.
    CALL FUNCTION &apos;DD_FKEYS_GET&apos;
      EXPORTING
        name           = l_name
        langu          = sy-langu
      TABLES
        dd05m_tab      = return
      EXCEPTIONS
        illegal_input  = 1
        not_found      = 2
        expand_failure = 3
        OTHERS         = 4.
  ENDMETHOD.                    &quot;get_related_tables

  METHOD compute_related_tables.
    DATA: t_aux         TYPE dd05mttyp,
          t_join_fields TYPE dd05mttyp,
          o_join_fields TYPE REF TO lcl_join_fields,
          wa_table      TYPE dd05m.

    FIELD-SYMBOLS: &lt;fs_table&gt;      TYPE dd05m,
                   &lt;fs_aux&gt;        TYPE dd05m,
                   &lt;fs_join_field&gt; TYPE dd05m,
                   &lt;fs_join_table&gt; TYPE ty_join_table.

    t_aux = i_tables.

    SORT t_aux BY checktable.
    DELETE ADJACENT DUPLICATES FROM t_aux COMPARING checktable.

    LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
      CLEAR o_join_fields.
      CREATE OBJECT o_join_fields.
      LOOP AT i_tables ASSIGNING &lt;fs_table&gt; WHERE checktable = &lt;fs_aux&gt;-checktable.
        o_join_fields-&gt;add_join_field( i_fortable   = &lt;fs_table&gt;-checktable
                                       i_forkey     = &lt;fs_table&gt;-checkfield
                                       i_checktable = &lt;fs_table&gt;-fortable
                                       i_checkfield = &lt;fs_table&gt;-forkey ).
      ENDLOOP.

      APPEND INITIAL LINE TO me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt;.
      &lt;fs_join_table&gt;-tabname     = &lt;fs_aux&gt;-checktable.
      &lt;fs_join_table&gt;-join_kind   = lcl_commands=&gt;inner_join_command.
      &lt;fs_join_table&gt;-icon        = icon_display_more.
      &lt;fs_join_table&gt;-join_fields = o_join_fields.
      &lt;fs_join_table&gt;-style       = me-&gt;get_block_style_for_join_table( ).
      UNASSIGN &lt;fs_join_table&gt;.
    ENDLOOP.

  ENDMETHOD.                    &quot;compute_related_tables

  METHOD get_block_style_for_join_table.
    me-&gt;add_style( EXPORTING
                     i_fieldname = &apos;TABNAME&apos;
                     i_style = cl_gui_alv_grid=&gt;mc_style_disabled
                   CHANGING
                     e_style = return ).
  ENDMETHOD.                    &quot;get_block_style_for_join_table

  METHOD add_style.
    DATA: wa_style TYPE lvc_s_styl.
    wa_style-fieldname = i_fieldname.
    wa_style-style     = i_style.
    APPEND wa_style TO e_style.
  ENDMETHOD.                    &quot;add_style

  METHOD open_join_fields.
    DATA: o_screen     TYPE REF TO lcl_screen_700,
          o_error      TYPE REF TO lcx_join_error,
          l_index      TYPE i,
          l_join_table TYPE string,
          t_tables     TYPE salv_wd_t_string.

    FIELD-SYMBOLS &lt;fs_join_table&gt; TYPE ty_join_table.

    me-&gt;o_alv-&gt;check_changed_data( ).
    l_index = i_index.

    TRY.
        me-&gt;check_join_tables( ).

        READ TABLE me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt; INDEX i_index.
        IF sy-subrc IS INITIAL.
          l_join_table = &lt;fs_join_table&gt;-tabname.
          t_tables = me-&gt;get_tables( ).

          o_screen ?= lcl_screen=&gt;get_instance( 700 ).
          o_screen-&gt;flush( ).
          o_screen-&gt;set_join_table( l_join_table ).
          o_screen-&gt;consist_tables( t_tables ).
          o_screen-&gt;set_join_fields( &lt;fs_join_table&gt;-join_fields ).
          o_screen-&gt;show( i_first_col = 20
                          i_first_row = 5
                          i_last_col  = 115
                          i_last_row  = 15 ).

          CHECK o_screen-&gt;get_exit_command( ) = abap_false.
          &lt;fs_join_table&gt;-join_fields = o_screen-&gt;get_join_fields( ).
          IF &lt;fs_join_table&gt;-join_fields IS BOUND.
            &lt;fs_join_table&gt;-icon = icon_display_more.
          ELSE.
            &lt;fs_join_table&gt;-icon = icon_enter_more.
          ENDIF.

          DATA: wa_stable TYPE lvc_s_stbl.
          wa_stable-col = abap_true. wa_stable-row = abap_true.
          me-&gt;refresh_alv( i_stable       = wa_stable
                           i_soft_refresh = abap_true ).

        ENDIF.

      CATCH lcx_join_error INTO o_error.
        DATA: l_message    TYPE string,
              wa_row_id    TYPE lvc_s_row,
              wa_column_id TYPE lvc_s_col,
              wa_row_no    TYPE lvc_s_roid .
        l_message = o_error-&gt;get_message( ).
        wa_row_no-row_id = wa_row_id-index = o_error-&gt;get_index( ).
        wa_column_id-fieldname = o_error-&gt;get_field( ).
        me-&gt;o_alv-&gt;set_current_cell_via_id( is_row_id    = wa_row_id
                                            is_column_id = wa_column_id
                                            is_row_no    = wa_row_no ).
        lcl_message=&gt;report_message( i_msg     = l_message
                                     i_type    = &apos;S&apos;
                                     i_disp_as = &apos;E&apos; ).
    ENDTRY.

  ENDMETHOD.                    &quot;open_join_fields

  METHOD search_help_for_tabname.
    DATA: t_return_tab TYPE TABLE OF ddshretval,
          wa_stable	      TYPE lvc_s_stbl.
    FIELD-SYMBOLS: &lt;fs_return&gt; TYPE ddshretval,
                   &lt;fs_join_table&gt; TYPE ty_join_table.

    CALL FUNCTION &apos;F4IF_FIELD_VALUE_REQUEST&apos;
      EXPORTING
        tabname           = space
        fieldname         = space
        searchhelp        = &apos;DD_DBTB_16&apos;
        shlpparam         = &apos;TABNAME&apos;
      TABLES
        return_tab        = t_return_tab
      EXCEPTIONS
        field_not_found   = 1
        no_help_for_field = 2
        inconsistent_help = 3
        no_values_found   = 4
        OTHERS            = 5.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.

    READ TABLE t_return_tab ASSIGNING &lt;fs_return&gt; INDEX 1.
    IF sy-subrc IS INITIAL.
      READ TABLE me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt; INDEX i_index.
      IF sy-subrc IS INITIAL.
        &lt;fs_join_table&gt;-tabname = &lt;fs_return&gt;-fieldval.

        wa_stable-row = abap_true. wa_stable-col = abap_true.
        me-&gt;refresh_alv( i_stable       = wa_stable
                         i_soft_refresh = abap_true ).

      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;search_help_for_tabname

  METHOD get_f4_fields.
    DATA: wa_f4 TYPE lvc_s_f4.
    wa_f4-fieldname = &apos;TABNAME&apos;.
    wa_f4-register  = abap_true.
    APPEND wa_f4 TO return.
  ENDMETHOD.                    &quot;get_f4_fields

  METHOD check_join_tables.
    FIELD-SYMBOLS &lt;fs_join_table&gt; TYPE ty_join_table.
    IF NOT i_index IS INITIAL.
      READ TABLE me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt; INDEX i_index.
      IF sy-subrc IS INITIAL.
        me-&gt;consist_join_table( i_join_table          = &lt;fs_join_table&gt;
                                i_index               = i_index
                                i_consist_join_fields = i_consist_join_fields ).
      ENDIF.
    ELSE.
      LOOP AT me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt;.
        me-&gt;consist_join_table( i_join_table          = &lt;fs_join_table&gt;
                                i_index               = sy-tabix
                                i_consist_join_fields = i_consist_join_fields ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;check_join_tables

  METHOD consist_join_table.
    DATA: l_message TYPE string,
          l_field   TYPE string.

    IF i_join_table-tabname IS INITIAL.
      l_message = &apos;Table name is required.&apos;. l_field = &apos;TABNAME&apos;.

    ELSEIF lcl_table=&gt;check_table_name( i_join_table-tabname ) = abap_false.
      CONCATENATE &apos;Table&apos; i_join_table-tabname &apos;is unknown.&apos; INTO l_message SEPARATED BY space.
      l_field = &apos;TABNAME&apos;.

    ELSEIF i_join_table-join_kind IS INITIAL.
      l_message = &apos;Kind of join is required.&apos;.
      l_field = &apos;JOIN_KIND&apos;.

    ELSEIF NOT i_join_table-alias IS INITIAL AND i_join_table-alias CO &apos;0123456789 &apos;.
      l_message = &apos;Table alias can not contain only numbers.&apos;.
      l_field = &apos;ALIAS&apos;.

    ELSEIF i_consist_join_fields = abap_true AND NOT i_join_table-join_fields IS BOUND.
      l_message = &apos;Join Fields is required.&apos;.
      l_field = &apos;JOIN_FIELDS&apos;.

    ENDIF.

    IF NOT l_message IS INITIAL.
      CONDENSE l_message.
      RAISE EXCEPTION TYPE lcx_join_error
        EXPORTING
          i_message = l_message
          i_field   = l_field
          i_index   = i_index.
    ENDIF.

  ENDMETHOD.                    &quot;consist_join_table

  METHOD get_tables.
    FIELD-SYMBOLS &lt;fs_join_table&gt; TYPE ty_join_table.

    APPEND v_tabname TO return.

    LOOP AT me-&gt;t_join_tables ASSIGNING &lt;fs_join_table&gt;.
      APPEND &lt;fs_join_table&gt;-tabname TO return.
    ENDLOOP.

  ENDMETHOD.                    &quot;get_tables

  METHOD build_join_tables.
    DATA: t_tables      TYPE TABLE OF REF TO lcl_table,
          t_join_tables TYPE tyt_join_table,
          t_join_fields TYPE tyt_join_fields,
          l_tabname     TYPE string,
          l_alias       TYPE string.

    FIELD-SYMBOLS: &lt;fs_table&gt; TYPE REF TO lcl_table,
                   &lt;fs_join_table&gt; TYPE ty_join_table.

    i_from-&gt;get_tables( IMPORTING e_tables = t_tables ).

    LOOP AT t_tables ASSIGNING &lt;fs_table&gt;.

      l_tabname = &lt;fs_table&gt;-&gt;get_name( ).
      l_alias = &lt;fs_table&gt;-&gt;get_alias( ).

      IF sy-tabix = 1. &quot;FROM Table
        me-&gt;set_tabname( l_tabname ).
        me-&gt;set_tabalias( l_alias ).

      ELSE. &quot;Join Tables
        APPEND INITIAL LINE TO t_join_tables ASSIGNING &lt;fs_join_table&gt;.
        &lt;fs_join_table&gt;-tabname     = &lt;fs_table&gt;-&gt;get_name( ).
        &lt;fs_join_table&gt;-alias       = &lt;fs_table&gt;-&gt;get_alias( ).
        &lt;fs_join_table&gt;-join_kind   = &lt;fs_table&gt;-&gt;get_join_kind( ).
        &lt;fs_join_table&gt;-icon        = icon_display_more.

        CREATE OBJECT &lt;fs_join_table&gt;-join_fields.
        &lt;fs_table&gt;-&gt;get_join_fields( IMPORTING e_join_fields = t_join_fields ).
        &lt;fs_join_table&gt;-join_fields-&gt;set_join_fields( t_join_fields ).
        &lt;fs_join_table&gt;-style = me-&gt;get_block_style_for_join_table( ).
        UNASSIGN &lt;fs_join_table&gt;.

      ENDIF.

    ENDLOOP.

    me-&gt;set_join_tables( t_join_tables ).

  ENDMETHOD.                    &quot;build_join_tables

ENDCLASS.                    &quot;lcl_screen_600 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_from_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_from_generator IMPLEMENTATION.

  METHOD generate.
    DATA: o_query          TYPE REF TO lcl_query,
          o_from           TYPE REF TO lcl_from,
          o_generator      TYPE REF TO lcl_query_element_generator,
          t_join_tables    TYPE tyt_join_table,
          t_select_command TYPE salv_wd_t_string,
          t_from_command   TYPE salv_wd_t_string,
          t_where_command  TYPE salv_wd_t_string.

    me-&gt;select_join_tables( IMPORTING e_join_tables = t_join_tables ).
    return = me-&gt;compute_join_tables( t_join_tables ).

    CREATE OBJECT o_query
      EXPORTING
        i_query = return.
    o_from ?= o_query-&gt;identify_query_elements( lcl_commands=&gt;from ).

    IF me-&gt;v_gen_select = abap_true.
      CREATE OBJECT o_generator
        TYPE
          lcl_select_generator
        EXPORTING
          i_element            = o_from.
      TRY.
          t_select_command = o_generator-&gt;generate( ).
          return = o_generator-&gt;generate_new_query_text( i_query        = return
                                                         i_command_text = t_select_command ).
        CATCH cx_dynamic_check.                          &quot;#EC NO_HANDLE
      ENDTRY.

    ENDIF.

    IF me-&gt;v_gen_where = abap_true.
      TRY .
          CREATE OBJECT o_generator
            TYPE
              lcl_where_generator
            EXPORTING
              i_element           = o_from.
          t_where_command = o_generator-&gt;generate( ).
          return = o_generator-&gt;generate_new_query_text( i_query        = return
                                                         i_command_text = t_where_command ).
        CATCH cx_dynamic_check.                          &quot;#EC NO_HANDLE
      ENDTRY.

    ENDIF.
  ENDMETHOD.                    &quot;generate

  METHOD generate_new_query_text.
    DATA: t_text        TYPE salv_wd_t_string,
          t_select      TYPE salv_wd_t_string,
          t_where       TYPE salv_wd_t_string,
          t_split       TYPE TABLE OF string,
          l_find        TYPE boolean,
          l_string      TYPE string,
          l_result      TYPE string,
          l_garbage     TYPE string,
          l_split       TYPE boolean,
          l_command     TYPE string,
          l_index       TYPE i.

    IF i_query IS INITIAL.
      APPEND LINES OF i_command_text TO return.

    ELSE.

      t_text = i_query.

      CLEAR: l_string, l_result.
      LOOP AT t_text INTO l_string.
        TRANSLATE l_string TO UPPER CASE.
        IF l_find = abap_false.
          CLEAR t_split.
          SPLIT l_string AT space INTO TABLE t_split.
          FIND lcl_commands=&gt;from IN TABLE t_split.
          IF sy-subrc IS INITIAL.
            SPLIT l_string AT lcl_commands=&gt;from INTO l_result l_garbage.
            APPEND l_result TO t_select.
            EXIT.
          ELSE.
            APPEND l_string TO t_select.
          ENDIF.
        ENDIF.
      ENDLOOP.

      LOOP AT t_text INTO l_string.
        TRANSLATE l_string TO UPPER CASE.
        IF l_find = abap_false.
          CLEAR t_split.
          SPLIT l_string AT space INTO TABLE t_split.
          CASE 0.
            WHEN me-&gt;find_command( i_command = lcl_commands=&gt;where  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=&gt;where.

            WHEN me-&gt;find_command( i_command = lcl_commands=&gt;up     i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=&gt;up.

            WHEN me-&gt;find_command( i_command = lcl_commands=&gt;order  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=&gt;order.

            WHEN me-&gt;find_command( i_command = lcl_commands=&gt;group  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=&gt;group.

            WHEN me-&gt;find_command( i_command = lcl_commands=&gt;having i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=&gt;having.

          ENDCASE.
        ENDIF.

        CHECK l_find = abap_true.

        SPLIT l_string AT l_command INTO l_result l_garbage.
        IF NOT l_garbage IS INITIAL.
          CONCATENATE l_command l_garbage INTO l_garbage SEPARATED BY space.
          CONDENSE l_garbage.
          APPEND l_garbage TO t_where.
        ELSE.
          IF NOT l_result IS INITIAL.
            CONDENSE l_result.
            APPEND l_result TO t_where.
          ELSE.
            APPEND l_command TO t_where.
          ENDIF.
        ENDIF.

      ENDLOOP.

      APPEND LINES OF t_select TO return.
      APPEND LINES OF i_command_text TO return.
      APPEND LINES OF t_where TO return.

    ENDIF.

  ENDMETHOD.                    &quot;generate_new_query_text

  METHOD select_join_tables.
    DATA: o_screen TYPE REF TO lcl_screen_600,
          o_from   TYPE REF TO lcl_from.

    o_screen ?= lcl_screen=&gt;get_instance( 600 ).
    o_screen-&gt;flush( ).

    o_from ?= me-&gt;get_query_element( ).
    IF o_from IS BOUND.
      o_screen-&gt;build_join_tables( o_from ).
      o_screen-&gt;set_block_flags( abap_true ).
      o_screen-&gt;set_direct_initialize( abap_true ).
    ELSE.
      o_screen-&gt;set_block_flags( abap_false ).
    ENDIF.

    o_screen-&gt;show( i_first_col = 10  i_first_row = 3
                    i_last_col  = 122 i_last_row  = 25 ).

    IF o_screen-&gt;get_exit_command( ) = abap_true.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    me-&gt;v_gen_select = o_screen-&gt;get_create_select( ).
    me-&gt;v_gen_where  = o_screen-&gt;get_create_where( ).

    o_screen-&gt;get_join_tables( IMPORTING e_join_tables = e_join_tables ).

  ENDMETHOD.                    &quot;select_join_tables

  METHOD compute_join_tables.
    DATA: o_join_fields TYPE REF TO lcl_join_fields,
          t_join_fields TYPE tyt_join_fields,
          t_aux         TYPE salv_wd_t_string,
          l_field_1     TYPE string,
          l_field_2     TYPE string,
          l_command     TYPE string.

    FIELD-SYMBOLS: &lt;fs_join_table&gt; TYPE ty_join_table,
                   &lt;fs_aux&gt;        TYPE ty_join_table,
                   &lt;fs_join_field&gt; TYPE ty_join_fields.

    READ TABLE i_join_tables ASSIGNING &lt;fs_join_table&gt; INDEX 1.
    IF sy-subrc IS INITIAL.
      CONCATENATE lcl_commands=&gt;from &lt;fs_join_table&gt;-tabname INTO l_command SEPARATED BY space.
      IF NOT &lt;fs_join_table&gt;-alias IS INITIAL.
        CONCATENATE l_command lcl_commands=&gt;as &lt;fs_join_table&gt;-alias INTO l_command SEPARATED BY space.
      ENDIF.
      CONDENSE l_command.
      APPEND l_command TO return.
    ENDIF.

    LOOP AT i_join_tables ASSIGNING &lt;fs_join_table&gt; FROM 2.
      CLEAR: l_command, t_join_fields.

      CONCATENATE &lt;fs_join_table&gt;-join_kind &lt;fs_join_table&gt;-tabname INTO l_command SEPARATED BY space.
      IF NOT &lt;fs_join_table&gt;-alias IS INITIAL.
        CONCATENATE l_command lcl_commands=&gt;as &lt;fs_join_table&gt;-alias INTO l_command SEPARATED BY space.
      ENDIF.

      o_join_fields = &lt;fs_join_table&gt;-join_fields.
      o_join_fields-&gt;get_join_fields( IMPORTING e_join_fields = t_join_fields ).
      LOOP AT t_join_fields ASSIGNING &lt;fs_join_field&gt;.
        CLEAR: l_field_1, l_field_2.

        IF sy-tabix = 1.
          CONCATENATE l_command lcl_commands=&gt;on INTO l_command SEPARATED BY space.
        ELSE.
          CONCATENATE l_command lcl_commands=&gt;and INTO l_command SEPARATED BY space.
        ENDIF.

        READ TABLE i_join_tables ASSIGNING &lt;fs_aux&gt; WITH KEY tabname = &lt;fs_join_field&gt;-fortable.
        IF sy-subrc IS INITIAL.
          IF NOT &lt;fs_aux&gt;-alias IS INITIAL.
            CONCATENATE &lt;fs_aux&gt;-alias &apos;~&apos; &lt;fs_join_field&gt;-forkey INTO l_field_1 RESPECTING BLANKS.
          ELSE.
            CONCATENATE &lt;fs_join_field&gt;-fortable &apos;~&apos; &lt;fs_join_field&gt;-forkey INTO l_field_1 RESPECTING BLANKS.
          ENDIF.
        ENDIF.

        IF &lt;fs_join_field&gt;-checktable IS INITIAL.
          l_field_2 = &lt;fs_join_field&gt;-checkfield.
        ELSE.
          READ TABLE i_join_tables ASSIGNING &lt;fs_aux&gt; WITH KEY tabname = &lt;fs_join_field&gt;-checktable.
          IF sy-subrc IS INITIAL.
            IF NOT &lt;fs_aux&gt;-alias IS INITIAL.
              CONCATENATE &lt;fs_aux&gt;-alias &apos;~&apos; &lt;fs_join_field&gt;-checkfield INTO l_field_2 RESPECTING BLANKS.
            ELSE.
              CONCATENATE &lt;fs_join_field&gt;-checktable &apos;~&apos; &lt;fs_join_field&gt;-checkfield INTO l_field_2 RESPECTING BLANKS.
            ENDIF.
          ENDIF.
        ENDIF.
        CONDENSE: l_field_1 NO-GAPS,
                  l_field_2 NO-GAPS.

        CONCATENATE l_command l_field_1 &lt;fs_join_field&gt;-signal l_field_2 INTO l_command SEPARATED BY space.

      ENDLOOP.

      CONDENSE l_command.
      t_aux = lcl_query=&gt;split_text( i_text      = l_command
                                     i_outputlen = 80 ).

      APPEND LINES OF t_aux TO return.

    ENDLOOP.

  ENDMETHOD.                    &quot;compute_join_tables

ENDCLASS.                    &quot;lcl_from_generator IMPLEMENTATION
*&amp;---------------------------------------------------------------------*
*&amp;       Class (Implementation)  lcl_screen_700
*&amp;---------------------------------------------------------------------*
CLASS lcl_screen_700 IMPLEMENTATION.

  &quot;$. Region Getters and Setters
  METHOD set_join_fields.
    IF i_join_fields IS BOUND.
      i_join_fields-&gt;get_join_fields( IMPORTING e_join_fields = me-&gt;t_join_fields ).
      me-&gt;compute_join_fields( ).
    ENDIF.
  ENDMETHOD.                    &quot;set_join_fields
  METHOD get_join_fields.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.
    IF NOT me-&gt;t_join_fields IS INITIAL.
      CREATE OBJECT return.
      LOOP AT me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt;.
        return-&gt;add_join_field( i_fortable   = &lt;fs_join_field&gt;-fortable
                                i_forkey     = &lt;fs_join_field&gt;-forkey
                                i_checktable = &lt;fs_join_field&gt;-checktable
                                i_checkfield = &lt;fs_join_field&gt;-checkfield ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;get_join_fields

  METHOD set_join_table.
    me-&gt;v_join_table = i_table.
  ENDMETHOD.                    &quot;set_join_table
  METHOD get_join_table.
    return = me-&gt;v_join_table.
  ENDMETHOD.                    &quot;get_join_table
  &quot;$. Endregion Getters and Setters

  METHOD compute_join_fields.
    DATA: l_tabname TYPE string.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.
    LOOP AT me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt;.
      l_tabname = &lt;fs_join_field&gt;-fortable.
      &lt;fs_join_field&gt;-dd_handle_forkey = me-&gt;get_field_handle( l_tabname ).
      &lt;fs_join_field&gt;-dd_handle_checktable = 2.
      l_tabname = &lt;fs_join_field&gt;-checktable.
      &lt;fs_join_field&gt;-dd_handle_checkfield = me-&gt;get_field_handle( l_tabname ).
      &lt;fs_join_field&gt;-style = me-&gt;get_style_block_fields( ).
    ENDLOOP.
  ENDMETHOD.                    &quot;compute_join_fields

  METHOD flush.
    IF NOT me-&gt;o_container IS INITIAL.
      me-&gt;o_grid-&gt;free( ).
      me-&gt;o_container-&gt;free( ).
    ENDIF.
    CLEAR: me-&gt;o_container, me-&gt;o_grid, me-&gt;t_join_fields, me-&gt;v_join_table,
           me-&gt;t_handle, me-&gt;t_drop_down.
  ENDMETHOD.                    &quot;flush

  METHOD lif_screen~user_command.
    DATA: o_error TYPE REF TO lcx_join_error.

    CASE i_ucomm.
      WHEN c_enter.
        TRY.
            me-&gt;check_join_fields( ).
            LEAVE TO SCREEN 0.

          CATCH lcx_join_error INTO o_error.
            DATA: l_message    TYPE string,
                  wa_row_id    TYPE lvc_s_row,
                  wa_column_id TYPE lvc_s_col,
                  wa_row_no    TYPE lvc_s_roid .
            l_message = o_error-&gt;get_message( ).
            wa_row_no-row_id = wa_row_id-index = o_error-&gt;get_index( ).
            wa_column_id-fieldname = o_error-&gt;get_field( ).
            me-&gt;o_grid-&gt;set_current_cell_via_id( is_row_id    = wa_row_id
                                                is_column_id = wa_column_id
                                                is_row_no    = wa_row_no ).
            lcl_message=&gt;report_message( i_msg     = l_message
                                         i_type    = &apos;S&apos;
                                         i_disp_as = &apos;E&apos; ).
        ENDTRY.


    ENDCASE.
  ENDMETHOD.                    &quot;lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS &apos;PF_0700&apos;.
  ENDMETHOD.                    &quot;lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me-&gt;o_container IS INITIAL.
      me-&gt;initialize_container( ).
      me-&gt;initialize_alv( ).

    ENDIF.
  ENDMETHOD.                    &quot;lif_screen~initialize_screen

  METHOD initialize_container.
    CREATE OBJECT me-&gt;o_container
      EXPORTING
        container_name = &apos;CONTAINER_JOIN&apos;.
  ENDMETHOD.                    &quot;initialize_container

  METHOD initialize_alv.
    DATA: o_handler  TYPE REF TO lcl_event_handler,
          t_fieldcat TYPE lvc_t_fcat,
          t_exclude  TYPE ui_functions,
          t_drop_down TYPE lvc_t_drop,
          wa_layout  TYPE lvc_s_layo.

    CREATE OBJECT me-&gt;o_grid
      EXPORTING
        i_parent = me-&gt;o_container.

    t_fieldcat  = me-&gt;create_fieldcat( ).
    t_exclude   = me-&gt;exclude_functions( ).
    t_drop_down = me-&gt;t_drop_down.
    wa_layout-stylefname = &apos;STYLE&apos;.

    CREATE OBJECT o_handler.
    SET HANDLER: o_handler-&gt;handle_toolbar_join      FOR me-&gt;o_grid,
                 o_handler-&gt;handle_user_command_join FOR me-&gt;o_grid,
                 o_handler-&gt;handle_data_change_join  FOR me-&gt;o_grid.

    me-&gt;o_grid-&gt;set_ready_for_input( 1 ).
    me-&gt;o_grid-&gt;set_drop_down_table( EXPORTING it_drop_down = t_drop_down ).
    me-&gt;o_grid-&gt;register_edit_event( cl_gui_alv_grid=&gt;mc_evt_modified ).
    me-&gt;o_grid-&gt;set_table_for_first_display( EXPORTING
                                               is_layout            = wa_layout
                                               it_toolbar_excluding = t_exclude
                                             CHANGING
                                               it_fieldcatalog      = t_fieldcat
                                               it_outtab            = me-&gt;t_join_fields ).

  ENDMETHOD.                    &quot;initialize_alv

  METHOD create_fieldcat.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat.

    CREATE OBJECT o_fieldcat.

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;FORTABLE&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Table Name&apos;
                                   i_outputlen  = 20 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;FORKEY&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Field Name&apos;
                                   i_drdn_field = &apos;DD_HANDLE_FORKEY&apos;
                                   i_checktable = &apos;!&apos;
                                   i_outputlen  = 20 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;SIGNAL&apos;
                                   i_edit       = abap_false
                                   i_descr      = space
                                   i_just       = &apos;C&apos;
                                   i_outputlen  = 2 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;CHECKTABLE&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Table Name&apos;
                                   i_drdn_field = &apos;DD_HANDLE_CHECKTABLE&apos;
                                   i_checktable = &apos;!&apos;
                                   i_outputlen  = 20 ).

    o_fieldcat-&gt;add_field_to_fcat( i_fieldname  = &apos;CHECKFIELD&apos;
                                   i_edit       = abap_true
                                   i_descr      = &apos;Field Name&apos;
                                   i_drdn_field = &apos;DD_HANDLE_CHECKFIELD&apos;
                                   i_checktable = &apos;!&apos;
                                   i_outputlen  = 20 ).

    return = o_fieldcat-&gt;get_fieldcat( ).

  ENDMETHOD.                    &quot;create_fieldcat

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=&gt;mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    &quot;exclude_functions

  METHOD refresh_alv.
    me-&gt;o_grid-&gt;refresh_table_display( is_stable      = i_stable
                                       i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    &quot;refresh_alv

  METHOD add_line.
    DATA: l_tabname TYPE string.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.
    APPEND INITIAL LINE TO me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt;.
    l_tabname = me-&gt;get_join_table( ).
    &lt;fs_join_field&gt;-fortable = l_tabname.
    &lt;fs_join_field&gt;-signal   = &apos;=&apos;.
    &lt;fs_join_field&gt;-style    = me-&gt;get_style_block_fields( ).
    &lt;fs_join_field&gt;-dd_handle_forkey = me-&gt;get_field_handle( l_tabname ).
    &lt;fs_join_field&gt;-dd_handle_checktable = 2.
    UNASSIGN &lt;fs_join_field&gt;.
  ENDMETHOD.                    &quot;add_line

  METHOD delete_line.
    DATA: t_index_rows  TYPE lvc_t_row,
          t_aux         TYPE tyt_join_fields,
          l_answer      TYPE c.

    FIELD-SYMBOLS: &lt;fs_index_row&gt; TYPE lvc_s_row,
                   &lt;fs_aux&gt;       TYPE ty_join_fields.

    me-&gt;o_grid-&gt;get_selected_rows( IMPORTING et_index_rows  = t_index_rows ).
    IF t_index_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    l_answer = lcl_message=&gt;user_choice( i_title    = &apos;Delete Join Fields&apos;
                                         i_question = &apos;Delete selected lines?&apos;
                                         i_option_1 = &apos;Yes&apos;
                                         i_option_2 = &apos;No&apos;
                                         i_icon     = &apos;@M_QUES@&apos; ).
    CHECK l_answer = &apos;1&apos;.

    LOOP AT t_index_rows ASSIGNING &lt;fs_index_row&gt;.
      READ TABLE me-&gt;t_join_fields ASSIGNING &lt;fs_aux&gt; INDEX &lt;fs_index_row&gt;-index.
      IF sy-subrc IS INITIAL.
        APPEND &lt;fs_aux&gt; TO t_aux.
      ENDIF.
    ENDLOOP.

    LOOP AT t_aux ASSIGNING &lt;fs_aux&gt;.
      READ TABLE me-&gt;t_join_fields WITH KEY fortable   = &lt;fs_aux&gt;-fortable
                                            forkey     = &lt;fs_aux&gt;-forkey
                                            checktable = &lt;fs_aux&gt;-checktable
                                            checkfield = &lt;fs_aux&gt;-checkfield TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        DELETE me-&gt;t_join_fields INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;delete_line

  METHOD get_style_block_fields.
    DATA: wa_style TYPE lvc_s_styl.
    wa_style-style = cl_gui_alv_grid=&gt;mc_style_disabled.
    wa_style-fieldname = &apos;FORTABLE&apos;.
    APPEND wa_style TO return.
    wa_style-fieldname = &apos;SIGNAL&apos;.
    APPEND wa_style TO return.
  ENDMETHOD.                    &quot;get_style_block_fields

  METHOD consist_tables.
    DATA: o_table        TYPE REF TO lcl_table,
          t_tables       TYPE salv_wd_t_string,
          t_fields       TYPE tyt_table_fields,
          l_tabname      TYPE string,
          l_field_handle TYPE i VALUE 2.

    FIELD-SYMBOLS &lt;fs_field&gt; TYPE ty_table_fields.

    t_tables = i_tables.
    l_tabname = me-&gt;get_join_table( ).

    LOOP AT t_tables INTO l_tabname.
      CHECK l_tabname &lt;&gt; me-&gt;get_join_table( ).
      me-&gt;add_dropdown( i_handle = 2
                        i_value  = l_tabname ).
    ENDLOOP.

    LOOP AT t_tables INTO l_tabname.
      CLEAR t_fields.
      CREATE OBJECT o_table
        EXPORTING
          i_name = l_tabname.
      o_table-&gt;get_table_fields( IMPORTING e_fields = t_fields ).

      ADD 1 TO l_field_handle.

      IF l_tabname = me-&gt;get_join_table( ).
        me-&gt;add_handle( i_tabname       = l_tabname
                        i_tab_handle    = 1
                        i_fields_handle = l_field_handle ).
      ELSE.
        me-&gt;add_handle( i_tabname       = l_tabname
                        i_tab_handle    = 2
                        i_fields_handle = l_field_handle ).
      ENDIF.

      me-&gt;add_dropdown( i_handle = l_field_handle
                        i_fields = t_fields ).
    ENDLOOP.

  ENDMETHOD.                    &quot;consist_tables

  METHOD add_handle.
    FIELD-SYMBOLS &lt;fs_handle&gt; TYPE ty_handle.
    APPEND INITIAL LINE TO me-&gt;t_handle ASSIGNING &lt;fs_handle&gt;.
    &lt;fs_handle&gt;-tabname       = i_tabname.
    &lt;fs_handle&gt;-tab_handle    = i_tab_handle.
    &lt;fs_handle&gt;-fields_handle = i_fields_handle.
    UNASSIGN &lt;fs_handle&gt;.
  ENDMETHOD.                    &quot;add_handle

  METHOD add_dropdown.
    FIELD-SYMBOLS: &lt;fs_drop_down&gt; TYPE lvc_s_drop,
                   &lt;fs_field&gt; TYPE ty_table_fields.
    IF NOT i_fields IS INITIAL.
      LOOP AT i_fields ASSIGNING &lt;fs_field&gt;.
        APPEND INITIAL LINE TO me-&gt;t_drop_down ASSIGNING &lt;fs_drop_down&gt;.
        &lt;fs_drop_down&gt;-handle = i_handle.
        &lt;fs_drop_down&gt;-value = &lt;fs_field&gt;-fieldname.
        UNASSIGN &lt;fs_drop_down&gt;.
      ENDLOOP.
    ELSE.
      APPEND INITIAL LINE TO me-&gt;t_drop_down ASSIGNING &lt;fs_drop_down&gt;.
      &lt;fs_drop_down&gt;-handle = i_handle.
      &lt;fs_drop_down&gt;-value = i_value.
      UNASSIGN &lt;fs_drop_down&gt;.
    ENDIF.
  ENDMETHOD.                    &quot;add_dropdown

  METHOD get_field_handle.
    FIELD-SYMBOLS &lt;fs_handle&gt; TYPE ty_handle.
    READ TABLE me-&gt;t_handle ASSIGNING &lt;fs_handle&gt; WITH KEY tabname = i_tabname.
    IF sy-subrc IS INITIAL.
      return = &lt;fs_handle&gt;-fields_handle.
    ENDIF.
  ENDMETHOD.                    &quot;get_field_handle

  METHOD set_handle_checkfield.
    FIELD-SYMBOLS &lt;fs_join_field&gt; TYPE ty_join_fields.
    READ TABLE me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt; INDEX i_index.
    IF sy-subrc IS INITIAL.
      IF i_value IS INITIAL.
        CLEAR &lt;fs_join_field&gt;-dd_handle_checkfield.
      ELSE.
        &lt;fs_join_field&gt;-dd_handle_checkfield = me-&gt;get_field_handle( i_value ).
      ENDIF.
    ENDIF.
  ENDMETHOD.                    &quot;set_handle_checkfield

  METHOD check_join_fields.
    DATA: l_message TYPE string,
          l_field   TYPE string.
    FIELD-SYMBOLS: &lt;fs_join_field&gt; TYPE ty_join_fields.

    me-&gt;o_grid-&gt;check_changed_data( ).

    LOOP AT me-&gt;t_join_fields ASSIGNING &lt;fs_join_field&gt;.
      IF &lt;fs_join_field&gt;-forkey IS INITIAL.
        l_message = &apos;Join field is required.&apos;.
        l_field = &apos;FORKEY&apos;.

      ELSEIF NOT &lt;fs_join_field&gt;-checktable IS INITIAL AND &lt;fs_join_field&gt;-checkfield IS INITIAL.
        l_message = &apos;Join field is required.&apos;.
        l_field = &apos;CHECKFIELD&apos;.

      ENDIF.

      IF NOT l_message IS INITIAL.
        RAISE EXCEPTION TYPE lcx_join_error
          EXPORTING
            i_index   = sy-tabix
            i_field   = l_field
            i_message = l_message.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.                    &quot;check_join_fields

ENDCLASS.               &quot;lcl_screen_700</source>
 </PROG>
</nugget>
